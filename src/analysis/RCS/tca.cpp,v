head	1.188;
access;
symbols;
locks
	suan:1.188; strict;
comment	@// @;


1.188
date	2004.07.19.22.59.54;	author suan;	state Exp;
branches;
next	1.187;

1.187
date	2004.07.19.21.13.08;	author suan;	state Exp;
branches;
next	1.186;

1.186
date	2004.07.16.19.46.35;	author suan;	state Exp;
branches;
next	1.185;

1.185
date	2004.07.05.18.29.24;	author suan;	state Exp;
branches;
next	1.184;

1.184
date	2004.07.01.23.36.01;	author suan;	state Exp;
branches;
next	1.183;

1.183
date	2004.07.01.14.05.11;	author suan;	state Exp;
branches;
next	1.182;

1.182
date	2004.06.29.20.02.32;	author suan;	state Exp;
branches;
next	1.181;

1.181
date	2004.06.28.22.20.13;	author suan;	state Exp;
branches;
next	1.180;

1.180
date	2004.06.23.17.16.49;	author suan;	state Exp;
branches;
next	1.179;

1.179
date	2004.06.23.14.57.00;	author suan;	state Exp;
branches;
next	1.178;

1.178
date	2004.06.15.18.55.35;	author suan;	state Exp;
branches;
next	1.177;

1.177
date	2004.05.24.20.08.15;	author suan;	state Exp;
branches;
next	1.176;

1.176
date	2004.05.24.19.48.33;	author suan;	state Exp;
branches;
next	1.175;

1.175
date	2004.05.24.19.10.09;	author suan;	state Exp;
branches;
next	1.174;

1.174
date	2004.05.20.19.24.22;	author suan;	state Exp;
branches;
next	1.173;

1.173
date	2004.05.19.16.59.58;	author suan;	state Exp;
branches;
next	1.172;

1.172
date	2004.05.19.15.21.08;	author suan;	state Exp;
branches;
next	1.171;

1.171
date	2004.05.18.23.32.36;	author suan;	state Exp;
branches;
next	1.170;

1.170
date	2004.05.18.21.37.54;	author suan;	state Exp;
branches;
next	1.169;

1.169
date	2004.05.17.22.34.44;	author suan;	state Exp;
branches;
next	1.168;

1.168
date	2004.05.14.22.41.56;	author suan;	state Exp;
branches;
next	1.167;

1.167
date	2004.05.13.19.19.32;	author suan;	state Exp;
branches;
next	1.166;

1.166
date	2004.05.12.21.17.22;	author suan;	state Exp;
branches;
next	1.165;

1.165
date	2004.05.12.18.53.04;	author suan;	state Exp;
branches;
next	1.164;

1.164
date	2004.05.11.22.26.15;	author suan;	state Exp;
branches;
next	1.163;

1.163
date	2004.05.11.21.50.54;	author suan;	state Exp;
branches;
next	1.162;

1.162
date	2004.05.11.15.01.15;	author suan;	state Exp;
branches;
next	1.161;

1.161
date	2004.05.10.14.50.59;	author suan;	state Exp;
branches;
next	1.160;

1.160
date	2004.05.08.23.04.16;	author suan;	state Exp;
branches;
next	1.159;

1.159
date	2004.05.08.17.34.35;	author suan;	state Exp;
branches;
next	1.158;

1.158
date	2004.05.07.23.30.14;	author suan;	state Exp;
branches;
next	1.157;

1.157
date	2004.05.07.21.21.52;	author suan;	state Exp;
branches;
next	1.156;

1.156
date	2004.05.07.19.52.39;	author suan;	state Exp;
branches;
next	1.155;

1.155
date	2004.05.07.18.54.14;	author suan;	state Exp;
branches;
next	1.154;

1.154
date	2004.05.03.22.56.17;	author suan;	state Exp;
branches;
next	1.153;

1.153
date	2004.05.03.20.45.59;	author suan;	state Exp;
branches;
next	1.152;

1.152
date	2004.05.02.20.13.09;	author suan;	state Exp;
branches;
next	1.151;

1.151
date	2004.04.21.18.59.26;	author suan;	state Exp;
branches;
next	1.150;

1.150
date	2004.04.14.16.12.19;	author suan;	state Exp;
branches;
next	1.149;

1.149
date	2004.04.02.16.15.41;	author suan;	state Exp;
branches;
next	1.148;

1.148
date	2004.03.31.18.38.07;	author suan;	state Exp;
branches;
next	1.147;

1.147
date	2004.03.31.15.18.37;	author suan;	state Exp;
branches;
next	1.146;

1.146
date	2004.03.29.20.29.06;	author suan;	state Exp;
branches;
next	1.145;

1.145
date	2004.03.29.17.17.32;	author suan;	state Exp;
branches;
next	1.144;

1.144
date	2004.03.29.02.24.42;	author suan;	state Exp;
branches;
next	1.143;

1.143
date	2004.03.28.20.53.05;	author suan;	state Exp;
branches;
next	1.142;

1.142
date	2004.03.18.21.21.28;	author suan;	state Exp;
branches;
next	1.141;

1.141
date	2004.03.18.19.33.42;	author suan;	state Exp;
branches;
next	1.140;

1.140
date	2004.03.03.00.45.32;	author suan;	state Exp;
branches;
next	1.139;

1.139
date	2004.02.24.00.31.28;	author suan;	state Exp;
branches;
next	1.138;

1.138
date	2004.02.19.14.37.04;	author suan;	state Exp;
branches;
next	1.137;

1.137
date	2004.02.19.00.39.16;	author suan;	state Exp;
branches;
next	1.136;

1.136
date	2004.02.18.16.06.52;	author suan;	state Exp;
branches;
next	1.135;

1.135
date	2004.01.30.22.29.54;	author suan;	state Exp;
branches;
next	1.134;

1.134
date	2003.12.16.22.57.18;	author suan;	state Exp;
branches;
next	1.133;

1.133
date	2003.12.15.22.58.07;	author suan;	state Exp;
branches;
next	1.132;

1.132
date	2003.12.11.17.31.28;	author suan;	state Exp;
branches;
next	1.131;

1.131
date	2003.12.10.15.39.51;	author suan;	state Exp;
branches;
next	1.130;

1.130
date	2003.12.06.01.38.01;	author suan;	state Exp;
branches;
next	1.129;

1.129
date	2003.11.18.20.47.16;	author suan;	state Exp;
branches;
next	1.128;

1.128
date	2003.11.14.15.58.36;	author suan;	state Exp;
branches;
next	1.127;

1.127
date	2003.11.12.17.42.12;	author suan;	state Exp;
branches;
next	1.126;

1.126
date	2003.11.12.00.10.31;	author suan;	state Exp;
branches;
next	1.125;

1.125
date	2003.11.07.20.39.42;	author suan;	state Exp;
branches;
next	1.124;

1.124
date	2003.11.06.20.57.39;	author suan;	state Exp;
branches;
next	1.123;

1.123
date	2003.11.05.21.26.08;	author suan;	state Exp;
branches;
next	1.122;

1.122
date	2003.11.05.19.53.11;	author suan;	state Exp;
branches;
next	1.121;

1.121
date	2003.11.05.19.45.57;	author suan;	state Exp;
branches;
next	1.120;

1.120
date	2003.10.29.23.12.11;	author suan;	state Exp;
branches;
next	1.119;

1.119
date	2003.10.24.22.40.50;	author suan;	state Exp;
branches;
next	1.118;

1.118
date	2003.10.21.21.32.17;	author suan;	state Exp;
branches;
next	1.117;

1.117
date	2003.10.08.23.31.07;	author suan;	state Exp;
branches;
next	1.116;

1.116
date	2003.10.02.19.31.00;	author suan;	state Exp;
branches;
next	1.115;

1.115
date	2003.06.20.22.07.16;	author suan;	state Exp;
branches;
next	1.114;

1.114
date	2003.06.18.20.08.46;	author suan;	state Exp;
branches;
next	1.113;

1.113
date	2003.06.16.19.03.12;	author suan;	state Exp;
branches;
next	1.112;

1.112
date	2003.06.11.23.09.46;	author suan;	state Exp;
branches;
next	1.111;

1.111
date	2003.03.26.15.53.05;	author suan;	state Exp;
branches;
next	1.110;

1.110
date	2003.03.20.00.03.06;	author suan;	state Exp;
branches;
next	1.109;

1.109
date	2003.02.27.00.54.40;	author suan;	state Exp;
branches;
next	1.108;

1.108
date	2003.02.26.21.11.26;	author suan;	state Exp;
branches;
next	1.107;

1.107
date	2003.02.25.23.07.35;	author suan;	state Exp;
branches;
next	1.106;

1.106
date	2003.02.25.22.39.31;	author suan;	state Exp;
branches;
next	1.105;

1.105
date	2003.02.25.21.50.19;	author suan;	state Exp;
branches;
next	1.104;

1.104
date	2003.02.25.20.04.46;	author suan;	state Exp;
branches;
next	1.103;

1.103
date	2003.02.24.22.54.57;	author suan;	state Exp;
branches;
next	1.102;

1.102
date	2003.02.22.00.05.44;	author suan;	state Exp;
branches;
next	1.101;

1.101
date	2003.02.17.19.29.23;	author suan;	state Exp;
branches;
next	1.100;

1.100
date	2003.02.12.21.12.14;	author suan;	state Exp;
branches;
next	1.99;

1.99
date	2003.02.04.15.42.52;	author suan;	state Exp;
branches;
next	1.98;

1.98
date	2003.02.03.21.56.42;	author suan;	state Exp;
branches;
next	1.97;

1.97
date	2003.01.17.20.15.48;	author suan;	state Exp;
branches;
next	1.96;

1.96
date	2003.01.16.19.30.49;	author suan;	state Exp;
branches;
next	1.95;

1.95
date	2003.01.16.17.45.59;	author suan;	state Exp;
branches;
next	1.94;

1.94
date	2003.01.14.21.51.09;	author suan;	state Exp;
branches;
next	1.93;

1.93
date	2003.01.14.21.10.06;	author suan;	state Exp;
branches;
next	1.92;

1.92
date	2003.01.03.18.57.49;	author suan;	state Exp;
branches;
next	1.91;

1.91
date	2002.12.20.20.59.32;	author suan;	state Exp;
branches;
next	1.90;

1.90
date	2002.12.19.22.03.44;	author suan;	state Exp;
branches;
next	1.89;

1.89
date	2002.12.19.19.44.08;	author suan;	state Exp;
branches;
next	1.88;

1.88
date	2002.12.19.00.24.06;	author suan;	state Exp;
branches;
next	1.87;

1.87
date	2002.12.18.00.24.34;	author suan;	state Exp;
branches;
next	1.86;

1.86
date	2002.12.16.23.32.57;	author suan;	state Exp;
branches;
next	1.85;

1.85
date	2002.12.16.22.43.50;	author suan;	state Exp;
branches;
next	1.84;

1.84
date	2002.12.11.21.31.34;	author suan;	state Exp;
branches;
next	1.83;

1.83
date	2002.12.11.17.43.59;	author suan;	state Exp;
branches;
next	1.82;

1.82
date	2002.11.29.21.26.17;	author suan;	state Exp;
branches;
next	1.81;

1.81
date	2002.11.29.16.45.56;	author suan;	state Exp;
branches;
next	1.80;

1.80
date	2002.11.27.22.21.34;	author suan;	state Exp;
branches;
next	1.79;

1.79
date	2002.11.27.19.52.44;	author suan;	state Exp;
branches;
next	1.78;

1.78
date	2002.11.27.00.26.55;	author suan;	state Exp;
branches;
next	1.77;

1.77
date	2002.11.26.23.17.13;	author suan;	state Exp;
branches;
next	1.76;

1.76
date	2002.11.25.19.30.25;	author suan;	state Exp;
branches;
next	1.75;

1.75
date	2002.11.22.19.55.46;	author suan;	state Exp;
branches;
next	1.74;

1.74
date	2002.11.21.21.07.34;	author suan;	state Exp;
branches;
next	1.73;

1.73
date	2002.11.21.20.44.57;	author suan;	state Exp;
branches;
next	1.72;

1.72
date	2002.11.21.18.39.07;	author suan;	state Exp;
branches;
next	1.71;

1.71
date	2002.11.21.00.35.53;	author suan;	state Exp;
branches;
next	1.70;

1.70
date	2002.11.18.22.49.59;	author suan;	state Exp;
branches;
next	1.69;

1.69
date	2002.11.18.22.15.52;	author suan;	state Exp;
branches;
next	1.68;

1.68
date	2002.11.18.16.43.13;	author suan;	state Exp;
branches;
next	1.67;

1.67
date	2002.11.15.22.07.32;	author suan;	state Exp;
branches;
next	1.66;

1.66
date	2002.11.15.17.49.43;	author suan;	state Exp;
branches;
next	1.65;

1.65
date	2002.11.14.21.26.46;	author suan;	state Exp;
branches;
next	1.64;

1.64
date	2002.11.13.01.42.39;	author suan;	state Exp;
branches;
next	1.63;

1.63
date	2002.11.12.00.44.01;	author suan;	state Exp;
branches;
next	1.62;

1.62
date	2002.11.11.22.23.34;	author suan;	state Exp;
branches;
next	1.61;

1.61
date	2002.11.07.00.40.47;	author suan;	state Exp;
branches;
next	1.60;

1.60
date	2002.11.06.20.03.20;	author suan;	state Exp;
branches;
next	1.59;

1.59
date	2002.11.05.21.20.30;	author suan;	state Exp;
branches;
next	1.58;

1.58
date	2002.10.31.16.58.17;	author suan;	state Exp;
branches;
next	1.57;

1.57
date	2002.10.30.20.47.39;	author suan;	state Exp;
branches;
next	1.56;

1.56
date	2002.10.29.17.14.08;	author suan;	state Exp;
branches;
next	1.55;

1.55
date	2002.10.28.22.02.27;	author suan;	state Exp;
branches;
next	1.54;

1.54
date	2002.10.23.20.26.57;	author suan;	state Exp;
branches;
next	1.53;

1.53
date	2002.10.21.18.23.51;	author suan;	state Exp;
branches;
next	1.52;

1.52
date	2002.10.21.00.02.07;	author suan;	state Exp;
branches;
next	1.51;

1.51
date	2002.10.17.15.51.44;	author suan;	state Exp;
branches;
next	1.50;

1.50
date	2002.10.03.23.15.44;	author suan;	state Exp;
branches;
next	1.49;

1.49
date	2002.09.18.15.35.20;	author suan;	state Exp;
branches;
next	1.48;

1.48
date	2002.08.22.13.50.39;	author suan;	state Exp;
branches;
next	1.47;

1.47
date	2002.08.19.14.22.25;	author suan;	state Exp;
branches;
next	1.46;

1.46
date	2002.08.18.22.13.53;	author suan;	state Exp;
branches;
next	1.45;

1.45
date	2002.08.18.21.38.13;	author suan;	state Exp;
branches;
next	1.44;

1.44
date	2002.08.18.21.30.13;	author suan;	state Exp;
branches;
next	1.43;

1.43
date	2002.08.18.16.15.21;	author suan;	state Exp;
branches;
next	1.42;

1.42
date	2002.08.16.23.20.35;	author suan;	state Exp;
branches;
next	1.41;

1.41
date	2002.08.16.21.56.08;	author suan;	state Exp;
branches;
next	1.40;

1.40
date	2002.08.16.20.28.52;	author suan;	state Exp;
branches;
next	1.39;

1.39
date	2002.08.16.16.57.31;	author suan;	state Exp;
branches;
next	1.38;

1.38
date	2002.08.15.23.39.23;	author suan;	state Exp;
branches;
next	1.37;

1.37
date	2002.08.15.21.16.25;	author suan;	state Exp;
branches;
next	1.36;

1.36
date	2002.08.15.16.50.54;	author suan;	state Exp;
branches;
next	1.35;

1.35
date	2002.08.15.16.22.23;	author suan;	state Exp;
branches;
next	1.34;

1.34
date	2002.08.15.14.34.17;	author suan;	state Exp;
branches;
next	1.33;

1.33
date	2002.08.14.23.03.01;	author suan;	state Exp;
branches;
next	1.32;

1.32
date	2002.08.14.19.32.14;	author suan;	state Exp;
branches;
next	1.31;

1.31
date	2002.08.12.20.18.11;	author suan;	state Exp;
branches;
next	1.30;

1.30
date	2002.08.10.21.26.24;	author suan;	state Exp;
branches;
next	1.29;

1.29
date	2002.07.30.19.48.50;	author suan;	state Exp;
branches;
next	1.28;

1.28
date	2002.07.30.18.16.24;	author suan;	state Exp;
branches;
next	1.27;

1.27
date	2002.07.30.13.31.45;	author suan;	state Exp;
branches;
next	1.26;

1.26
date	2002.07.30.13.27.06;	author suan;	state Exp;
branches;
next	1.25;

1.25
date	2002.07.29.22.33.35;	author suan;	state Exp;
branches;
next	1.24;

1.24
date	2002.07.29.16.18.09;	author suan;	state Exp;
branches;
next	1.23;

1.23
date	2002.07.28.21.37.24;	author suan;	state Exp;
branches;
next	1.22;

1.22
date	2002.07.25.15.48.48;	author suan;	state Exp;
branches;
next	1.21;

1.21
date	2002.05.26.05.43.21;	author suan;	state Exp;
branches;
next	1.20;

1.20
date	2002.05.25.18.58.05;	author suan;	state Exp;
branches;
next	1.19;

1.19
date	2002.05.23.22.44.23;	author suan;	state Exp;
branches;
next	1.18;

1.18
date	2002.05.21.21.50.48;	author suan;	state Exp;
branches;
next	1.17;

1.17
date	2002.05.16.20.32.06;	author suan;	state Exp;
branches;
next	1.16;

1.16
date	2002.05.08.23.24.24;	author suan;	state Exp;
branches;
next	1.15;

1.15
date	2002.04.25.18.01.17;	author suan;	state Exp;
branches;
next	1.14;

1.14
date	2002.04.24.21.56.10;	author suan;	state Exp;
branches;
next	1.13;

1.13
date	2002.04.19.23.54.05;	author suan;	state Exp;
branches;
next	1.12;

1.12
date	2002.04.19.16.45.01;	author suan;	state Exp;
branches;
next	1.11;

1.11
date	2002.04.18.17.06.19;	author suan;	state Exp;
branches;
next	1.10;

1.10
date	2002.04.18.15.55.32;	author suan;	state Exp;
branches;
next	1.9;

1.9
date	2002.04.16.22.43.51;	author suan;	state Exp;
branches;
next	1.8;

1.8
date	2002.04.16.20.57.21;	author suan;	state Exp;
branches;
next	1.7;

1.7
date	2002.04.16.20.06.53;	author suan;	state Exp;
branches;
next	1.6;

1.6
date	2002.04.12.22.48.38;	author suan;	state Exp;
branches;
next	1.5;

1.5
date	2002.04.12.17.18.13;	author suan;	state Exp;
branches;
next	1.4;

1.4
date	2002.04.11.17.13.14;	author suan;	state Exp;
branches;
next	1.3;

1.3
date	2002.04.11.04.21.43;	author suan;	state Exp;
branches;
next	1.2;

1.2
date	2002.04.10.17.01.25;	author suan;	state Exp;
branches;
next	1.1;

1.1
date	2002.04.10.16.19.04;	author suan;	state Exp;
branches;
next	;


desc
@Top-level analysis class; currently includes main, but
that may change.
@


1.188
log
@Added -mbu-intra-iref flag to collect iref in addition
to gref, and to just use iref for MBU analysis -- hopefully
will lead to smaller facts and faster analysis.
Also: observed that "gmodref_skip_locals" has been set
all along (for ran?), so mbu may not have been correct??
Fixed --- at least partially, for mbu --- I think...
@
text
@#include <ctype.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h> // for strtoul

#include "flags.h"
#include "diag.h"
#include "ao.h"
#include "tca.h"
#include "pta.h"
#include "ecr.h"
#include "cfg.h"
#include "dfa.h"
#include "ran.h"
#include "pmbu.h"

//------------------------------------------------------
//- Global flags

//- -ptr or -ptrw mode?
bool flag_readwrite = true;

//- fix nargs: use when there is clash in number of function arguments
bool flag_use_maxnargs = true;

//- do address-taken analysis (no points-to analysis)
bool flag_do_addr_taken = false;

//- (ptr/w mode): all dereferences are unsafe (i.e., only compute tracked)
bool flag_all_deref_unsafe = false;

//- verbose output level
int flag_verbose = 0;

//- recycle nodes whenever possible
bool flag_recycle = true;

//- output readable names rather than Tid/Pid
bool flag_readable_output = false;

//- compute GREF and filter call nodes
bool flag_gref_filter = true;

//- GMOD/GREF should skip locals
bool flag_gmodref_skip_locals = true;

//- treat string literals as read-only
bool flag_strlit_readonly = true;

//- tsl analysis: mark stringlit as invalid:
//  this is set to flag_strlit_readonly in -ptrw mode
bool flag_mark_strlit_invalid = false;

//- ptr(w): 0=ignore heap/stack, 1=freed-heap unsafe, 2=heap+stack unsafe
int flag_heapstack = 0;

//- mbu analysis level
int flag_may_be_uninit = 0;

//- mbu intra-procedural or inter-procedural
static bool flag_mbu_inter = true;	//- keep local to this file

//- pmbu flow-sensitive or flow-insensitive
static bool flag_pmbu_sensitive = false;	//- keep local to this file

//- do reaching-defs analysis
bool flag_reaching_defs = false;

//- treat verifyTag as fixing types on mismatch? (for nt:mbu,red)
bool flag_vtfix = false;

//- keep iref sets around (currently needed only by mbu)
bool flag_compute_iref = false;

//- do redundant-check analysis
bool flag_redundant = false;

//- red: handle parallel 2 rounds?
bool flag_red_paral2r = true;

//- do range analysis
bool flag_range = false;

//- range do intra-procedural or inter-procedural
static bool flag_range_inter = false;	//- keep local to this file

//- range analysis: do narrowing phase
bool flag_range_do_narrow = true;

//- range analysis: do widen/narrow always or on backedge only
bool flag_range_widen_always = false;
bool flag_range_narrow_always = true;

//- range analysis: compute backedge filter for better widening
//  ~~ separate flag to control (inter-procedural) loop backedge
//     and callgraph backedge
//  ~~ Notice different default behaviors!
bool flag_range_filter_loop_backedge = true;
bool flag_range_filter_call_backedge = false;

//- range analysis: treat zero specially, i.e. use "has_zero" flag in Interval class
bool flag_range_zero_special = true;

//- range analysis: representation choices (default is "DO"):
bool flag_range_must_have_ao = false;	// true: ao=null implies bottom
bool flag_range_ty_can_change = true;	// true: ty can be adjusted
bool flag_range_do_sliding = true;	// true: allow sliding (only if ty-can-change)
bool flag_range_handle_preds = true;	// true: try to improve predicates
bool flag_range_skip_targeted_preds = false;	// true: don't intersect at predicates if either side is targeted
bool flag_range_exact_sizes = false;	// true: assume exact sizeof info
//- a note on must-have-ao vs. ty-can-change (quite confusing):
//  . if must-have-ao == true,  then ty-can-change==false => cannot change types at all
//  . if must-have-ao == false, then ty-can-change==false => just cannot do xform(1a')
//
//- SO: | must-have-ao | ty-can-change | is
//  ----+--------------+---------------+----------------
//   A. |     true     |     true      | LO + ty-change + xform(1a')
//   B. |     true     |     false     | LO
//   C. |     false    |     true      | DO
//   D. |     false    |     false     | DO - xform(1a')
//- C-D = xform(1a')
//- C-A = unknown-target

//- range analysis: collect stats
bool flag_range_collect_stats = false;

//- vuln mode: write vulnerable locations and dereferences
bool flag_vuln = true;

//- range analysis: set this to true when entering "collecting" phase.
bool flag_debug_range_collect_phase = false;

//- range analysis: account for malloc sizes (whenever possible)
bool flag_range_handle_malloc = true;

//- points-to analysis: do online cycle detection and collapsing
//- NOTE: as implemented, it's unclear whether the incl-to and
//        pts-to cycle-elimination will clash, so be warned.
//	  empirically, at least, they survived with each other.
//  Note that as of nov 2003, -cde-incl appears buggy, while
//	 -cde-pt looks ok.
bool flag_collapse_inclto_cycle = true;
bool flag_collapse_ptsto_cycle = true;

//- dfa worklist mode (see flags.h for modes)
enum wl_mode flag_worklist_mode = WL_MODE_LEAF_FIRST;

//- instantiate all struct/union members during setStaticType (declaration)
bool flag_instantiate_structunion = true;

//- dfa filter relevant AOs during analysis (used by MBU, RAN)
bool flag_filter_relevant_aos = false;

//- dfa worklist initialize depth first, or by traverse id (more or less topological)
bool flag_worklist_init_depth_first = false;

//- mbu: perform lowerThan by comparing size only
bool flag_mbu_lowerthan_by_size = false;

//- dfa: on function call, ignore pre-call facts?
//  (optimistic; unsafe when recursive? -- recursion OK now)
bool flag_callsite_top = true;

//- dfa: use basic blocks
bool flag_use_bblocks = false;

//------------------------------------------------------
//- TCAstate

void TCAstate::processFile(char * filename)
{
  FILE * inf = fopen(filename, "r");
  if(!inf){
    fprintf(stderr, "Error opening input file %s\n", filename);
  } else {
    static int nlctr = 0;
    if(!((nlctr++)%5)) fprintf(stderr, "\n");
    fprintf(stderr, "(%s)", filename);

    char buf[TCA_BUF_SIZE];

    IDmap aidmap, pidmap;
    InputState istate(inf, aidmap, pidmap, values);

    TCtype * tgtty = 0;
    AO * aotgt = 0;

    fgets(buf, TCA_BUF_SIZE, inf);
    while(!feof(inf)){
      switch(*buf){
        case ':': { //- assign target
            char * cp = &buf[2];
	    tgtty = TCtype::stringToTy(cp, &cp);
            aotgt = AO::stringToAO(cp, &cp, aidmap, pidmap, values);
            if(aotgt && !tgtty) tgtty = &TCtype::tcVoidType; //-- error
          } break;
        case '=':   //- 'true' assign source
        case '-': { //- 'pseudo' assign source
            char * cp = &buf[2];
            AO * aosrc = AO::stringToAO(cp, &cp, aidmap, pidmap, values);
            if(aosrc && aotgt){
              TCassignEdge * e = aosrc->assignTo(*aotgt, *tgtty);
              if(e) assigns.Append(e);
              if(*buf == '=') aosrc->setRequiredType(*tgtty); //-- add assignment type to reqd-type
            }
          } break;
        case '@@': { //- aid entry
            char sc = buf[2];
            char * cp = &buf[4];
            unsigned int aidno = strtoul(cp, &cp, 10);
            //- skip leading and trailing spaces
            while(isspace(*cp)) cp++;
            char * ep = cp + strlen(cp) - 1;
            while(isspace(*ep)) ep--;
            *(ep+1) = 0;
            //- get id, insert into aidmap
            ID& aid = aidtab.getID(cp,sc);
            aidmap.map(aidno, aid);
          } break;
        case '%': { //- pid entry
            char sc = buf[2];
            char * cp = &buf[4];
            unsigned int pidno = strtoul(cp, &cp, 10);
            //- skip leading and trailing spaces
            while(isspace(*cp)) cp++;
            char * ep = cp + strlen(cp) - 1;
            while(isspace(*ep)) ep--;
            *(ep+1) = 0;
            //- get id, insert into pidmap
            ID& pid = pidtab.getID(cp,sc);
            pidmap.map(pidno, pid);
          } break;
        case '+': { //- static type
            char * cp = &buf[2];
	    TCtype * ty = TCtype::stringToTy(cp, &cp);
            AO * ao = AO::stringToAO(cp, &cp, aidmap, pidmap, values);
            if(ao && ty) ao->setStaticType(*ty);
	  } break;
        case '}': { //- verify tag
            char * cp = &buf[2];
	    TCtype * ty = TCtype::stringToTy(cp, &cp);
            AO * ao = AO::stringToAO(cp, &cp, aidmap, pidmap, values);
            if(ao && ty) ao->setRequiredType(*ty); //- initialize reqd-type
	  } break;
        case ']': { //- verify pointer
            char * cp = &buf[2];
	    TCtype * ty = TCtype::stringToTy(cp, &cp);
            AO * ao = AO::stringToAO(cp, &cp, aidmap, pidmap, values);
            if(ao && ty) ao->setVerifyPtrType(*ty);
	  } break;
        case 'f':   //- normal function definition
        case 'v': { //- varg function definition
            char * cp = &buf[2];
            unsigned int largno = strtoul(cp, &cp, 10);
            AO * ao = AO::stringToAO(cp, &cp, aidmap, pidmap, values);
            if(ao && ao->getKind() == AO::aoFunction)
              ((AOFunction *)ao)->setAttributes(largno, *buf == 'v');
            else {
	      fprintf(stderr, "Invalid f directive, for object: ");
	      if(ao) ao->dump_descr(stderr);
	      else fprintf(stderr, "(null)");
	      fprintf(stderr, "\n");
	    }
	  } break;
        case '!': {
	    char * filestem = 0;
	    int i;
            for(i = strlen(filename) - 1; i >= 0 && filename[i] != '.'; --i);
            if(i >= 0){
              filestem = new char[i+1];
              strncpy(filestem, filename, i);
              filestem[i] = 0;
            } else filestem = filename;
	    cfg.read(istate, buf, filestem);
	  } break;
        case '$': //- ao alias -- not yet implemented
        case '~': //- type-safety level -- ignore (for now?)
        case '#': //- comment
        default : //- treat as comment
	  ;
      }
      fgets(buf, TCA_BUF_SIZE, inf);
    }
    fclose(inf);
  }
}

void TCAstate::traverseAOs(void (*fp)(AO&))
{
  values.traverseAOs(fp);
  aidtab.traverseAOs(fp);
  pidtab.traverseAOs(fp);
}

TCAstate::relaos_mode TCAstate::msp_relaos_mode;
DependencyMap TCAstate::msp_misc_dependencies;
suco_set<ECR *> TCAstate::msp_starting_ecrs;
int TCAstate::crao_total_aos = 0;
int TCAstate::crao_marked_aos = 0;
TClatRootSet TCAstate::possTypeConstraintRoots;
int TCAstate::poss_type_init_counter = 0;
int TCAstate::poss_type_assign_counter = 0;
int TCAstate::poss_type_incl_counter = 0;

void TCAstate::initPossTypeConstraintsAO(AO& ao)
{
  ECR& e = ao.getECR();
  switch(ao.getKind()){
    case AO::aoValue:{
        TCtype& valty = ((AOValue&)ao).getTy();
        TClatType& latty = possTypeConstraintRoots.getLatType(valty);
        e.possType().constrainLE(latty);
      } break;
    case AO::aoOp:{
        TCtype& opty = ((AOOp&)ao).getTy();
        TClatType& latty = possTypeConstraintRoots.getLatType(opty);
        e.possType().constrainLE(latty);
      } break;
    case AO::aoExt:{
        e.possType().constrainLE(possTypeConstraintRoots.getLatType(TClatRootSet::lrBottom));
      } break;
    case AO::aoAddrOf:{
        e.possType().constrainLE(possTypeConstraintRoots.getLatType(TClatRootSet::lrPointer));
      } break;
/*
    case AO::aoId:
    case AO::aoMalloc:
    case AO::aoSDot:
    case AO::aoUDot:
    case AO::aoReturn:
    case AO::aoArg:
    case AO::aoStar:
    case AO::aoStringLit:
    case AO::aoFunction:
*/
    default: break;	//- NOP
  }
  if(flag_verbose > 1){
    if(++poss_type_init_counter % 100 == 0) 
      fprintf(stderr, "."); 
    if(poss_type_init_counter % 5000 == 0) 
      fprintf(stderr, "\n");
  }     
  initPossTypeConstraintsInclusion(e);
}

void TCAstate::initPossTypeConstraintsInclusion(ECR& ecr)
{
  if(ecr.poss_type_incl_visited) return;
  ecr.poss_type_incl_visited = true;

  if(flag_verbose > 1)
    if(++poss_type_incl_counter % 100 == 0) 
      fprintf(stderr, "*"); 

  suco_iterator<ECR *> ii(ecr.inclToECRs());
  while(ii.Iterate()){
    ECR& recr = *ii.Current();
    ecr.possType().constrainLE(recr.possType());
    recr.writeType().constrainLE(ecr.writeType());
    initPossTypeConstraintsInclusion(recr);
  }
}

void TCAstate::initPossTypeConstraintsAssign(TCassignEdge& edge)
{
  ECR& fromECR = edge.getFrom().getECR();
  ECR& toECR = edge.getTo().getECR();
  if(&fromECR != &toECR){ // harmless optimization?
    ECR::traverseCounter++;
    fromECR.traverseTag = ECR::traverseCounter;

    toECR.writeType().constrainLE(fromECR.possType());

    if(flag_verbose > 1){
      if(++poss_type_assign_counter % 100 == 0) 
        fprintf(stderr, "."); 
      if(poss_type_assign_counter % 5000 == 0) 
        fprintf(stderr, "\n");
    }     
  }
  //- do inclusions
  initPossTypeConstraintsInclusion(fromECR);
}

void TCAstate::ptAnalysis()
{
  //----------------------------------------
  //-- PT analysis

  //- prelude: find max_nargs (if needed)
  if(flag_use_maxnargs){
    if(flag_verbose) TCstats::timer("computing maxnargs");
    traverseAOs(ECRargRet::findMaxNargs);
    if(flag_verbose) TCstats::timer(0);
    if(flag_verbose) fprintf(stderr, "(maxnargs = %d)\n", ECRargRet::getMaxNargs());
  }

  // - initialize ECRs
  if(flag_verbose) TCstats::timer("initializing ECRs");
  traverseAOs(PTanalysis::initializeECRbasic);
  if(flag_verbose) fprintf(stderr, "(basic)");
  traverseAOs(PTanalysis::initializeECRaggregate_collapseAlways);
  if(flag_verbose) fprintf(stderr, "(aggregate)");
  traverseAOs(PTanalysis::initializeECRpointers);
  if(flag_verbose) fprintf(stderr, "(pointers)\n");
  if(flag_verbose) TCstats::timer(0);

  TCstats::timer("points-to analysis collapse-always");
  PTanalysis::analyzeAssigns_collapseAlways(assigns);
  TCstats::timer(0);
}

void TCAstate::markInvalidNode(AO& ao)
{
  //-- initial invalid nodes are those pointed-to by VALUE, STRLIT, op and ext
  switch(ao.getKind()){
    case AO::aoValue:
    case AO::aoStringLit:
    case AO::aoOp:
    case AO::aoExt: {
	  //-- mark ECR invalid, propagate up incl edges, and propagate down derefs
	  ao.getECR().getPointsTo().markInvalid(true);
	} break;
    default:
	break;
  }
}

void TCAstate::markInvalidNodeNonNull(AO& ao)
{
  //-- initial non-null invalid nodes are those pointed-to by
  //	VALUE (excl VALUE_zero), STRLIT, op and ext
  switch(ao.getKind()){
    case AO::aoValue:
	if(((AOValue&)ao).getTy().getKind() == TCtype::tcZero){
	  break;
	} // else fallthrough!
    case AO::aoStringLit:
    case AO::aoOp:
    case AO::aoExt: {
	  //-- mark ECR invalid, propagate up incl edges, and propagate down derefs
	  ao.getECR().getPointsTo().markInvalid(true);
	} break;
    case AO::aoAddrOf: {
	  if(flag_mark_strlit_invalid
	     && (((AOAddrOf&)ao).getTarget().getKind() == AO::aoStringLit)){
	    ao.getECR().getPointsTo().markInvalid(true);
          }
	} break;
    default:
	break;
  }
}

//----------------------------------------------------
//-- insert return-node aliases! ( R D foo --incl--> R foo )

void TCAstate::addReturnNodeAliases(AO& ao)
{
  if(ao.getKind() == AO::aoReturn){
    AO& fpao = ((AOReturn&)ao).getParent();
    suco_set<ECR *> alias_ecrs;
    //- collect alias ecrs
    ECR::getECR(fpao).collectAliasECRs(alias_ecrs);	//- Still not safe to use getAliasECRs?
    //- for each alias ao that's a function, insert return-node alias ( R D foo --incl--> R foo )
    suco_iterator<ECR *> ei(alias_ecrs);
    while(ei.Iterate()){
      suco_iterator<AO *> ai(ei.Current()->getAOset());
      while(ai.Iterate()){
        if(ai.Current()->getKind() == AO::aoFunction){
          AO& ret = ((AOFunction *)ai.Current())->getTarget().get_AOReturn();
          ECR::getECR(ao).includesTo(ECR::getECR(ret));
        }
      }
    }
  }
}

//---------------------------------------
//-- Non-standard PT analysis-related stuff:
//   insert argRet assignment edges
void TCAstate::supplementalPTanalysis()
{
  //-- insert argRet assignment edges
  if(flag_verbose) TCstats::timer("adding Arg-Ret assignments");
  TCAstate::static_arg_ret_assigns = &arg_ret_assigns;
  traverseAOs(TCAstate::insertArgRetAssignEdges);
  if(flag_verbose) TCstats::timer(0);
  if(flag_verbose) fprintf(stderr, "(%d argrets processed)\n", insertArgRetAssignEdges_doneset.Length());

  //-- insert return-node aliases! ( R D foo --incl--> R foo )
  // - needed by flow-sensitive analysis/MBU (at least)
  if(flag_verbose) TCstats::timer("adding return-node aliases");
  traverseAOs(TCAstate::addReturnNodeAliases);
  if(flag_verbose) TCstats::timer(0);

  //-- finalize points-to graph: traverse AOs and
  //   fix ECR forward pointers
  TCstats::timer("finalizing points-to graph ECR pointers");
  ECR::traverseCounter++;
  traverseAOs(ECR::fixECR);
  ECR::garbageCollect();
  TCstats::timer(0);
}

suco_set<ECRargRet *> TCAstate::collectInclToArgRets_ECRs;

bool TCAstate::collectInclToArgRets(ECR& e)
{
  ECRargRet * ear = e.argRet();
  if(ear) collectInclToArgRets_ECRs.Insert(ear);
  return true; //-- true ensures full traversal
}

void TCAstate::addAssignEdges(ECR * lecr, ECR * recr, AO::aoKind kind)
{
  if(lecr && recr){
/**/if(lecr != &lecr->followECR()) fprintf(stderr, "WARNING(addAssignEdges): lecr != lecr->followECR()\n");
/**/if(recr != &recr->followECR()) fprintf(stderr, "WARNING(addAssignEdges): recr != recr->followECR()\n");
    suco_set<AO *>& laos = lecr->followECR().getAOset();
    suco_set<AO *>& raos = recr->followECR().getAOset();
    if(!laos.IsEmpty() && !raos.IsEmpty()){
      suco_iterator<AO *> li(laos); //-- note: laos may contain more than one member: due to unification?
      while(li.Iterate()){
        AO& lao = *li.Current();
        if(lao.getKind() == kind){ //- only do aoArg or aoReturn nodes
          suco_iterator<AO *> ri(raos); //-- note: raos may contain more than one member: due to unification?
          while(ri.Iterate()){
            AO& rao = *ri.Current();
            if(rao.getKind() == kind){
              TCtype * rst = rao.getStaticType();
              if(!rst){
                //- no static type: signal error?
                //~~ not if rao is AOArg[largno]
                if((rao.getKind() != AO::aoArg)
		  || (((AOArg&)rao).getParent().getKind() != AO::aoFunction)
		  || (((AOFunction&)((AOArg&)rao).getParent()).getLargNo() != ((AOArg&)rao).argNo())){
                  fprintf(stderr, "WARNING(addAssignEdges): no static type, setting to void type, in:\n  ");
                  lao.dump_descr(stderr);
                  fprintf(stderr, "\n  --ASSIGN--> ");
                  rao.dump_descr(stderr);
                  fprintf(stderr, "\n");
                }
                rst = &TCtype::tcVoidType;
              }
              TCassignEdge * edge = lao.assignTo(rao, *rst);
              if(edge) static_arg_ret_assigns->Append(edge);
	      lao.setRequiredType(*rst); //- add assignment type to reqd-type

            } // else (if not rao.getKind() == kind ) never happens
          }
        } // else ( if not  lao.getKind() == kind ) never happens
      }
    }
  }
}

suco_llist<TCassignEdge *> * TCAstate::static_arg_ret_assigns = 0;

suco_set<ECRargRet *> TCAstate::insertArgRetAssignEdges_doneset;

void TCAstate::insertArgRetAssignEdges(AO& ao)
{
  static int counter = 0;
  if(static_arg_ret_assigns){
    ECR& ecr = ECR::getECR(ao);
    ECRargRet * ear = ecr.argRet();
    if(ear && !insertArgRetAssignEdges_doneset.Contains(ear)){
      insertArgRetAssignEdges_doneset.Insert(ear);

      ECR& e = ear->getMainParent();

      //- traverse include edges, collect frontier ECRs
      collectInclToArgRets_ECRs.Clear();
      e.traverseAliases(0, collectInclToArgRets);

      //- for each frontier ECR, add assignment edges
      suco_iterator<ECRargRet *> ei(collectInclToArgRets_ECRs); // follow inclusion edges
      while(ei.Iterate()){
	ECRargRet * rar = ei.Current();
	if(ear != rar){ //- skip self-assigns?
	  //-------------------------
	  //- DO ARGS
	  int minArgSize = (ear->getArgSize() < rar->getArgSize()) ? ear->getArgSize() : rar->getArgSize();
	  int i;
	  for(i = 1; i <= minArgSize; ++i)
	    addAssignEdges(ear->get_arg(i), rar->get_arg(i), AO::aoArg);

	  //-------------------------
	  //- DO RET
	  addAssignEdges(rar->get_ret(), ear->get_ret(), AO::aoReturn);
	}
      }
      if(flag_verbose > 1){
        if(++counter % 100 == 0)
          fprintf(stderr, ".");
        if(counter % 5000 == 0)
          fprintf(stderr, "\n");
      }
    }
  }
}

void TCAstate::possTypeAnalysis()
{
  //----------------------------------------
  //-- compute possible-types

  //-- mark (initial) invalid nodes
  traverseAOs(TCAstate::markInvalidNode);

  if(flag_heapstack){
    //-- mark freed-heap locations as invalid
    // - mark *free.arg1 as influential
    ID * free_id = this->pidtab.lookupByName(".free");
    if(free_id){
      AO * fao = free_id->get_AOId().find(AO::aoFunction);
      if(fao && fao->get_AOArg(1)){
        //-- free is a special case: markInvalid must follow inclEdge *forward*
        suco_iterator<ECR *> ei(fao->get_AOArg(1)->getECR().getPointsTo().getAliasECRs());
        while(ei.Iterate()){
          ei.Current()->markInvalid(false); // mark invalid, propagate up incl edges, but don't propagate down derefs
          ei.Current()->propagateExposed(); // propagate exposed forward
        }
      } else fprintf(stderr, "WARNING (-heap): Free Function-AO or AOArg Not Found\n");
    } else fprintf(stderr, "WARNING (-heap): Free ID Not Found\n");

    if(flag_heapstack == 2){
      //-- mark all auto locations as invalid
      this->pidtab.traverseIDs(TCAstate::markAutoInvalidId);
      this->aidtab.traverseIDs(TCAstate::markAutoInvalidId);	//- for alloca $malloc objects!
    }
  }

  //- seed runtime-types
  if(flag_verbose) TCstats::timer("initializing possible-type");
  traverseAOs(initPossTypeConstraintsAO);
  if(flag_verbose) TCstats::timer(0);

  if(flag_verbose) TCstats::timer("building possible-types constraints");
  suco_iterator<TCassignEdge *> ai(assigns);
  while(ai.Iterate())
    initPossTypeConstraintsAssign(*ai.Current());
  suco_iterator<TCassignEdge *> arai(arg_ret_assigns);
  while(arai.Iterate())
    initPossTypeConstraintsAssign(*arai.Current());
  if(flag_verbose) TCstats::timer(0);

  if(flag_verbose > 3) possTypeConstraintRoots.debug_dump(stderr);

  //- Solve possible-type constraints
  if(flag_verbose) TCstats::timer("solving possible-type constraints");
  possTypeConstraintRoots.solveMeet();
  if(flag_verbose) TCstats::timer(0);
}

void TCAstate::assignTSC(AO& ao)
{
  ECR& ecr = ao.getECR();
  AO::ts_categ oldtsc = ao.getTSC();
  //-- possibly-invalid...
  if(oldtsc == AO::TSC_POSS_INVALID)
    return; // skip if already there
  // - rule L1a
  if(ao.isRef() && ecr.isInvalid()){
    ao.setTSC(AO::TSC_POSS_INVALID);
    //-- propagate L3:influential, which propagates L4:exposed
    ecr.propagateInfluential();
    return;
  }
  // - rule L1b
//TODO

  //-- badly-typed...
  if(oldtsc == AO::TSC_BADLY_TYPED)
    return; // skip if already there
  // - rules L2a, L2b
  TClatType::latKind possType = ecr.possType().getKind();
  if(!TClatType::GE(possType, ao.getRequiredType()) ||
	possType == TClatType::tclBottom){
    ao.setTSC(AO::TSC_BADLY_TYPED);
    //-- propagate L3:influential, which propagates L4:exposed
    ecr.propagateInfluential();
    return;
  }
}

void TCAstate::assignAllUnsafeRW(AO& ao)
{
  ECR& ecr = ao.getECR();
  AO::ts_categ oldtsc = ao.getTSC();
  //-- possibly-invalid...
  if(oldtsc == AO::TSC_POSS_INVALID)
    return; // skip if already there
  if(ao.isRef()){
    ao.setTSC(AO::TSC_POSS_INVALID);
    //-- propagate L3:influential, which propagates L4:exposed
    ecr.propagateInfluential();
    return;
  }
}

void TCAstate::assignAllUnsafeW(AO& ao)
{
  ECR& ecr = ao.getECR();
  AO::ts_categ oldtsc = ao.getTSC();
  //-- possibly-invalid...
  if(oldtsc == AO::TSC_POSS_INVALID)
    return; // skip if already there
  if(ao.isRef() && ao.isAssigned()){
    ao.setTSC(AO::TSC_POSS_INVALID);
    //-- propagate L3:influential, which propagates L4:exposed
    ecr.propagateInfluential();
    return;
  }
}

void TCAstate::assignTSCderefWrite(AO& ao)
{
  ECR& ecr = ao.getECR();
  AO::ts_categ oldtsc = ao.getTSC();
  //-- possibly-invalid...
  if(oldtsc == AO::TSC_POSS_INVALID)
    return; // skip if already there
  // - rule L1a
  if(ao.isRef() && ecr.isInvalid() && ao.isAssigned()){
    ao.setTSC(AO::TSC_POSS_INVALID);
    //-- propagate L3:influential, which propagates L4:exposed
    ecr.propagateInfluential();
    return;
  }
  // - rule L1b
//TODO

}

void TCAstate::assignTSCderef(AO& ao)
{
  ECR& ecr = ao.getECR();
  AO::ts_categ oldtsc = ao.getTSC();
  //-- possibly-invalid...
  if(oldtsc == AO::TSC_POSS_INVALID)
    return; // skip if already there
  // - rule L1a
  if(ao.isRef() && ecr.isInvalid()){
    ao.setTSC(AO::TSC_POSS_INVALID);
    //-- propagate L3:influential, which propagates L4:exposed
    ecr.propagateInfluential();
    return;
  }
  // - rule L1b
//TODO

}

void TCAstate::tscAnalysis()
{
  //----------------------------------------
  //-- compute type-safety levels
  if(flag_verbose) TCstats::timer("assigning type-safety categories");
  traverseAOs(assignTSC);
  if(flag_verbose) TCstats::timer(0);
}

void TCAstate::markInvalidLocAO(AO& ao)
{
  if(ao.isLoc()) // mark invalid, propagate up incl edges, but don't propagate down derefs
    ao.getECR().markInvalid(false);
}

void TCAstate::markAutoInvalidId(ID& id)
{
  if(id.getSC() == ID::AUTO)
    id.get_AOId().traverseAOs(TCAstate::markInvalidLocAO);
}

void TCAstate::invalidPtrAnalysis()
{
  //----------------------------------------
  //-- mark non-null invalid nodes
  traverseAOs(markInvalidNodeNonNull);

  if(flag_heapstack){
    //-- mark freed-heap locations as invalid
    // - mark *free.arg1 as influential
    ID * free_id = this->pidtab.lookupByName(".free");
    if(free_id){
      AO * fao = free_id->get_AOId().find(AO::aoFunction);
      if(fao && fao->get_AOArg(1)){
        //-- free is a special case: markInvalid must follow inclEdge *forward*
        suco_iterator<ECR *> ei(fao->get_AOArg(1)->getECR().getPointsTo().getAliasECRs());
        while(ei.Iterate()){
          ei.Current()->markInvalid(false); // mark invalid, propagate up incl edges, but don't propagate down derefs
          ei.Current()->propagateExposed(); // propagate exposed forward
        }
      } else fprintf(stderr, "WARNING (-ptr-heap): Free Function-AO or AOArg Not Found\n");
    } else fprintf(stderr, "WARNING (-ptr-heap): Free ID Not Found\n");

    if(flag_heapstack == 2){
      //-- mark all auto locations as invalid
      this->pidtab.traverseIDs(TCAstate::markAutoInvalidId);
      this->aidtab.traverseIDs(TCAstate::markAutoInvalidId);	//- for alloca $malloc objects!
    }
  }

  //----------------------------------------
  //-- assign type-safety levels, rules L1a and L1b only
  if(flag_verbose) TCstats::timer("assigning type-safety categories");
  traverseAOs(flag_readwrite?assignTSCderef:assignTSCderefWrite);
  if(flag_verbose) TCstats::timer(0);
}

void TCAstate::allDerefUnsafeAnalysis()
{
  traverseAOs(flag_readwrite?assignAllUnsafeRW:assignAllUnsafeW);
}

void TCAstate::tcFlowSensitiveAnalyses()
{
  if(flag_reaching_defs | flag_may_be_uninit | flag_redundant){ //- faster not to short-circuit
    cfg.prepareCFG(false);

    if(flag_reaching_defs){
      TCstats::timer("reaching-defs analysis");
      RDA rda;
      rda.doAnalysis(cfg);
      TCstats::timer(0);
    }
    if(flag_may_be_uninit){
      TCstats::timer("may-be-uninit analysis");
      if(flag_verbose) fprintf(stderr, "(mbu level %d)\n", flag_may_be_uninit);
      MBU mbu(flag_mbu_inter);
      mbu.doAnalysis(cfg);
      TCstats::timer(0);

      if(flag_reaching_defs){ // collect mbu-rda results

        RDMBfactHandler rmh(this->mbu_results);
        MBUc rdmb(rmh, flag_mbu_inter);

        TCstats::timer("collecting reaching-def/may-be-uninit results");
        rdmb.collectResults(cfg);
        TCstats::timer(0);

        //- for each result index object, propagateExposed on its ecr
        this->mbu_results.markAOsExposed();

      } else { // collect mbu-delta results

        TCstats::timer("collecting may-be-uninit/delta results");

        MBUc1factHandler c1h(this->mbu_results);
        MBUc mbuc1(c1h, flag_mbu_inter);
        if(flag_verbose) fprintf(stderr, "(phase 1)");
        mbuc1.collectResults(cfg);

        MBUc2factHandler c2h(this->mbu_results);
        MBUc mbuc2(c2h, flag_mbu_inter);
        if(flag_verbose) fprintf(stderr, "(phase 2)");
        mbuc2.collectResults(cfg);

        TCstats::timer(0);

        //- for each result index object, propagateExposed on its ecr
        this->mbu_results.markAOsExposed();
      }
    }
    if(flag_redundant){
      TCstats::timer("redundant-check (tp) analysis");
      RED red(REDtpFactHandler::handler, flag_red_paral2r);
      red.doAnalysis(cfg);
      TCstats::timer(0);

      if(flag_verbose) TCstats::timer("collecting redundant-check (tp) results");
      REDtpcFactHandler rtpcfh(this->red_results);
      REDc redc(rtpcfh);
      redc.collectResults(cfg);
      if(flag_verbose) TCstats::timer(0);
    }
  }
}

//- Mark starting points for relevant-aos filtering, controlled by flag
//  msp_relaos_mode : MBU or RAN mode
//     - if MBU mode, mark only safe derefs
//     - if RAN mode, mark unsafe derefs and tracked malloc sizes
//  Collect these in TCAstate::msp_starting_ecrs.
//- In RAN mode, also collect in TCAstate::msp_misc_dependencies
//  the following:
//  1. for assignments, dependencies not captured by flow-insensitive
//     assignment edges (e.g. if A is an array, x = A[i] is captured
//     only by x <--assign-- "op A", so we need to add the dependency
//     x <--dep-- i).
//  2. for predicates, dependency sets containing all aos in the
//     predicate (e.g., "x < y" generates the set {x,y} showing that
//     x and y depend on each other).
bool TCAstate::markStartingPoints(PgmExpr& pe)
{
  //- 1. verify ptr/ptrw
  if(pe.getKind() == PgmExpr::fVerify){
    PExprVerify& pev = (PExprVerify&) pe;
    if((pev.getVpKind() == PExprVerify::vpPtrW) ||
	(flag_readwrite && (pev.getVpKind() == PExprVerify::vpPtr))){
      bool is_safexp_deref = false;
      bool is_unsafe_deref = false;
      {
        suco_iterator<AO *> aoi(pev.getDesc().getAOs());
        while(aoi.Iterate()){
          if(aoi.Current()->getTSC() >= AO::TSC_EXPOSED)
            is_safexp_deref = true;
          else
            is_unsafe_deref = true;
        }
      }
      if(((TCAstate::msp_relaos_mode == relaos_MBU) && is_safexp_deref)||  //-MBU MODE: mark affaos of safe derefs
	(((TCAstate::msp_relaos_mode == relaos_RAN) && is_unsafe_deref))){ //-RAN MODE: mark affaos of unsafe deref
        suco_set<ECR *> affecrs;
        pev.getDesc().collectAffectingAliasLocECRs(affecrs);
        suco_iterator<ECR *> aei(affecrs);
        while(aei.Iterate()){
          TCAstate::markRelevantAndCollectInclFromECRs(aei.Current()->getAOset(), TCAstate::msp_starting_ecrs);
        }
      }
    }
  }
  //- 2. RAN mode: collect mallocsize AOs and dependencies
  if(TCAstate::msp_relaos_mode == relaos_RAN){
    //- 2a. malloc decl (future extension: any decl, if size argument may be a variable)
    //      - collect mallocsize affECRs
    if(pe.getKind() == PgmExpr::fDecl){
      PExprDecl& ped = (PExprDecl&) pe;
//TODO: filter out untracked aos? should only arise w/o heapstack, so let's not bother!?!
      if(ped.isMalloc() && ped.getMallocSize()){
        suco_set<ECR *> affecrs;
        ped.getMallocSize()->collectAffectingAliasLocECRs(affecrs); //-TODO: need only deref one level?
        suco_iterator<ECR *> aei(affecrs);
        while(aei.Iterate()){
          TCAstate::markRelevantAndCollectInclFromECRs(aei.Current()->getAOset(), TCAstate::msp_starting_ecrs);
        }
      }
    }
    //- 3. Collect dependencies (RAN mode only)
    if(pe.getKind() == PgmExpr::fAssign){
      PExprAssign& pea = (PExprAssign&) pe;
      suco_set<AO *> dep_aos;
      pea.getRHS().collectDependencies(dep_aos, true);
      if(!dep_aos.IsEmpty()){
        TCAstate::msp_misc_dependencies.addDirectedDependency(pea.getLHS().getAOs(), dep_aos); //- dep_aos is consumed
      }
    }
    if(pe.getKind() == PgmExpr::fPredicate){
      PExprPredicate& pep = (PExprPredicate&) pe;
      suco_set<AO *> dep_aos;
      pep.getDesc().collectDependencies(dep_aos, false);
      if(dep_aos.Length() > 1){ //- skip empty and singleton
        TCAstate::msp_misc_dependencies.addDependencySet(dep_aos); //- dep_aos is consumed
      }
    }
  }
  return true; //- continue traversal
}

void TCAstate::resetRelevantTag(AO& ao)
{
  ao.dfa_relevant = true;
}

void TCAstate::clearRelevantTag(AO& ao)
{
  ao.dfa_relevant = false;
}

void TCAstate::countRelevantAOs(AO& ao)
{
  TCAstate::crao_total_aos++;
  if(ao.dfa_relevant){
    if(flag_verbose){
      fprintf(stderr, "Relevant AO: ");
      ao.dump_descr(stderr);
      fprintf(stderr, "\n");
    }
    TCAstate::crao_marked_aos++;
  }
}
 
void TCAstate::markRelevantAndCollectInclFromECRs(suco_set<AO *>& aoset, suco_set<ECR *>& ecrset)
{
  suco_iterator<AO *> aoi(aoset);
  while(aoi.Iterate()){
    AO& ao = *aoi.Current();
    if(!ao.dfa_relevant && ao.isLocArgRet()){
      ao.dfa_relevant = true;
      ao.getECR().collectInclFromECRs(ecrset);
    }
  }
}

//- Marks relevant loc-AOs for two different (ptr/ptrw) analyses:
//  a. relmode=relaos_MBU : start with afflocs of safe and exposed
//	derefs, and propagate from there.
//  b. relmode=relaos_RAN : start with afflocs of unsafe derefs,
//	and propagate from there.
//  The 'readwrite' flag controls whether to start from vPtr+vPtrW
//  or vPtrW-only nodes.
//- The markings are carried by the AO::dfa_relevant tag.
void TCAstate::markRelevantLocs(bool readwrite, relaos_mode relmode)
{
  TCstats::timer("collect relevant locset");
  //  I. Clear dfa_relevant tags, and msp_starting_ecrs
  this->traverseAOs(TCAstate::clearRelevantTag);
  TCAstate::msp_starting_ecrs.Clear();

  //  II. Mark starting points (see markStartingPoints()).
  TCAstate::msp_relaos_mode = relmode;
  cfg.traverseRootNodes(TCAstate::markStartingPoints);

  // IIa: verbose output
  if(flag_verbose){
    TCAstate::crao_total_aos = 0;
    TCAstate::crao_marked_aos = 0;
    fprintf(stderr, "STARTING POINTS (%s):\n",
			(TCAstate::msp_relaos_mode == relaos_MBU)?"MBU":"RAN");
    this->traverseAOs(TCAstate::countRelevantAOs);
    fprintf(stderr, "--Starting Point AOs: %d, Total AOs: %d\n",
  			TCAstate::crao_marked_aos,
  			TCAstate::crao_total_aos);
    TCAstate::msp_misc_dependencies.debug_dump(stderr);
  }
  fprintf(stderr, "--Starting points: %d ecrs; Dependencies: %d directed, %d sets\n",
			TCAstate::msp_starting_ecrs.Length(),
			TCAstate::msp_misc_dependencies.getDirectedDependencies().Length(),
			TCAstate::msp_misc_dependencies.getDependencySets().Length());

  // III. Follow assignment edges and dependencies backwards:
  //      MBU: assignment edges only; RAN: assignments+dependencies.
  //      (Note: don't filter by relmode, since locs of any classification
  //       may affect the points of interest)
  suco_set<ECR *> pending_ecrs;
  pending_ecrs.Attach(TCAstate::msp_starting_ecrs);
  do {
    suco_set<ECR *> active_ecrs;
    active_ecrs.Attach(pending_ecrs);

/**/fprintf(stderr, "DEBUG relevant: active_ecrs = %d...\n", active_ecrs.Length());

    //- check dependencies (RAN only)
    if(TCAstate::msp_relaos_mode == relaos_RAN){
      suco_set<ECR *> new_ecrs;
      suco_iterator<Dependency *> ddi(TCAstate::msp_misc_dependencies.getDirectedDependencies());
      while(ddi.Iterate()){
        if(active_ecrs.Contains(&ddi.Current()->getKey().getECR())){
          TCAstate::markRelevantAndCollectInclFromECRs(ddi.Current()->getAOs(), pending_ecrs);
          ddi.DeleteCurrent(); //- WARNING: leaking a Dependency
        }
      }
      suco_iterator<suco_set<AO *> *> dsi(TCAstate::msp_misc_dependencies.getDependencySets());
      while(dsi.Iterate()){
        //- check to see if active_ecrs intersects dsi.Current()
        suco_iterator<AO *> daoi(*dsi.Current());
        while(daoi.Iterate()){
          if(active_ecrs.Contains(&daoi.Current()->getECR())){
            //- they intersect
            TCAstate::markRelevantAndCollectInclFromECRs(*dsi.Current(), pending_ecrs);
            dsi.DeleteCurrent(); //- WARNING: leaking an ao-list
            break;
          }
        }
      }
    }

    //- collect incoming edges
    suco_set<TCassignEdge *> edges;
    suco_iterator<ECR *> ecri(active_ecrs);
    while(ecri.Iterate()){
      suco_iterator<AO *> aoi(ecri.Current()->getAOset());
      while(aoi.Iterate()){
        edges.Union(aoi.Current()->getIncomingAssignEdges());
      }
    }

    //- follow edges backwards
    suco_iterator<TCassignEdge *> aei(edges);
    while(aei.Iterate()){
      //- collect affecting ecrs: "from" aliases + de-starred ao aliases
      suco_set<ECR *> from_ecrs;
      aei.Current()->getFrom().getECR().collectAliasECRs(from_ecrs, true);

      //- collect unprocessed back-prop'ed ecrs: for each irrelevant
      //  loc-ao* in from_ecrs, follow incl-edges backwards
      //  (*loc-ao, or all aos?)
      suco_iterator<ECR *> fecri(from_ecrs);
      while(fecri.Iterate()){
        TCAstate::markRelevantAndCollectInclFromECRs(fecri.Current()->getAOset(), pending_ecrs);
      }
    }
  } while(!pending_ecrs.IsEmpty());

  //  V. Diagnostic: count relevant aos
  TCAstate::crao_total_aos = 0;
  TCAstate::crao_marked_aos = 0;
  this->traverseAOs(TCAstate::countRelevantAOs);
  fprintf(stderr, "%s Relevant AOs: %d, Total AOs: %d\n",
			(TCAstate::msp_relaos_mode == relaos_MBU)?"MBU":"RAN",
  			TCAstate::crao_marked_aos,
  			TCAstate::crao_total_aos);

  TCstats::timer(0);
}

void TCAstate::ptrFlowSensitiveAnalyses()
{
  if(flag_may_be_uninit | flag_redundant | flag_range){
    cfg.prepareCFG(flag_range);

    if(flag_may_be_uninit){
      //- collect relevant aos: safe pointers that would otherwise be checked
//OBSOLESCE!
//      if(flag_filter_relevant_aos){
//        this->markRelevantLocs(flag_readwrite, relaos_MBU);
//      }

      pMBUfactHandler::readwrite = flag_readwrite;

      if(flag_pmbu_sensitive){ //- flow-sensitive

/**/fprintf(stderr, "WARNING: pmbu/flow-sensitive not yet supported.\n");

//--OBSOLETE/TODO: flow-sensitive pMBU analysis
// - currently in non-correct condition: must rewrite
      //- (ptr/ptrw)-mode mbu analysis
//      TCstats::timer("may-be-uninit analysis");
//      pMBUfactHandler pmbuh();
//      MBU pmbu(false, pmbuh);
//      pmbu.doAnalysis(cfg, true);	//-true=skip_libfns
//      if(flag_verbose) TCstats::timer(0);

      } else { //- flow-insensitive

        TCstats::timer("may-be-uninit analysis (flow-insensitive)");
        pMBUfactHandler::doInsensitiveAnalysis(this->cfg);
        TCstats::timer(0);

      }

      this->traverseAOs(pMBUfactHandler::collectUnsafeTracked);

      fprintf(stderr, "pMBU: %d locs, %d unsafe, %d tracked\n",
			pMBUfactHandler::results.Length(),
			pMBUfactHandler::unsafe.Length(),
			pMBUfactHandler::tracked.Length());

      //- done: reset relevant tags
//      if(flag_filter_relevant_aos){
//        this->traverseAOs(TCAstate::resetRelevantTag);
//      }
    }

    if(flag_redundant){
      //- REDUNDANT CHECK ANALYSIS
      if(flag_readwrite){ //- ptr

        TCstats::timer("redundant-check (p) analysis");
        RED red(REDpFactHandler::handler, flag_red_paral2r);
        red.doAnalysis(cfg);
        TCstats::timer(0);

        if(flag_verbose) TCstats::timer("collecting redundant-check (p) results");
        REDpcFactHandler rcfh(this->red_results);
        REDc redc(rcfh);
        redc.collectResults(cfg);
        if(flag_verbose) TCstats::timer(0);

      } else { //- ptrw

        TCstats::timer("redundant-check (pw) analysis");
        RED red(REDpwFactHandler::handler, flag_red_paral2r);
        red.doAnalysis(cfg);
        TCstats::timer(0);

        if(flag_verbose) TCstats::timer("collecting redundant-check (pw) results");
        REDpwcFactHandler rcfh(this->red_results);
        REDc redc(rcfh);
        redc.collectResults(cfg);
        if(flag_verbose) TCstats::timer(0);
      }
    }

    if(flag_range){
      //- RANGE ANALYSIS
      if(flag_filter_relevant_aos){
        this->markRelevantLocs(flag_readwrite, relaos_RAN);
      }
      {
        TCstats::timer("range analysis - widening");
        if(flag_verbose) fprintf(stderr, "(widening %s)\n", flag_range_widen_always?"always":"on backedge");
        RAN ranw(RANfactHandler::handler, flag_range_inter, RAN::WN_WIDEN, flag_range_widen_always);
        ranw.doAnalysis(cfg);
        TCstats::timer(0);
      }
      if(flag_range_do_narrow){
        TCstats::timer("range analysis - phase 2: narrowing");
        if(flag_verbose) fprintf(stderr, "(narrowing %s)\n", flag_range_narrow_always?"always":"on backedge");
        RAN rann(RANfactHandler::handler, flag_range_inter, RAN::WN_NARROW, flag_range_narrow_always);
        rann.doAnalysis(cfg);
        TCstats::timer(0);
      }
      {
        TCstats::timer("collecting range-analysis results");
        RANcFactHandler rcfh(this->ran_results, flag_readwrite);
        RANc ranc(rcfh, flag_range_inter);
        flag_debug_range_collect_phase = true; //- debug flag, to output known-pred info
        ranc.collectResults(cfg);
        TCstats::timer(0);
        if(flag_range_collect_stats){
          this->ran_num_all_vps = rcfh.countAllVPs(false);
          this->ran_num_finite_vps = rcfh.countFiniteVPs(false);
          this->ran_num_half_finite_vps = rcfh.countHalfFiniteVPs(false);

          this->ran_num_array_all_vps = rcfh.countAllVPs(true);
          this->ran_num_array_finite_vps = rcfh.countFiniteVPs(true);
          this->ran_num_array_half_finite_vps = rcfh.countHalfFiniteVPs(true);
          this->ran_num_array_inbounds_vps = rcfh.countInboundsVPs(true);

          this->ran_num_known_preds = rcfh.countKnownPreds();
        }
        //- inb-vps: do always
        this->ran_num_inbounds_vps = rcfh.countInboundsVPs(false);
        this->ran_num_inbounds_sdotarrows = rcfh.countInboundsSdotArrows();
      }
      if(flag_filter_relevant_aos){
        this->traverseAOs(TCAstate::resetRelevantTag);
      }
    }
  }
}

void TCAstate::setAddrofDerefUDotUnsafe(AO& ao)
{
  //-----------------------------------------------
  //-- find all addr-of objects, mark target unsafe
  if(ao.getKind() == AO::aoAddrOf){
    AOAddrOf& ado = (AOAddrOf&) ao;
    ado.getTarget().setTS_UNSAFE(); //- propagates along assign edges
  }

  //---------------------------------------------
  //-- find all dereference nodes, mark as unsafe
  if(ao.getKind() == AO::aoStar){
    ao.setTS_UNSAFE(); //- propagates along assign edges
  }

  //----------------------------------------
  //-- find all union-dot nodes, mark as unsafe
  if(ao.getKind() == AO::aoUDot){
    ao.setTS_UNSAFE(); //- propagates along assign edges
    //- set parent unsafe also
    ((AOUDot &)ao).getParent().setTS_UNSAFE();
  }
}

void TCAstate::markDerefUnsafeAddrofTracked(AO& ao)
{
  if(ao.isRef())
    ao.setTSC(AO::TSC_POSS_INVALID);

  if(ao.getKind() == AO::aoMalloc)
    ao.setTSC(AO::TSC_EXPOSED);

  if(ao.getKind() == AO::aoAddrOf)
    ((AOAddrOf&)ao).getTarget().setTSC(AO::TSC_EXPOSED);
}

void TCAstate::addrAssignAnalysis(bool ptrptrw)
{
  traverseAOs(ptrptrw?markDerefUnsafeAddrofTracked:setAddrofDerefUDotUnsafe);
}

bool TCAstate::isVulnFunction(const char * cp)
{
  const char * fnlist[] = {
		".execl",
		".execlp",
		".execle",
		".execv",
		".execvp",
		".execve",
		".system",
		".popen",
		".longjmp",
		"._longjmp",
		".siglongjmp",
	};
  for(int i = 0; i < (sizeof(fnlist)/sizeof(fnlist[0])); ++i){
    if(!strcmp(cp, fnlist[i]))
      return true;
  }
  return false;
}

// Search for and mark vulnerable locations:
//  1. Function pointers are vulnerable
//  2. Vulnerable function arguments are vulnerable
//     (vulnerable functions: exec, system, popen, longjmp,...
//      - see isVulnFunction() above for full list)
//     *NOTE*: currently coded to assume the vulnerable
//     locations are:
//      a. the first argument of the vulnerable function
//      b. what the first argument points to
//     e.g., system(p) ==> p and what p points to are vulnerable.
//     This fits the currently-recognized vulnerable functions,
//     but would need to be changed for future extensions.
bool TCAstate::collectVulnerable(PgmExpr& expr)
{
  if(expr.getKind() == PgmExpr::fCall){
    PExprCall& call_expr = (PExprCall&)expr;

    //- A. mark vulnerable function pointers
    if(!call_expr.isDirectCall()){
      suco_iterator<AO *> faoi(call_expr.getFaos());
      while(faoi.Iterate()){
        AO& fao = *faoi.Current();
        if(fao.isLoc()){
          fao.markVulnerableLocAndPropagate("Function Pointer");
        } else {
          suco_iterator<ECR *> ecri(fao.getECR().getAliasECRs());
          while(ecri.Iterate()){
            suco_iterator<AO *> aoi(ecri.Current()->getAOset());
            while(aoi.Iterate()){
              if(aoi.Current()->isLoc()){
                aoi.Current()->markVulnerableLocAndPropagate("Function Pointer");
              }
            }
          }
        }
      }
    }

    //- B. look for vulnerable functions
    const char * vuln_fn_name = 0;
    { //-1. search TargetFns -- currently vuln fns should be undefined, so this block should yield nothing
      suco_iterator<CFGfunction *> tfi(call_expr.getTargetFns());
      while(tfi.Iterate()){
        const char * idname = tfi.Current()->getId().getPid().getname();
        if(TCAstate::isVulnFunction(idname)){
          vuln_fn_name = idname;
          break;
        }
      }
    }
    if(!vuln_fn_name){
      //-2. search undefTargetFns
      suco_iterator<AOId *> utfi(call_expr.getUndefTargetFns());
      while(utfi.Iterate()){
        const char * idname = utfi.Current()->getPid().getname();
        if(TCAstate::isVulnFunction(idname)){
          vuln_fn_name = idname;
          break;
        }
      }
    }
    //- if this is a vulnerable call, do stuff
    if(vuln_fn_name){
      PExprArg * arg1_expr = call_expr.getArg(1);
      if(arg1_expr){
        suco_iterator<AO *> arg1_aoi(arg1_expr->getDesc().getAOs());
        while(arg1_aoi.Iterate()){
          AO& arg1_ao = *arg1_aoi.Current();

          //- mark as vulnerable location:
          //  - if arg1_ao is a location, then arg1_ao
          //  - else, loc-aliases(arg1_ao)
          if(arg1_ao.isLoc()){
            arg1_ao.markVulnerableLocAndPropagate(vuln_fn_name);
          } else {
            suco_iterator<ECR *> ecri(arg1_ao.getECR().getAliasECRs());
            while(ecri.Iterate()){
              suco_iterator<AO *> aoi(ecri.Current()->getAOset());
              while(aoi.Iterate()){
                if(aoi.Current()->isLoc()){
                  aoi.Current()->markVulnerableLocAndPropagate(vuln_fn_name);
                }
              }
            }
          }
          //- also, mark as vulnerable locations pt-set(arg1_ao)
          {
            suco_iterator<ECR *> ecri(arg1_ao.getECR().getPointsTo().getAliasECRs());
            while(ecri.Iterate()){
              suco_iterator<AO *> aoi(ecri.Current()->getAOset());
              while(aoi.Iterate()){
                if(aoi.Current()->isLoc()){
                  aoi.Current()->markVulnerableLocAndPropagate(vuln_fn_name);
                }
              }
            }
          }
        }
      } else fprintf(stderr, "WARNING(collectVulnerable): call to %s missing argument 1\n", vuln_fn_name);
    }
  }
  return true; //- true ensures full traversal
}

void TCAstate::computeVulnerable()
{
  cfg.prepareCFG(false);
  cfg.traverseRootNodes(TCAstate::collectVulnerable);
}

void TCAstate::writeVulnerable(FILE * outf)
{
  AO::aoWriteStream = outf;
  traverseAOs(AO::writeVulnerable);
  AO::aoWriteStream = 0;
}

//NOTE: the signatures capture the behavior of our wrappers,
//	which doesn't always match the actual behavior!
//	(in particular, our wrappers were writting with
//	-ptrw mode in mind, and doesn't always check reads?)
//TODO: for the retval-sensitive functions (those that return
//	a static buffer), I currently just comment them out.
//	Don't uncomment them unless handling them; else may
//	erroneously de-_typecheck_ some calls.
const char * TCAstate::interestingLibFnSignature(ID * fnid)
{
  //-These describe the behavior of _typecheck_ versions: see dynamic/tcptrlibc.c
  //  r=read
  //  w=write
  //  x=no
  //  v=vararg: vr/vw/vx
  //-0th spot = retval (currently unused)
  //-1st spot = arg 1, ...
  static struct {
    const char * fnname;
    const char * signature;
  } libfns[] = {
	{".fgets","_w"},
	{".gets","_w"},
	{".fread","_w"},
	{".scanf","_xvw"},
	{".fscanf","_xxvw"},
	{".sscanf","_xxvw"},
				//NOTE (sprintf,snprintf): current signatures ("_w","_w") are unsafe;
				//	should actually be ("_wvw","_wxxvw"), plus some coordination with
				//	pctn (not currently done for sprintf,sprintf -- TODO).
				//	HOWEVER, current version is "conservative" in that it doesn't
				//	allow any "%n" to write into a vulnerable location.
	{".sprintf","_w"},
	{".snprintf","_w"},
//	{".printf,"_"},		//- "xvw" ~~> handled by "pctn"?
//	{".fprintf,"_"},	//- "xxvw" ~~> handled by "pctn"?
	{".free","_w"},
//	{".realloc","_?x"},
	{".bzero","_w"},
	{".memcpy","_wr"},
	{".memmove","_wr"},
	{".strcpy","_wr"},
	{".strncpy","_wr"},
	{".strcat","_wr"},
	{".strncat","_wr"},
//	{".strxfrm","_wrx"},
	{".memset","_w"},
//	{".strerror","_"},
	{".memccpy","_wr"},
//	{".strsignal","_"},
//	{".strdup","_r"},
//	{".nl_langinfo","_x"},
//	{".stat","_rw"},
//	{".lstat","_rw"},
//	{".fstat","_xw"},
//	{".ctime","_r"},
//	{".localtime","_r"},
//	{".gmtime","_r"},
//	{".asctime","_r"},
//	{".getpass","_r"},
//	{".read","_xwx"},
//	{".pread","_xwxx"},
//	{".readv","_xwx"},
//	{".gethostbyname","_r"},
//	{".gethostbyaddr","_rxx"},
  };

  if(fnid){
    int i;
    for(i = 0; i < (sizeof(libfns)/sizeof(libfns[0])); ++i){
      if(!strcmp(fnid->getname(), libfns[i].fnname)){
        return libfns[i].signature;
      }
    }
  }
  return 0;
}

//-------------------------------------------
// For each "interesting" function (described by
// TCAstate::interestingLibFnSignature() above)
// determine whether we should call the instrumented
// or uninstrumented version of the function by checking
// whether the relevant argument points to a tracked/
// vulnerable location.
// NOTE/TODO: currently includes "free", which sort of
//  doubles the functionality of "/" computed elsewhere.
//  The difference is that "/" also computes the status
//  in "limit_malloc" mode, which isn't done here.
//  So for now, continue to use "/" instead of this.
//  (Even though, technically, "limit_malloc" mode is
//  unsafe.)
bool TCAstate::writeLibfnTrackStatus(PgmExpr& expr)
{
  if(expr.getKind() == PgmExpr::fCall){
    PExprCall& call_expr = (PExprCall&)expr;

    //- look for interesting library functions
    const char * libfn_signature = interestingLibFnSignature(call_expr.isDirectCall());
    if(libfn_signature){
      ExposedStatus es_ptr = ExposedStatus::NA;
      ExposedStatus es_vuln = ExposedStatus::NA;
      int i;
      bool varg_mode = false;
      PExprArg * arg_expr;
      for(i = 1; arg_expr = call_expr.getArg(i); ++i){
        if(!varg_mode && !libfn_signature[i]){
          break; //-done
        }
        if(!varg_mode && libfn_signature[i] == 'v'){
          if((libfn_signature[i+1] == 'w')
		|| (libfn_signature[i+1] == 'r' && flag_readwrite == false)){
            varg_mode = true;
          } else {
            break; //-done
          }
        }
        if(varg_mode
		|| (libfn_signature[i] == 'w')
		|| (libfn_signature[i] == 'r' && flag_readwrite == false)){
          suco_iterator<AO *> aoi(arg_expr->getDesc().getAOs());
          while(aoi.Iterate()){
            es_ptr.combine(aoi.Current()->pointsToExposed(false, flag_range, false));
            es_vuln.combine(aoi.Current()->pointsToExposed(false, flag_range, true));
          }
        }
        if(es_ptr.isSome() && es_vuln.isSome()) break; //- short circuit; no need to check further
      }
      AID& call_aid = call_expr.getAid();
      fprintf(AO::aoWriteStream, "! %d f p %c %d\n", call_aid.filestem_id, es_ptr.exposedCode(), call_aid.aid);
      fprintf(AO::aoWriteStream, "! %d f v %c %d\n", call_aid.filestem_id, es_vuln.exposedCode(), call_aid.aid);
    }
  }
  return true; //- true ensures full traversal
}

void TCAstate::outputLibfnTrackStatus(FILE * outf)
{
  cfg.prepareCFG(false);
  AO::aoWriteStream = outf; //- borrow this stream pointer :-D
  cfg.traverseRootNodes(TCAstate::writeLibfnTrackStatus);
  AO::aoWriteStream = 0;
}

void TCAstate::writeTSoutput(FILE * outf, bool tsl)
{
  //-- assign unique IDs to aidtab and pidtab entries
  unsigned int naids = aidtab.assignUIDs(1);
  unsigned int npids = pidtab.assignUIDs(naids);

  if(flag_verbose) fprintf(stderr, "#Aids = %d, #Pids = %d\n", naids-1, npids-naids);

  fprintf(stderr, (tsl)?"---Outputting ts_levels\n":"---Outputting ts_categs\n");

  fprintf(outf, "# %s\n", (tsl)?"(addr-taken TSLs)":((flag_all_deref_unsafe)?"(tracked-only TSCs)":"(flow-insens TSCs)"));

  //----------------------------------------
  //-- collect stats on number of different types of nodes
  TCstats::doAssigns(outf, assigns);
  traverseAOs(TCstats::doAO);

  //----------------------------------------
  //-- output stats
  TCstats::print(outf);

  //-- first: for address-taken analysis, default ts-level is SAFE
  fprintf(outf, "^ S\n");

  //-- next, output aliases
  aidtab.output_aliases(outf, '@@');
  pidtab.output_aliases(outf, '%');

  //- traverse abstract objects to assign ecrnos, and output inclTo lists
  if(!tsl){
    AO::aoWriteStream = outf;
    traverseAOs(AO::assignEcrNosAndWriteToFile);
    AO::aoWriteStream = 0;
  }

  //- traverse abstract objects to output safety level
  AO::aoWriteStream = outf;
  traverseAOs((tsl)?(AO::writeTSlevel):(AO::writeTScateg));
  AO::aoWriteStream = 0;

  //- A. traverse argument to free()
  //     check to see if points-to target is all tracked,
  //     all untracked, or a mix (incl untouched under -ran)
  //     NOTE: assumes direct calls only!  TODO: handle indirect calls
  //- B. traverse argument to vulnerable functions (longjmp, exec*, system, popen)
  //     output comment summarizing their trackedness/touchedness
  //     NOTE: again, assume direct calls only!  TODO: handle indirect calls
  if(!tsl){
    suco_iterator<TCassignEdge *> aei(assigns);
    while(aei.Iterate()){
      if(aei.Current()->getTo().getKind() == AO::aoArg){
	AOArg& aao = (AOArg &) aei.Current()->getTo();
        if(aao.argNo() == 1 && aao.getParent().getKind() == AO::aoStar){
          AOStar& sao = (AOStar &)aao.getParent();
          if(sao.getTarget().getKind() == AO::aoId){
            ID& fid = ((AOId &)sao.getTarget()).getPid();
            if(!strcmp(fid.getname(),".free")){
              //-- found an argument to free
              AO& fao = aei.Current()->getFrom();
	      if(!fao.isVal()){ //- skip value AOs
                if(flag_do_addr_taken) fprintf(outf, "/ A A ");
                else fprintf(outf, "/ %c %c ",  fao.pointsToExposed(false, flag_range, false).exposedCode(),
						fao.pointsToExposed(true, flag_range, false).exposedCode());
                fao.write_string_rep(outf, flag_readable_output);
                fprintf(outf, "\n");

                //- vuln mode output
                if(flag_vuln){ //-TODO: should only output in ptr/ptrw mode!!!
                  fprintf(outf, "/V%c %c ", fao.pointsToExposed(false, flag_range, true).exposedCode(),
					    fao.pointsToExposed(true, flag_range, true).exposedCode());
                  fao.write_string_rep(outf, flag_readable_output);
                  fprintf(outf, "\n");
                }
              }
            }
            if(TCAstate::isVulnFunction(fid.getname())){
              //-- found an argument to vuln function
              AO& fao = aei.Current()->getFrom();
	      if(!fao.isVal()){ //- skip value AOs
                fprintf(outf, "# vuln%s(", fid.getname());
                fao.write_string_rep(outf, true);
                fprintf(outf, "):\n");
                //-----------------------------------------------------
                // Hackery Alert:
                //  What we're trying to do here is figure out the
                //  tracked-ness status of first argument of vuln fns,
		//  in particular setjmp buffers.
                //  Here, fao is the first argument to longjmp.
                //  Question: is fao the buffer, or a pointer to the
                //  buffer?
                //  Answer: looks like it's implementation dependent:
                //  fao is of type "jmp_buf" which (on my Linux gcc)
                //  is an array of size one which gets translated to
                //  a pointer, but another implementation may choose
                //  not to pass-by-reference.
                //  Therefore: I'll look up the static type of the
                //  argument (aao), and if it is a pointer, then
                //  look at fao's points-to set; otherwise look at
                //  fao's alias set.
                //-----------------------------------------------------
                bool getpointsto = true; //- assume pass-by-reference by default
                if(aao.getStaticType()){
                  getpointsto = (aao.getStaticType()->getKind() == TCtype::tcPointer);
                } else fprintf(stderr, "ERROR(writeTSoutput): %s argument static type unknown\n", fid.getname());
                suco_iterator<ECR *> ei((getpointsto) ? fao.getECR().getPointsTo().getAliasECRs()
						      : fao.getECR().getAliasECRs()
					);
                while(ei.Iterate()){
                  suco_iterator<AO *> aoi(ei.Current()->getAOset());
                  while(aoi.Iterate()){
                    if(aoi.Current()->isLoc() &&
			aoi.Current()->getKind() != AO::aoStringLit && //- filter out string literals!?
			(&aoi.Current()->getEnclosingStruct()) == aoi.Current()){ //- only output outermost struct
										  //  TODO: this is a cheap test that
										  //  only works with collapseAlways ECR mapping!
                      fprintf(outf, "#  arg%s(%c/%c): ", fid.getname(),
				ei.Current()->exposed?'E':'S',	//- exploitation of friendship :-D
				ei.Current()->touched?'T':'U');
                      aoi.Current()->write_string_rep(outf, true);
                      fprintf(outf, "\n");
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }

  //- output DFA results
  AID::writeFileStemMap(outf);

  //- outputs per-aid tracked-status for interesting library functions
  //  (free, strcpy, etc.)
  //  NOTE: for free, duplicates (?) "/" output above
  TCAstate::outputLibfnTrackStatus(outf);

  if(flag_may_be_uninit){
    this->mbu_results.writeResults(outf);
    pMBUfactHandler::writeResults(this->cfg, outf);
  }

  //- output RED results
  if(flag_redundant){
    this->red_results.writeResults(outf);
  }

  //- output RAN results
  if(flag_range){
    if(flag_range_collect_stats){
      fprintf(outf, "# RAN-count vps-all = %d\n", this->ran_num_all_vps);
      fprintf(outf, "# RAN-count vps-finite = %d\n", this->ran_num_finite_vps);
      fprintf(outf, "# RAN-count vps-half-finite = %d\n", this->ran_num_half_finite_vps);
      fprintf(outf, "# RAN-count vps-array-all = %d\n", this->ran_num_array_all_vps);
      fprintf(outf, "# RAN-count vps-array-finite = %d\n", this->ran_num_array_finite_vps);
      fprintf(outf, "# RAN-count vps-array-half-finite = %d\n", this->ran_num_array_half_finite_vps);
      fprintf(outf, "# RAN-count vps-array-inbounds = %d\n", this->ran_num_array_inbounds_vps);
      fprintf(outf, "# RAN-count known-preds = %d\n", this->ran_num_known_preds);
    }
    //- inb-vps: do always
    fprintf(outf, "# RAN-count vps-inbounds = %d\n", this->ran_num_inbounds_vps);
    fprintf(outf, "# RAN-count vps-inb-sdotarrow = %d\n", this->ran_num_inbounds_sdotarrows);
    suco_iterator<PExprVerify *> bci(this->ran_results);
    while(bci.Iterate()){
      AID& aid = bci.Current()->getAid();
      fprintf(outf, "! %d b %d\n", aid.filestem_id, aid.aid);
    }
  }

  //- output if exposed AOs are untouched
  if(flag_range){ //- future extension: other analyses may touch also
    AO::aoWriteStream = outf;
    traverseAOs(AO::writeUntouchedExposed);
    AO::aoWriteStream = 0;
  }
}

void TCAstate::printDerefAliases(AO& ao)
{
  if(ao.isRef()){
    ao.write_string_rep(AO::aoWriteStream, true);
    fprintf(AO::aoWriteStream, ": ");
    suco_set<AO *> alias_aos;
    suco_iterator<ECR *> ei(ao.getECR().getAliasECRs());
    while(ei.Iterate())
      alias_aos.Union(ei.Current()->getAOset());
    AO::write_list_string_rep(AO::aoWriteStream, alias_aos, true);
    fprintf(AO::aoWriteStream, "\n");
  }
}

void TCAstate::writeAliases(FILE * outf)
{
  AO::aoWriteStream = outf;
  traverseAOs(TCAstate::printDerefAliases);
  AO::aoWriteStream = 0;
}

void TCAstate::writeCallgraph(FILE * outf, bool dot, char * trace_fn)
{
  cfg.writeCallgraph(outf, dot, trace_fn);
}

FILE * daf_outf = 0;
void dump_ao_fun(AO& ao) { ao.debug_dump(daf_outf); fprintf(daf_outf, "\n"); }

void TCAstate::summary_dump(FILE * outf)
{
  daf_outf = outf;
  fprintf(stderr, " --Dumping Value-AOs...\n");
  fprintf(outf, "--VALUE-AOs:\n");
  values.traverseAOs(dump_ao_fun);

  fprintf(stderr, " --Dumping Aid-AOs...\n");
  fprintf(outf, "--AID-AOs:\n");
  aidtab.traverseAOs(dump_ao_fun);

  fprintf(stderr, " --Dumping Pid-AOs...\n");
  fprintf(outf, "--PID-AOs:\n");
  pidtab.traverseAOs(dump_ao_fun);
  daf_outf = 0;

  fprintf(stderr, "---Done Dumping AOs\n");

  fprintf(stderr, " --Dumping Assignments...\n");
  fprintf(outf, "--ASSIGNS:\n");
  suco_iterator<TCassignEdge *> ai(assigns);
  while(ai.Iterate()){
    ai.Current()->getTo().write_string_rep(outf, true);
    fprintf(outf, "= ");
    ai.Current()->getFrom().write_string_rep(outf, true);
    fprintf(outf, "\n");
  }

  fprintf(stderr, " --Dumping Arg-Ret Assignments...\n");
  fprintf(outf, "--ARG-RET-ASSIGNS:\n");
  suco_iterator<TCassignEdge *> arai(arg_ret_assigns);
  while(arai.Iterate()){
    arai.Current()->getTo().write_string_rep(outf, true);
    fprintf(outf, "= ");
    arai.Current()->getFrom().write_string_rep(outf, true);
    fprintf(outf, "\n");
  }

}

void TCAstate::debug_dump(FILE * outf)
{
  fprintf(stderr, "---Dumping State:\n");

  fprintf(stderr, " --Dumping Aidtab...\n");
  fprintf(outf, "--AIDTAB:\n");
  aidtab.debug_dump(outf);

  fprintf(stderr, " --Dumping Pidtab...\n");
  fprintf(outf, "--PIDTAB:\n");
  pidtab.debug_dump(outf);

  daf_outf = outf;
  fprintf(stderr, " --Dumping Value-AOs...\n");
  fprintf(outf, "--VALUE-AOs:\n");
  values.traverseAOs(dump_ao_fun);

  fprintf(stderr, " --Dumping Aid-AOs...\n");
  fprintf(outf, "--AID-AOs:\n");
  aidtab.traverseAOs(dump_ao_fun);

  fprintf(stderr, " --Dumping Pid-AOs...\n");
  fprintf(outf, "--PID-AOs:\n");
  pidtab.traverseAOs(dump_ao_fun);
  daf_outf = 0;

  fprintf(stderr, " --Dumping Assignments...\n");
  fprintf(outf, "--ASSIGNS:\n");
  suco_iterator<TCassignEdge *> ai(assigns);
  while(ai.Iterate()) ai.Current()->debug_dump(outf);

  fprintf(stderr, " --Dumping Arg-Ret Assignments...\n");
  fprintf(outf, "--ARG-RET-ASSIGNS:\n");
  suco_iterator<TCassignEdge *> arai(arg_ret_assigns);
  while(arai.Iterate()) arai.Current()->debug_dump(outf);

  fprintf(stderr, " --Dumping ECRs/Points-to Graph...\n");
  fprintf(outf, "--ECR/PT Graph:\n");
  AO::aoWriteStream = outf;
  traverseAOs(AO::writeECR);
  AO::aoWriteStream = 0;

  fprintf(stderr, " --Dumping CFG...\n");
  fprintf(outf, "--CFG:\n");
  cfg.debug_dump(outf);
  fprintf(stderr, "---Done Dumping State\n");

  if(flag_may_be_uninit){
    fprintf(stderr, " --Dumping MBU results...\n");
    fprintf(outf, "--MBU results:");
    this->mbu_results.debug_dump(outf, false);
    fprintf(stderr, " --Done Dumping MBU results\n");

    fprintf(stderr, " --Dumping pMBU results...\n");
    fprintf(outf, "--pMBU aos:\n");
    suco_iterator<AO *> pmi(pMBUfactHandler::results);
    while(pmi.Iterate()){
      pmi.Current()->dump_descr(outf);
      fprintf(outf, "\n");
    }
    fprintf(stderr, " --Done Dumping pMBU results\n");
  }

  if(flag_redundant){
    fprintf(stderr, " --Dumping RED results...\n");
    this->red_results.debug_dump(outf);
    fprintf(stderr, " --Done Dumping RED results\n");
  }

  if(flag_range){
    fprintf(stderr, " --Dumping RAN results...\n");
    
    fprintf(outf, "--RAN results:");
    suco_iterator<PExprVerify *> bci(this->ran_results);
    while(bci.Iterate())
      bci.Current()->debug_dump(outf, 3, true);

    fprintf(stderr, " --Done Dumping RAN results\n");
  }
}

//------------------------------------------------------

int main(int argc, char * argv[])
{
  const char * outfile = 0;
  enum { tcm_pta, tcm_callgraph, tcm_ptr, tcm_ptrw, tcm_full } mode = tcm_full;
  bool debug_mode = false;
  bool summary_mode = false;
  bool no_output = false;
  bool callgraph_dot = false;
  char * calltrace = 0;
  int local_flag_range_collect_stats = -1;

  if(argc <= 1)
    return fprintf(stderr, "Usage: %s [options] files\n"
			   "   [options] are:\n"
			   "     -o outfile   output filename (default a.tc_tsls)\n"
			   "     -addr        address-taken analysis\n"
			   "     -pta         points-to analysis only (no TS-level output)\n"
			   "     -callgraph   dump callgraph info only\n"
			   "      -callgraph-dot  output in dot format\n"
			   "     -calltrace=<fn_name>\n"
			   "                  dump non-recursive call trace(s) for function fn_name\n"
			   "     -nt          full RTC(newtags) type-safety analysis (default action)\n"
			   "     -ptr         mark invalid non-null pointer only (for security tool)\n"
			   "     -ptrw        mark invalid deref-written non-null pointer only\n"
			   "       -strlit-writable in ptrw mode: are strlits writable? (default no)\n"
			   "       -unsafe-derefs   all derefs unsafe; only compute tracked (default no)\n"
			   "    [-no]-vuln    output vulnerable locations and dereferences (default yes)\n"
			   "     -heap        unsafe to point to freed-heap (default off)\n"
			   "     -heapstack   unsafe to point to freed-heap or stack (default off)\n"
			   "                  (NOTE: these were previously -ptr-heap/-ptr-heapstack)\n"
			   "\n"
			   "     -dfa         dataflow (flow-sensitive) analysis\n"
			   "                  turns on -mbu1\n"
			   "    [-no]-vtfix   treat verifyTag as fixing type on mismatch (default no)\n"
			   "     -mbu[1234]   may-be-uninit analysis level\n"
			   "                  1: full (default)\n"
			   "                  2: don't assign return values\n"
			   "                  3: don't assign args/return values\n"
			   "                  4: don't propagate via asssignments at all\n"
			   "     -mbu-intra/-mbu-inter\n"
			   "                  do may-be-uninit intra/inter-procedurally (default inter)\n"
			   "     -mbu-intra-iref\n"
			   "                  do may-be-uninit intra-procedurally, use iref (default no)\n"
			   "     -pmbu-sensitive/-pmbu-insensitive\n"
			   "                  vp may-be-uninit flow-insensitive (default) or sensitive\n"
			   "     -rda         do reaching-defs analysis\n"
			   "     -red         do redundant-check analysis\n"
			   "      -red-par, red-no-par\n"
			   "                  parallels do two rounds (default yes)\n"
			   "     -range       do range analysis (-ptr/-ptrw only)\n"
			   "      -ran-intra/-ran-inter\n"
			   "                  do range analysis intra/inter-procedurally (default intra)\n"
			   "     -ran-[DO|LO] interval use DO or LO representation (default DO)\n"
			   "       -ran-must-ao/-ran-must-ao-no\n"
			   "                  must have AO?  (LO=>yes, DO=>no)\n"
			   "       -ran-tychange-[yes|no]\n"
			   "                  allow descriptor type change?  (LO=>no, DO=>yes)\n"
			   "       -ran-sliding-[yes|no]\n"
			   "                  do sliding if possible?  (only if tychange; default=yes)\n"
			   "       -ran-dopreds-[yes|no]\n"
			   "                  try to improve predicate ranges?  (default=yes)\n"
                           "       -ran-skip-tgted-preds\n"
			   "                  don't improve targeted predicate ranges\n"
			   "       -ran-exactsizes[-no]\n"
			   "                  assume exact sizes of types?  (default=no)\n"
			   "      -ran-widen-[always|backedge]\n"
			   "                  widen always or only on backedge (default=backedge)\n"
			   "      -ran-no-narrow\n"
			   "      -ran-narrow[|-always|-backedge]\n"
			   "                  range analysis: do narrowing? (default=yes)\n"
			   "                  if so, always or only on backedge (default=always)\n"
			   "      -ran[-no]-filter-loop-backedge\n"
			   "                  compute backedge filter on loops? (default=yes)\n"
			   "      -ran[-no]-filter-call-backedge\n"
			   "                  compute backedge filter in callgraph? (default=no)\n"
			   "      -ran[-no]-malloc\n"
			   "                  handle malloc objects (default=yes)\n"
			   "      -ran[-no]-zero-special\n"
			   "                  treat zero specially (default=yes)\n"
			   "     -ran[-no]-collect-stats\n"
			   "                  collect finite/half-finite/known-pred stats (default=ptr)\n"
			   "     -ltsize      mbu: perform lower-than by size comparison (experimental)\n"
			   "     -callmeet    at non-empty callsites, always merge with pre-call facts\n"
			   "    [-no]-gref    compute GREF and filter at callsites (default=yes)\n"
			   "    [-no]-bblocks use basic blocks (default=off)\n"
			   "     -gmodref-skip-locals\n"
			   "     -gmodref-include-locals\n"
			   "                  GMOD/GREF should include/skip locals (default=skip)\n"
			   "     -wlmode[012] } worklist traversal order (default=leaf):\n"
			   "      -fifo       } 0: fifo\n"
			   "      -lifo       } 1: lifo\n"
			   "      -leaf       } 2: leaf-first in call-graph\n"
			   "     -wli-topo/-wli-depth\n"
			   "                  worklist initialize traversal order (default=topo)\n"
			   "    [-no]-relevant-aos\n"
			   "                  filter relevant aos during dfa (default=false)\n"
			   "    [-no]-inst-fields\n"
			   "                  instantiate struct/union field AOs at decl (default=true)\n"
			   "\n"
			   "     -debug       dump full debug output, turns on -readable\n"
			   "     -readable    output readable names instead of pid/aid\n"
			   "     -summary     dump AO summary output\n"
			   "     -no-output   don't output to file\n"
			   "\n"
			   "    [-no]-fixnargs  Precompute max number of function args (default=yes)\n"
			   "    [-no]-cde-incl  Cycle detection/elimination: incl-to (default=yes)\n"
			   "    [-no]-cde-pt    Cycle detection/elimination: points-to (default=yes)\n"
			   "\n"
			   "    [-no]-recycle Recycle list nodes (default=yes)\n"
			   "\n"
			   "     -v[12345]    verbose execution mode (-v == -v2)\n"
			   "                  1: info on stage only\n"
			   "                  2: progress dots\n"
			   "                  3: full stats\n"
			   "                  4: higher diagnostic debug stuff\n"
			   "                  5: DFA full trace\n"
			, argv[0]);

  suco_llist<const char *> infiles;

  for(int i = 1; i < argc; ++i){
    if(argv[i][0] == '-'){
      if(!strcmp(argv[i],"-o")){
        if(i+1 < argc) outfile = argv[++i];
      } else if(!strcmp(argv[i],"-addr")){
        flag_do_addr_taken = true;
      } else if(!strcmp(argv[i],"-pta")){
        mode = tcm_pta;
      } else if(!strcmp(argv[i],"-callgraph")){
        mode = tcm_callgraph;
      } else if(!strcmp(argv[i],"-callgraph-dot")){
        mode = tcm_callgraph;
        callgraph_dot = true;
      } else if(!strncmp(argv[i],"-calltrace=", 11)){
        mode = tcm_callgraph;
        calltrace = &argv[i][11];
      } else if(!strcmp(argv[i],"-ptr")){
        mode = tcm_ptr;
        flag_readwrite = true;
      } else if(!strcmp(argv[i],"-ptrw")){
        mode = tcm_ptrw;
        flag_readwrite = false;
      } else if(!strcmp(argv[i],"-nt")){
        mode = tcm_full;
      } else if(!strcmp(argv[i],"-vuln")){
        flag_vuln = true;
      } else if(!strcmp(argv[i],"-no-vuln")){
        flag_vuln = false;
      } else if(!strcmp(argv[i],"-heap")){
        flag_heapstack = 1;
      } else if(!strcmp(argv[i],"-heapstack")){
        flag_heapstack = 2;
      } else if(!strcmp(argv[i],"-ptr-heap")){
        flag_heapstack = 1;
      } else if(!strcmp(argv[i],"-ptr-heapstack")){
        flag_heapstack = 2;
      } else if(!strcmp(argv[i],"-strlit-writable")){
        flag_strlit_readonly = false;
      } else if(!strcmp(argv[i],"-unsafe-derefs")){
        flag_all_deref_unsafe = true;
      } else if(!strcmp(argv[i],"-dfa")){
        flag_may_be_uninit = 1;
      } else if(!strcmp(argv[i],"-vtfix")){
        flag_vtfix = true;
      } else if(!strcmp(argv[i],"-no-vtfix")){
        flag_vtfix = false;
      } else if(!strcmp(argv[i],"-rda")){
        flag_reaching_defs = true;
      } else if(!strcmp(argv[i],"-red")){
        flag_redundant = true;
      } else if(!strcmp(argv[i],"-red-par")){
        flag_redundant = true;
        flag_red_paral2r = true;
      } else if(!strcmp(argv[i],"-red-no-par")){
        flag_redundant = true;
        flag_red_paral2r = false;
      } else if(!strcmp(argv[i],"-range")){
        flag_range = true;
      } else if(!strcmp(argv[i],"-ran-intra")){
        flag_range = true;
        flag_range_inter = false;
      } else if(!strcmp(argv[i],"-ran-inter")){
        flag_range = true;
        flag_range_inter = true;
      } else if(!strcmp(argv[i],"-ran-widen-always")){
        flag_range_widen_always = true;
      } else if(!strcmp(argv[i],"-ran-widen-backedge")){
        flag_range_widen_always = false;
      } else if(!strcmp(argv[i],"-ran-DO")){
        flag_range_must_have_ao = false;
        flag_range_ty_can_change = true;
        flag_range_do_sliding = true;
      } else if(!strcmp(argv[i],"-ran-LO")){
        flag_range_must_have_ao = true;
        flag_range_ty_can_change = false;
        flag_range_do_sliding = false;
      } else if(!strcmp(argv[i],"-ran-must-ao")){
        flag_range_must_have_ao = true;
      } else if(!strcmp(argv[i],"-ran-must-ao-no")){
        flag_range_must_have_ao = false;
      } else if(!strcmp(argv[i],"-ran-tychange-yes")){
        flag_range_ty_can_change = true;
      } else if(!strcmp(argv[i],"-ran-tychange-no")){
        flag_range_ty_can_change = false;
      } else if(!strcmp(argv[i],"-ran-sliding-yes")){
        flag_range_do_sliding = true;
      } else if(!strcmp(argv[i],"-ran-sliding-no")){
        flag_range_do_sliding = false;
      } else if(!strcmp(argv[i],"-ran-dopreds-yes")){
        flag_range_handle_preds = true;
      } else if(!strcmp(argv[i],"-ran-dopreds-no")){
        flag_range_handle_preds = false;
      } else if(!strcmp(argv[i],"-ran-skip-tgted-preds")){
        flag_range_skip_targeted_preds = true;
      } else if(!strcmp(argv[i],"-ran-exactsizes")){
        flag_range_exact_sizes = true;
      } else if(!strcmp(argv[i],"-ran-exactsizes-no")){
        flag_range_exact_sizes = false;
      } else if(!strcmp(argv[i],"-ran-narrow")){
        flag_range_do_narrow = true;
      } else if(!strcmp(argv[i],"-ran-no-narrow")){
        flag_range_do_narrow = false;
      } else if(!strcmp(argv[i],"-ran-narrow-always")){
        flag_range_do_narrow = true;
        flag_range_narrow_always = true;
      } else if(!strcmp(argv[i],"-ran-narrow-backedge")){
        flag_range_do_narrow = true;
        flag_range_narrow_always = false;
      } else if(!strcmp(argv[i], "-ran-malloc")){
        flag_range_handle_malloc = true;
      } else if(!strcmp(argv[i], "-ran-no-malloc")){
        flag_range_handle_malloc = false;
      } else if(!strcmp(argv[i], "-ran-zero-special")){
        flag_range_zero_special = true;
      } else if(!strcmp(argv[i], "-ran-no-zero-special")){
        flag_range_zero_special = false;
      } else if(!strcmp(argv[i], "-ran-collect-stats")){
        local_flag_range_collect_stats = 1;
      } else if(!strcmp(argv[i], "-ran-no-collect-stats")){
        local_flag_range_collect_stats = 0;
      } else if(!strcmp(argv[i], "-ran-filter-loop-backedge")){
        flag_range_filter_loop_backedge = true;
      } else if(!strcmp(argv[i], "-ran-no-filter-loop-backedge")){
        flag_range_filter_loop_backedge = false;
      } else if(!strcmp(argv[i], "-ran-filter-call-backedge")){
        flag_range_filter_call_backedge = true;
      } else if(!strcmp(argv[i], "-ran-no-filter-call-backedge")){
        flag_range_filter_call_backedge = false;
      } else if(!strcmp(argv[i],"-mbu-intra")){
        flag_mbu_inter = false;
        if(!flag_may_be_uninit) flag_may_be_uninit = 1;
      } else if(!strcmp(argv[i],"-mbu-intra-iref")){
        flag_compute_iref = true;
        flag_mbu_inter = false;
        if(!flag_may_be_uninit) flag_may_be_uninit = 1;
      } else if(!strcmp(argv[i],"-mbu-inter")){
        flag_mbu_inter = true;
        if(!flag_may_be_uninit) flag_may_be_uninit = 1;
      } else if(!strncmp(argv[i],"-mbu",4)){
        flag_may_be_uninit = atoi(argv[i]+4);
        if(flag_may_be_uninit < 1)
           flag_may_be_uninit = 1;
      } else if(!strcmp(argv[i],"-pmbu-sensitive")){
        flag_pmbu_sensitive = true;
        if(!flag_may_be_uninit) flag_may_be_uninit = 1;
      } else if(!strcmp(argv[i],"-pmbu-insensitive")){
        flag_pmbu_sensitive = false;
        if(!flag_may_be_uninit) flag_may_be_uninit = 1;
      } else if(!strncmp(argv[i],"-wlmode", 7)){
        flag_verbose = (isdigit(argv[i][7]))
			? (argv[i][7] - '0')
			: 0;
      } else if(!strcmp(argv[i],"-fifo")){
        flag_worklist_mode = WL_MODE_FIFO;
      } else if(!strcmp(argv[i],"-lifo")){
        flag_worklist_mode = WL_MODE_LIFO;
      } else if(!strcmp(argv[i],"-leaf")){
        flag_worklist_mode = WL_MODE_LEAF_FIRST;
      } else if(!strcmp(argv[i],"-wli-topo")){
        flag_worklist_init_depth_first = false;
      } else if(!strcmp(argv[i],"-wli-depth")){
        flag_worklist_init_depth_first = true;
      } else if(!strcmp(argv[i],"-relevant-aos")){
        flag_filter_relevant_aos = true;
      } else if(!strcmp(argv[i],"-no-relevant-aos")){
        flag_filter_relevant_aos = false;
      } else if(!strcmp(argv[i],"-inst-fields")){
        flag_instantiate_structunion = true;
      } else if(!strcmp(argv[i],"-no-inst-fields")){
        flag_instantiate_structunion = false;
      } else if(!strcmp(argv[i],"-ltsize")){
        flag_mbu_lowerthan_by_size = true;
      } else if(!strcmp(argv[i],"-callmeet")){
        flag_callsite_top = false;
      } else if(!strcmp(argv[i],"-bblocks")){
        flag_use_bblocks = true;
      } else if(!strcmp(argv[i],"-no-bblocks")){
        flag_use_bblocks = false;
      } else if(!strcmp(argv[i],"-fixnargs")){
        flag_use_maxnargs = true;
      } else if(!strcmp(argv[i],"-no-fixnargs")){
        flag_use_maxnargs = false;
      } else if(!strcmp(argv[i],"-cde-incl")){
        flag_collapse_inclto_cycle = true;
      } else if(!strcmp(argv[i],"-no-cde-incl")){
        flag_collapse_inclto_cycle = false;
      } else if(!strcmp(argv[i],"-cde-pt")){
        flag_collapse_ptsto_cycle = true;
      } else if(!strcmp(argv[i],"-no-cde-pt")){
        flag_collapse_ptsto_cycle = false;
      } else if(!strcmp(argv[i],"-recycle")){
        flag_recycle = true;
        suco_recycle = true;
      } else if(!strcmp(argv[i],"-no-recycle")){
        flag_recycle = false;
        suco_recycle = false;
      } else if(!strcmp(argv[i],"-debug")){
        debug_mode = true;
        flag_readable_output = true;
      } else if(!strcmp(argv[i],"-readable")){
        flag_readable_output = true;
      } else if(!strcmp(argv[i],"-gref")){
        flag_gref_filter = true;
      } else if(!strcmp(argv[i],"-no-gref")){
        flag_gref_filter = false;
      } else if(!strcmp(argv[i],"-gmodref-include-locals")){
        flag_gmodref_skip_locals = false;
      } else if(!strcmp(argv[i],"-gmodref-skip-locals")){
        flag_gmodref_skip_locals = true;
      } else if(!strcmp(argv[i],"-summary")){
        summary_mode = true;
      } else if(!strcmp(argv[i],"-no-output")){
        no_output = true;
      } else if(argv[i][0] == '-' && argv[i][1] == 'v'){
        flag_verbose = (isdigit(argv[i][2]))
			? (argv[i][2] - '0')
			: 2;
      } else {
        fprintf(stderr, "Unrecognized option [%s] ignored\n", argv[i]);
      }
    } else {
      infiles.Append(argv[i]); //-- collect input files
    }
  }

  if(mode == tcm_ptrw){
    flag_mark_strlit_invalid = flag_strlit_readonly;
  }
  if(local_flag_range_collect_stats == -1){
    if(mode == tcm_ptr) flag_range_collect_stats = true;
  } else {
    flag_range_collect_stats = local_flag_range_collect_stats;
  }
  TCAstate state;

  TCstats::timer("reading files");
  suco_iterator<const char *> ifi(infiles); //-- read in from input files
  while(ifi.Iterate())
    state.processFile((char *)ifi.Current());
  fprintf(stderr, "\n");
  TCstats::timer(0);

  if(!outfile)
    outfile = (debug_mode || summary_mode)?"a.debug_dump":"a.tc_tsls";

  fprintf(stderr, "Doing analysis\n");
  switch(mode){
    case tcm_ptr:
    case tcm_ptrw:
      if(flag_do_addr_taken){
        state.addrAssignAnalysis(true);
      } else {
        TCstats::timer("flow-insensitive invalid-ptr analysis");
        state.ptAnalysis();
        state.supplementalPTanalysis();
        if(flag_all_deref_unsafe) state.allDerefUnsafeAnalysis();
        else state.invalidPtrAnalysis();
        TCstats::timer(0);
        state.ptrFlowSensitiveAnalyses();
      }
      if(flag_vuln) state.computeVulnerable();
      break;

    case tcm_pta:
    case tcm_callgraph:
      state.ptAnalysis();
      state.supplementalPTanalysis();
      break;

    default:
    case tcm_full:
      if(flag_do_addr_taken){
        state.addrAssignAnalysis(false);
      } else {
        TCstats::timer("flow-insensitive TSC analysis");
        state.ptAnalysis();
        state.supplementalPTanalysis();
        state.possTypeAnalysis();
        state.tscAnalysis();
        TCstats::timer(0);
        state.tcFlowSensitiveAnalyses();
      }
      break;
  }
  fprintf(stderr, "Analysis Done\n");

  if(!no_output){
    FILE * outf = fopen(outfile, "w");
    if(!outf){
      fprintf(stderr, "Error opening output file %s\n", outfile);
    } else {
      const char * ata = (flag_do_addr_taken)?" - Address Taken Analysis":"";
      fprintf(stderr, "Writing output to file [%s]\n", outfile);
      switch(mode){
        case tcm_ptr:  fprintf(outf, "# Invalid Pointer Analysis%s\n", ata); break;
        case tcm_ptrw: fprintf(outf, "# Invalid Pointer (write-only) Analysis%s\n", ata); break;
        case tcm_pta:  fprintf(outf, "# Points-To Analysis\n"); break;
        case tcm_callgraph:  fprintf(outf, "# Callgraph\n"); break;
        default:
        case tcm_full: fprintf(outf, "# Full (nt) Type-Safty Analysis%s\n", ata); break;
      }

      fprintf(outf, "# Flow-sensitive Analyses:");
      if(flag_reaching_defs) fprintf(outf, " -rda");
      if(flag_may_be_uninit) fprintf(outf, " -mbu%d%s%s%s",
					flag_may_be_uninit,
					flag_mbu_inter?"":"-intra",
					flag_pmbu_sensitive?"-sensitive":"",
					flag_compute_iref?"-iref":"-gref");
      if(flag_heapstack == 1) fprintf(outf, " -heap");
      if(flag_heapstack == 2) fprintf(outf, " -heapstack");

      if(flag_redundant){
        fprintf(outf, " -red");
        if(flag_red_paral2r) fprintf(outf, "(par)");
      }
      if(flag_vtfix) fprintf(outf, " -vtfix");
      if(flag_range){
        fprintf(outf, " -range-%s (filter-backedge:loop=%s,callgraph=%s)(widen %s)",
			(flag_range_inter)?"inter":"intra",
			(flag_range_filter_loop_backedge)?"yes":"no",
			(flag_range_filter_call_backedge)?"yes":"no",
			(flag_range_widen_always)?"always":"on backedge");
        if(flag_range_do_narrow) fprintf(outf, "(narrow %s)", (flag_range_narrow_always)?"always":"on backedge");
      }
      fprintf(outf, "\n");

      if(debug_mode){
        state.debug_dump(outf);
      } else if(summary_mode){
        state.summary_dump(outf);
        fprintf(outf, "--Dereference-AO Aliases--\n");
	state.writeAliases(outf);
      } else {
        switch(mode){
	  case tcm_pta:
	    state.writeAliases(outf);
	    break;
	  case tcm_callgraph:
	    state.writeCallgraph(outf, callgraph_dot, calltrace);
	    break;
	  default:
	    state.writeTSoutput(outf, (mode == tcm_full) && flag_do_addr_taken);
	    break;
        }
      }
      if(flag_vuln && (mode == tcm_ptr || mode == tcm_ptrw)){
        state.writeVulnerable(outf);
      }
      fclose(outf);
    }
  }

  //- verbose: output runtime flags for verification
  if(flag_verbose){
#define WRITE_FLAG_VALUE(flag) fprintf(stderr, #flag " = %d\n", flag)
    WRITE_FLAG_VALUE(flag_do_addr_taken);
    WRITE_FLAG_VALUE(flag_use_maxnargs);
    WRITE_FLAG_VALUE(flag_collapse_inclto_cycle);
    WRITE_FLAG_VALUE(flag_collapse_ptsto_cycle);
    WRITE_FLAG_VALUE(flag_verbose);
    WRITE_FLAG_VALUE(flag_recycle);
    WRITE_FLAG_VALUE(flag_readable_output);
    WRITE_FLAG_VALUE(flag_gref_filter);
    WRITE_FLAG_VALUE(flag_gmodref_skip_locals);
    WRITE_FLAG_VALUE(flag_heapstack);
    WRITE_FLAG_VALUE(flag_may_be_uninit);
    WRITE_FLAG_VALUE(flag_mbu_inter);
    WRITE_FLAG_VALUE(flag_compute_iref);
    WRITE_FLAG_VALUE(flag_pmbu_sensitive);
    WRITE_FLAG_VALUE(flag_reaching_defs);
    WRITE_FLAG_VALUE(flag_redundant);
    WRITE_FLAG_VALUE(flag_red_paral2r);
    WRITE_FLAG_VALUE(flag_instantiate_structunion);
    WRITE_FLAG_VALUE(flag_worklist_mode);
    WRITE_FLAG_VALUE(flag_worklist_init_depth_first);
    WRITE_FLAG_VALUE(flag_filter_relevant_aos);
    WRITE_FLAG_VALUE(flag_mbu_lowerthan_by_size);
    WRITE_FLAG_VALUE(flag_callsite_top);
    WRITE_FLAG_VALUE(flag_use_bblocks);
    WRITE_FLAG_VALUE(flag_range);
    WRITE_FLAG_VALUE(flag_range_inter);
    WRITE_FLAG_VALUE(flag_range_must_have_ao);
    WRITE_FLAG_VALUE(flag_range_ty_can_change);
    WRITE_FLAG_VALUE(flag_range_do_sliding);
    WRITE_FLAG_VALUE(flag_range_handle_preds);
    WRITE_FLAG_VALUE(flag_range_skip_targeted_preds);
    WRITE_FLAG_VALUE(flag_range_exact_sizes);
    WRITE_FLAG_VALUE(flag_range_do_narrow);
    WRITE_FLAG_VALUE(flag_range_widen_always);
    WRITE_FLAG_VALUE(flag_range_narrow_always);
    WRITE_FLAG_VALUE(flag_range_filter_loop_backedge);
    WRITE_FLAG_VALUE(flag_range_filter_call_backedge);
    WRITE_FLAG_VALUE(flag_range_zero_special);
    WRITE_FLAG_VALUE(flag_range_handle_malloc);
    WRITE_FLAG_VALUE(flag_strlit_readonly);
    WRITE_FLAG_VALUE(flag_vuln);
#undef WRITE_FLAG_VALUE
  }

  return 0;
}

//------------------------------------------------------
@


1.187
log
@Output timer for collecting mbu.
@
text
@d72 3
d1934 2
d2144 4
d2317 1
a2317 1
      if(flag_may_be_uninit) fprintf(outf, " -mbu%d%s%s",
d2320 2
a2321 1
					flag_pmbu_sensitive?"-sensitive":"");
d2381 1
@


1.186
log
@CHANGES:
1. Moved PExprAssign::getSingletonLHSloc() to
   ExpDescr::getSingletonLoc(), so it can be used
   elsewhere to determine strong update.
1a. FIXED BUG (??) in getSingletonLoc(): previously
    for sdot object, was returning enclosing struct!?!
2. Added -vtfix flag, which enables/disables RED and
   MBU treatment of verifyTag as fixing the type on
   mismatch.
3. Added MBU handling of verifyTag vtfix.
4. Changed so that MBU uses the RED parallel hackery
   (PM_RED_UNSAFE) when vtfix is on.
@
text
@d839 1
a839 1
        if(flag_verbose) TCstats::timer("collecting reaching-def/may-be-uninit results");
d841 1
a841 1
        if(flag_verbose) TCstats::timer(0);
d848 1
a848 1
        if(flag_verbose) TCstats::timer("collecting may-be-uninit/delta results");
d860 1
a860 1
        if(flag_verbose) TCstats::timer(0);
@


1.185
log
@Enabled -heap/-heapstack for nt mode also.
@
text
@d69 3
d1923 1
d2050 4
d2319 1
@


1.184
log
@RAN: added counter to count number of in-bounds
dereferences that contain an SDot/UDot ('M') or
Arrow ('W').
@
text
@d55 1
a55 1
int flag_ptr_heapstack = 0;
d607 23
d778 1
a778 1
  if(flag_ptr_heapstack){
d794 1
a794 1
    if(flag_ptr_heapstack == 2){
a1910 2
			   "       -ptr-heap        unsafe to point to freed-heap\n"
			   "       -ptr-heapstack   unsafe to point to freed-heap or stack\n"
d1914 3
d2032 4
d2037 1
a2037 1
        flag_ptr_heapstack = 1;
d2039 1
a2039 1
        flag_ptr_heapstack = 2;
d2304 2
a2305 2
      if(flag_ptr_heapstack == 1) fprintf(outf, " -ptr-heap");
      if(flag_ptr_heapstack == 2) fprintf(outf, " -ptr-heapstack");
d2359 1
a2359 1
    WRITE_FLAG_VALUE(flag_ptr_heapstack);
@


1.183
log
@Added "parallel-2-rounds" hackery to get RED (ptr mode)
to get better results -- results _MAY_ or may not be sound...
Complication: the fix "broke" RAN (it gave worse results).
SO, in the interest of thesis deadline, I've hacked BBA to
switch between the two versions depending on which analysis
is being run.
@
text
@a1189 1
          this->ran_num_inbounds_vps = rcfh.countInboundsVPs(false);
d1198 3
a1687 1
      fprintf(outf, "# RAN-count vps-inbounds = %d\n", this->ran_num_inbounds_vps);
d1694 3
@


1.182
log
@ADDED evaluation of each library function call to determine
if its target (where relevant) is exposed -- this will mainly
be used in -vulnw mode to remove instrumentation when a
function's target is exposed (needed to avoid false positive).
Eventually, it may also be used in -ptr/ptrw mode to remove
instrumentation when a library function's target is not
exposed -- though currently this never happens because of
context-insensitive analysis and overly-conservative models.
SUPPLEMENTAL CHANGES to achieve the above:
 1. Created ExposedStatus class in ao.cpp/ao.h (was previously
    an enum in AO class)
 2. Changed PExprcall::isDirectCall() to return the ID of the
    direct call, rather than just a bool.
 3. Exported "flag_readwrite" to become a global -- it's about
    time (I'd been misguidedly trying to avoid this for far
    too long, creating a bigger mess instead)
@
text
@d72 3
d842 1
a842 1
      RED red(REDtpFactHandler::handler);
d1135 1
a1135 1
        RED red(REDpFactHandler::handler);
d1148 1
a1148 1
        RED red(REDpwFactHandler::handler);
d1903 2
d2018 6
d2275 4
a2278 1
      if(flag_redundant) fprintf(outf, " -red");
d2333 1
@


1.181
log
@Augmented to handle ALLOCA:
(solution is hackish at best)
- added is_alloca flag to AOMalloc object.
  HOWEVER, this is set only by flow_sensitive
  PgmExpr/MallocDecl case!
- a second channel of information comes from
  the (long-forgotten) "stclass" field of ID.
  (This is the bit used in -ptr-heapstack mode)
@
text
@d20 3
a285 1
bool TCAstate::msp_readwrite = false;
d746 1
a746 1
void TCAstate::invalidPtrAnalysis(bool readwrite)
d778 1
a778 1
  traverseAOs(readwrite?assignTSCderef:assignTSCderefWrite);
d782 1
a782 1
void TCAstate::allDerefUnsafeAnalysis(bool readwrite)
d784 1
a784 1
  traverseAOs(readwrite?assignAllUnsafeRW:assignAllUnsafeW);
d852 2
a853 3
//- Mark starting points for relevant-aos filtering, controlled by two flags:
//  1. msp_readwrite : indicate whether to mark reads or read/writes
//  2. msp_relaos_mode : MBU or RAN mode
d872 1
a872 1
	(TCAstate::msp_readwrite && (pev.getVpKind() == PExprVerify::vpPtr))){
a982 1
  TCAstate::msp_readwrite = readwrite;
d1079 1
a1079 1
void TCAstate::ptrFlowSensitiveAnalyses(bool readwrite)
d1088 1
a1088 1
//        this->markRelevantLocs(readwrite, relaos_MBU);
d1091 1
a1091 1
      pMBUfactHandler::readwrite = readwrite;
d1129 1
a1129 1
      if(readwrite){ //- ptr
d1160 1
a1160 1
        this->markRelevantLocs(readwrite, relaos_RAN);
d1178 1
a1178 1
        RANcFactHandler rcfh(this->ran_results, readwrite);
d1384 144
d1589 2
a1590 2
                else fprintf(outf, "/ %c %c ",  AO::exposedCode(fao.pointsToExposed(false, flag_range, false)),
						AO::exposedCode(fao.pointsToExposed(true, flag_range, false)));
d1596 2
a1597 2
                  fprintf(outf, "/V%c %c ", AO::exposedCode(fao.pointsToExposed(false, flag_range, true)),
					      AO::exposedCode(fao.pointsToExposed(true, flag_range, true)));
d1661 6
d1989 1
d1992 1
d2208 2
a2209 2
        if(flag_all_deref_unsafe) state.allDerefUnsafeAnalysis(mode == tcm_ptr);
        else state.invalidPtrAnalysis(mode == tcm_ptr);
d2211 1
a2211 1
        state.ptrFlowSensitiveAnalyses(mode == tcm_ptr);
@


1.180
log
@Added "/V" output (freearg status for vuln mode).
Entailed hackishly modifying ECR::inclToExposed().
@
text
@d769 1
@


1.179
log
@MAJOR ADDITION: added -vuln mode computations to output
1. vulnerable locations (function pointers and first
   arguments to exec,system,longjmp,...)
2. vulnerable dereferences (any Ref ao that may point
   to a vulnerable location)
@
text
@d1444 2
a1445 2
                else fprintf(outf, "/ %c %c ",  AO::exposedCode(fao.pointsToExposed(false, flag_range)),
						AO::exposedCode(fao.pointsToExposed(true, flag_range)));
d1448 8
@


1.178
log
@Added argument to prepareCFG indicating whether or not
to prepare the CFG for widening (along backedges).
Those steps are (currently) needed only for range analysis.
@
text
@d115 3
d1266 117
d1726 1
d1834 4
d2052 1
d2133 3
d2179 1
d2181 1
a2181 1
    WRITE_FLAG_VALUE(flag_range_handle_malloc);
@


1.177
log
@Added CFG::traverseRootNodes, used by pmbu and tca.
The thing to remember is that this function traverses
first the enter node (if any) before going through
each function's root nodes.
@
text
@d784 1
a784 1
    cfg.prepareCFG();
d1078 1
a1078 1
    cfg.prepareCFG();
@


1.176
log
@1. Moved pMBU "write results" code from TCAstate
to pMBUfactHandler class.
2. Removed pMBU filterResults -- just output everything
and let sml decide which to instrument.
@
text
@d980 1
a980 7
  suco_iterator<CFGfunction *> cfi(cfg.getFunctionList());
  while(cfi.Iterate()){
    suco_iterator<PgmStmt *> psi(cfi.Current()->getStmtList());
    while(psi.Iterate()){
      psi.Current()->traverseRootNodes(TCAstate::markStartingPoints);
    }
  }
@


1.175
log
@1. Wrote flow-insensitive pmbu analysis; the flow-sensitive
   portion is now in a non-working state, and needs to be
   rewritten.
2. Moved some pmbu-related code from TCAstate to
   pMBUfactHandler class.
So now: pmbu-sensitive is working, but not pmbu-insensitive.
@
text
@d1396 1
a1396 25

    { //- write p-MBU results
      suco_iterator<AO *> aoi(pMBUfactHandler::results);
      while(aoi.Iterate()){
        fprintf(outf, "M ");
        aoi.Current()->write_string_rep(outf, flag_readable_output);
        fprintf(outf, "\n");
      }
    }
    { //- write p-MBU unsafe aos
      suco_iterator<AO *> aoi(pMBUfactHandler::unsafe);
      while(aoi.Iterate()){
        fprintf(outf, "U ");
        aoi.Current()->write_string_rep(outf, flag_readable_output);
        fprintf(outf, "\n");
      }
    }
    { //- write p-MBU tracked aos
      suco_iterator<AO *> aoi(pMBUfactHandler::tracked);
      while(aoi.Iterate()){
        fprintf(outf, "T ");
        aoi.Current()->write_string_rep(outf, flag_readable_output);
        fprintf(outf, "\n");
      }
    }
@


1.174
log
@Extracted pMBU from mbu.c/mbu.h into its own files
pmbu.c/pmbu.h
@
text
@d60 3
a1080 36
suco_set<AO *> TCAstate::pmbu_results;
suco_set<AO *> TCAstate::pmbu_unsafe;
suco_set<AO *> TCAstate::pmbu_tracked;
bool TCAstate::pmbu_readwrite = false;

//- collect PMBU unsafe and tracked aos:
//  unsafe = all (safe) deref aos affected by something in pmbu_results
//  tracked = all (untracked) locs aliased by a (newly-)unsafe ao
void TCAstate::collectPMBUtrackedUnsafe(AO& ao)
{

  if(ao.isRef() && (ao.getTSC() > AO::TSC_POSS_INVALID)
	&& (TCAstate::pmbu_readwrite || ao.isAssigned())){
    suco_set<ECR *> affecrs;
    ao.getECR().collectAliasECRs(affecrs, true);	//- using this, because getAliasECRs filters loc/argret
    suco_iterator<ECR *> afecri(affecrs);
    while(afecri.Iterate()){
      if(afecri.Current()->getAOset().Intersects(TCAstate::pmbu_results)){
        //- found pmbu-unsafe ao
        TCAstate::pmbu_unsafe.Insert(&ao);
        //- collect pmbu-tracked = loc aliases
        suco_iterator<ECR *> alecri(ao.getECR().getAliasECRs());
        while(alecri.Iterate()){
          suco_iterator<AO *> aoi(alecri.Current()->getAOset());
          while(aoi.Iterate()){
            if(aoi.Current()->isLocArgRet() && aoi.Current()->getTSC() == AO::TSC_SAFE){
              TCAstate::pmbu_tracked.Insert(aoi.Current());
            }
          }
        }
        return;
      }
    }
  }
}

d1088 26
a1113 2
      if(flag_filter_relevant_aos){
        this->markRelevantLocs(readwrite, relaos_MBU);
d1116 1
a1116 10
      //- (ptr/ptrw)-mode mbu analysis: only check safe/exposed pointers
      TCstats::timer("may-be-uninit analysis");
      pMBUfactHandler pmbuh(TCAstate::pmbu_results, readwrite);
      MBU pmbu(false, pmbuh);
      pmbu.doAnalysis(cfg, true);	//-true=skip_libfns
      if(flag_verbose) TCstats::timer(0);

      //- collect pMBU-unsafe and pMBU-tracked aos
      TCAstate::pmbu_readwrite = readwrite;
      this->traverseAOs(TCAstate::collectPMBUtrackedUnsafe);
d1119 3
a1121 3
			TCAstate::pmbu_results.Length(),
			TCAstate::pmbu_unsafe.Length(),
			TCAstate::pmbu_tracked.Length());
d1124 3
a1126 3
      if(flag_filter_relevant_aos){
        this->traverseAOs(TCAstate::resetRelevantTag);
      }
d1398 1
a1398 1
      suco_iterator<AO *> aoi(TCAstate::pmbu_results);
d1406 1
a1406 1
      suco_iterator<AO *> aoi(TCAstate::pmbu_unsafe);
d1414 1
a1414 1
      suco_iterator<AO *> aoi(TCAstate::pmbu_tracked);
d1580 1
a1580 1
    suco_iterator<AO *> pmi(TCAstate::pmbu_results);
d1646 2
d1839 6
d2000 1
a2000 1
      if(flag_may_be_uninit) fprintf(outf, " -mbu%d%s",
d2002 2
a2003 1
					flag_mbu_inter?"":"-intra");
d2056 1
@


1.173
log
@Refined pMBU tracked/unsafe mechanism to account for
readwrite -- involves another ugly class-static flag.
@
text
@d15 1
@


1.172
log
@Slight re-ordering of pmbu unsafe/tracked collection
mechanism.
@
text
@d1080 1
d1087 3
a1089 1
  if(ao.isRef() && (ao.getTSC() > AO::TSC_POSS_INVALID)){
d1132 1
@


1.171
log
@pMBU now outputs in two modes:
mode 1: "M" = may-be-uninit location that may be
	dereferenced -- this is used by sml when
	-nullifySafeUninitPtrs is on, to zero-init
	these may-be-uninit locations.
mode 2: if -nullifySafeUninitPtrs is off, then
	treate all may-be-uninit derefs as unsafe,
	and their pointed-to locations as tracked.
	This is given by "U" and "T" lines respectively.
@
text
@d1077 33
d1128 7
a1134 1
      fprintf(stderr, "pMBU: %d aos\n", TCAstate::pmbu_results.Length());
a1281 33
suco_set<AO *> TCAstate::pmbu_results;
suco_set<AO *> TCAstate::pmbu_unsafe;
suco_set<AO *> TCAstate::pmbu_tracked;

//- collect PMBU unsafe and tracked aos:
//  unsafe = all (safe) deref aos affected by something in pmbu_results
//  tracked = all (untracked) locs aliased by a (newly-)unsafe ao
void TCAstate::collectPMBUtrackedUnsafe(AO& ao)
{
  if(ao.isRef() && (ao.getTSC() > AO::TSC_POSS_INVALID)){
    suco_set<ECR *> affecrs;
    ao.getECR().collectAliasECRs(affecrs, true);	//- using this, because getAliasECRs filters loc/argret
    suco_iterator<ECR *> afecri(affecrs);
    while(afecri.Iterate()){
      if(afecri.Current()->getAOset().Intersects(TCAstate::pmbu_results)){
        //- found pmbu-unsafe ao
        TCAstate::pmbu_unsafe.Insert(&ao);
        //- collect pmbu-tracked = loc aliases
        suco_iterator<ECR *> alecri(ao.getECR().getAliasECRs());
        while(alecri.Iterate()){
          suco_iterator<AO *> aoi(alecri.Current()->getAOset());
          while(aoi.Iterate()){
            if(aoi.Current()->isLocArgRet() && aoi.Current()->getTSC() == AO::TSC_SAFE){
              TCAstate::pmbu_tracked.Insert(aoi.Current());
            }
          }
        }
        return;
      }
    }
  }
}

a1417 6

    //- collect pMBU-unsafe and pMBU-tracked aos
    TCAstate::pmbu_unsafe.Clear();
    TCAstate::pmbu_tracked.Clear();
    this->traverseAOs(TCAstate::collectPMBUtrackedUnsafe);

@


1.170
log
@Added new flag "skip_libfn" to DFA::doAnalysis and
BBA::collectResults to control whether or not to
process library functions.
~> currently, only pMBU skips library fns.
~> other analyses still need to go through
   library fns, to process "touched aos" etc.
   *TODO*: recognize that we're in a libfn,
	and just do touched aos w/o collecting
	e.g. RAN aids.
@
text
@d1090 1
a1090 1
      pMBUfactHandler pmbuh(this->pmbu_results, readwrite);
d1095 3
d1243 33
d1404 29
a1432 6
    //- write p-MBU results
    suco_iterator<AO *> aoi(this->pmbu_results);
    while(aoi.Iterate()){
      fprintf(outf, "M ");
      aoi.Current()->write_string_rep(outf, flag_readable_output);
      fprintf(outf, "\n");
d1592 2
a1593 2
    fprintf(outf, "--pMBU results:\n");
    suco_iterator<AO *> pmi(this->pmbu_results);
@


1.169
log
@Added pMBU: may-be-uninit analysis for ptr/ptrw mode.
Very conservative, and still slow...
@
text
@d1092 1
a1092 1
      pmbu.doAnalysis(cfg);
@


1.168
log
@Changed GMOD/GREF to _exclude_ local variables taht
are only directly accessed.  (Added flag_gmodref_skip_locals
to control this.)
THIS IS A SIGNIFICANT CHANGE, and has been minimally verified
for RAN; need to validate for RED,MBU,other analyses.
@
text
@d798 1
a798 1
        MBUc rdmb(rmh, this->mbu_results, flag_mbu_inter);
d812 1
a812 1
        MBUc mbuc1(c1h, this->mbu_results, flag_mbu_inter);
d817 1
a817 1
        MBUc mbuc2(c2h, this->mbu_results, flag_mbu_inter);
d923 5
d1087 2
a1088 2
/*
      //- ptr(w) mode mbu analysis: only check safe/exposed pointers
d1090 3
a1092 9
      if(flag_verbose) fprintf(stderr, "(mbu level %d)\n", flag_may_be_uninit);
      MBU mbu(flag_mbu_inter);
      mbu.doAnalysis(cfg);
      TCstats::timer(0);

      if(flag_verbose) TCstats::timer("collecting may-be-uninit/ptr results");
      MBUcpfactHandler cph(this->mbu_results);
      MBUcp mbucp(cph, this->mbu_results);
      mbucp.collectResults(cfg);
d1095 3
a1097 3
      //- for each result index object, propagateExposed on its ecr
      this->mbu_results.markAOsExposed();
*/
d1170 3
d1367 8
d1531 9
@


1.167
log
@Added flag_range_skip_targeted_preds: when set, will
not try to improve ranges at predicates for targeted
ranges (improve only NULL-targeted ranges).
@
text
@d40 3
d1619 4
a1622 1
			   "     -wlmode[012] } worklist traversal order (default = leaf):\n"
d1829 4
d1978 1
@


1.166
log
@SMALL BUT MAJOR BUG FIX: RANc must take a flag indicating
whether to do intra or inter!  (Previously, was always
doing intra mode!)

Also: added ugly flag "flag_debug_range_collect_phase"
to help in debugging, currently used to output meaningful
information when reporting known predicates.
@
text
@d90 1
d1592 2
d1720 2
d1986 1
@


1.165
log
@Fixed efficiency bug: in ECR::collectAliasECRs, the
"has_locs" filter mechanism was removing non-loc ECRs
from the list too early, so the same sub-graph would've
been traversed multple times.
Now, loc-filtering is done separately, by a new function
ECR::filterLocArgRet().
@
text
@d107 3
d1149 2
a1150 1
        RANc ranc(rcfh);
@


1.164
log
@Deleted ecrSetIsRelevant, which had been obsolesced.
@
text
@d440 1
a440 1
    ECR::getECR(fpao).collectAliasECRs(alias_ecrs, false);	//- Still not safe to use getAliasECRs?
d1041 1
a1041 1
      aei.Current()->getFrom().getECR().collectAliasECRs(from_ecrs, false, true);
@


1.163
log
@RELEVANT AOS DONE (but some parts not efficient):
 - Added Dependency and DependencyMap classes, to record
   dependencies not captured by flow-insensitive assign
   edges.
 - Revamped tca relevant-aos collecting mechanism.
Note: certain recent changes rendered certain operations
less efficient, like getAliasECRs.
@
text
@a915 14
bool TCAstate::ecrSetIsRelevant(suco_set<ECR *>& eset)
{
  suco_iterator<ECR *> ei(eset);
  while(ei.Iterate()){
    suco_iterator<AO *> ai(ei.Current()->getAOset());
    while(ai.Iterate()){
      if(ai.Current()->dfa_relevant){
        return true;
      }
    }
  }
  return false;
}

@


1.162
log
@MAJOR UPDATE: towards relevant aos.
THIS VERSION RELIES ON ExpDescr's aoset TO CAPTURE
ALL DEPENDENCE INFORMATION, WHICH IS NOT THE CASE.
@
text
@d271 2
a272 1
suco_set<ECR *> TCAstate::msp_mallocsize_ecrs;
d835 1
a835 2
//- Mark starting points for relevant-aos filtering.
//  Uses three static members:
d839 11
a849 3
//     - if RAN mode, mark unsafe derefs and tracked malloc sizes,
//	 and collect malloc sizes in msp_mallocsize_ecrs
//  3. msp_mallocsize_ecrs : for RAN mode only, see 2.
d874 1
a874 6
          suco_iterator<AO *> aoi(aei.Current()->getAOset());
          while(aoi.Iterate()){
            if(aoi.Current()->isLocArgRet()){	//- redundant test?
              aoi.Current()->dfa_relevant = true;
            }
          }
d879 6
a884 5
  //- 2. RAN mode: malloc decl (future extension: any decl, if size argument may be a variable)
  //     - mark relevant, and collect in TCAstate::msp_mallocsize_ecrs
  if((TCAstate::msp_relaos_mode == relaos_RAN)
	&& (pe.getKind() == PgmExpr::fDecl)){
    PExprDecl& ped = (PExprDecl&) pe;
d886 6
a891 10
    if(ped.isMalloc() && ped.getMallocSize()){
      suco_set<ECR *> affecrs;
      ped.getMallocSize()->collectAffectingAliasLocECRs(affecrs); //-TODO: need only deref one level?
      suco_iterator<ECR *> aei(affecrs);
      while(aei.Iterate()){
        suco_iterator<AO *> aoi(aei.Current()->getAOset());
        while(aoi.Iterate()){
          if(aoi.Current()->isLocArgRet()){
            aoi.Current()->dfa_relevant = true;
          }
d894 17
a910 1
      TCAstate::msp_mallocsize_ecrs.UnionConsume(affecrs);
d948 1
a948 2
//- returns false if eset is empty
bool TCAstate::ecrsToAssignEdges(suco_set<ECR *>& eset, suco_set<TCassignEdge *>& edges, bool incoming)
d950 6
a955 11
  if(eset.IsEmpty()) return false;
  else {
    suco_iterator<ECR *> ecri(eset);
    while(ecri.Iterate()){
      suco_iterator<AO *> aoi(ecri.Current()->getAOset());
      while(aoi.Iterate()){
        edges.Union((incoming)
			? (aoi.Current()->getIncomingAssignEdges())
			: (aoi.Current()->getOutgoingAssignEdges())
		   );
      }
a956 1
    return true;
a964 2
//     ALSO: due two phases for mallocsizes: first backward then
//	forward!  Use msp_mallocsize_ecrs as holder.
d971 1
a971 1
  //  I. Clear dfa_relevant tags
d973 1
a973 1
  TCAstate::msp_mallocsize_ecrs.Clear();	//- RAN: mallocsize set
d993 1
a993 1
    fprintf(stderr, "--Starting Points AOs: %d, Total AOs: %d\n",
d996 1
a996 3
    if(TCAstate::msp_relaos_mode == relaos_RAN){
      fprintf(stderr, " -Malloc ECRs: %d\n", TCAstate::msp_mallocsize_ecrs.Length());
    } 
d998 14
d1013 1
a1013 13
  // III. Follow assignment edges backwards:
  //      (don't filter by relmode, since locs of any classification may affect
  //      the points of interest)
  suco_set<TCassignEdge *> pending_list;
  pending_list.InsertList(this->assigns);
  pending_list.InsertList(this->arg_ret_assigns);
  while(!pending_list.IsEmpty()){
    suco_set<TCassignEdge *> active_list;
    active_list.Attach(pending_list);
/**/fprintf(stderr, "DEBUG relevant: active_list size = %d...\n", active_list.Length());
    suco_iterator<TCassignEdge *> aei(active_list);
    while(aei.Iterate()){
      if(TCAstate::ecrSetIsRelevant(aei.Current()->getTo().getECR().getAliasECRs())){
d1015 20
a1034 24
        bool do_mallocsize = TCAstate::msp_mallocsize_ecrs.Intersects(aei.Current()->getTo().getECR().getAliasECRs());

        //- 1. collect affecting ecrs: "from" aliases + de-starred ao aliases
        suco_set<ECR *> from_affecting_ecrs;
        aei.Current()->getFrom().getECR().collectAliasECRs(from_affecting_ecrs, false, true); //- true=follow de-starred ao aliases

        //- 2. collect unprocessed back-prop'ed ecrs: for each irrelevant loc-ao* in
        //	from-affecting_ecrs, follow incl-edges backwards
        //	(*loc-ao, or all aos?)
        suco_set<ECR *> inclfrom_ecrs;
        suco_iterator<ECR *> fecri(from_affecting_ecrs);
        while(fecri.Iterate()){
          suco_iterator<AO *> aoi(fecri.Current()->getAOset());
          while(aoi.Iterate()){
            AO& ao = *aoi.Current();
            if(!ao.dfa_relevant && ao.isLocArgRet()){
              ao.dfa_relevant = true;
              suco_set<ECR *> ao_inclfrom_ecrs;
              ao.getECR().collectInclFromECRs(ao_inclfrom_ecrs);
              if(do_mallocsize){
                TCAstate::msp_mallocsize_ecrs.Union(ao_inclfrom_ecrs);
              }
              inclfrom_ecrs.UnionConsume(ao_inclfrom_ecrs);
            }
d1037 2
d1040 7
a1046 3
        //- 3. add to pending list each assignment assigning
	//	into incl_from_ecrs
        TCAstate::ecrsToAssignEdges(inclfrom_ecrs, pending_list, true); //- true=incoming edges
a1048 1
  }
d1050 13
a1062 37
  //  IV. RAN mode: from mallocsize locs, follow assignments forward
  if(TCAstate::msp_relaos_mode == relaos_RAN){
    if(flag_verbose){
      fprintf(stderr, "--After back-prop: %d Malloc ECRs\n", TCAstate::msp_mallocsize_ecrs.Length());
    }
    if(TCAstate::msp_mallocsize_ecrs.Length() > 0){
      suco_set<ECR *> pending_ecrs;
      pending_ecrs.Union(TCAstate::msp_mallocsize_ecrs);
      suco_set<TCassignEdge *> pending_edges;
      while(TCAstate::ecrsToAssignEdges(pending_ecrs, pending_edges, false)){ //- false=outgoing edges
        pending_ecrs.Clear();
        suco_set<TCassignEdge *> active_edges;
        active_edges.Attach(pending_edges);
        suco_iterator<TCassignEdge *> aei(active_edges);
        while(aei.Iterate()){
          //- 1. collect affecting ecrs: "to" aliases + de-starred ao aliases
          suco_set<ECR *> to_affecrs;
          aei.Current()->getTo().getECR().collectAliasECRs(to_affecrs, false, true); //- true=follow de-starred ao aliases

          //- 2. for each unprocessed loc-ao* in to_affecrs, follow incl-edges backwards
          suco_iterator<ECR *> tecri(to_affecrs);
          while(tecri.Iterate()){
            if(TCAstate::msp_mallocsize_ecrs.Insert(tecri.Current())){
              //- new ecr encountered: mark aos relevant, and collect incl-from ecrs
              //- a. mark aos relevant
              suco_iterator<AO *> aoi(tecri.Current()->getAOset());
              while(aoi.Iterate()){
                AO& ao = *aoi.Current();
                if(ao.isLocArgRet()){
                  ao.dfa_relevant = true;
                }
              }
              //- b. collect pending ecrs
              tecri.Current()->collectInclFromECRs(pending_ecrs);
            }
          }
        }
d1065 1
a1065 4
    if(flag_verbose){
      fprintf(stderr, "--After forward-prop: %d Malloc ECRs\n", TCAstate::msp_mallocsize_ecrs.Length());
    }
  }
@


1.161
log
@1. Renamed ExpDescr's affaos to estr_aos, to avoid confusion
   with "affecting aos" (affecrs).
2. tca: more refinement of relevant-aos computation:
   - specially handle op/ext/star AOs -- not quite
     there yet (this is hopefully the last bit that
     needs to be fixed)
   - in RAN mode, starting points must include malloc
     sizes.
@
text
@d271 1
d439 1
a439 1
    ECR::getECR(fpao).collectAliasECRs(alias_ecrs);	//- Still not safe to use getAliasECRs?
d835 7
a841 4
//  Uses two static flags:
//  1. msp_readwrite : mark reads or read/writes
//  2. msp_relaos_mode : MBU (mark safe derefs) or RAN
//     (mark unsafe derefs and tracked malloc sizes)
d862 11
a872 1
        pev.getDesc().affLocsMarkRelevant();
d877 1
d883 12
a894 1
      ped.getMallocSize()->affLocsMarkRelevant();
d931 19
d956 2
d964 1
a964 1
  //  1. Clear dfa_relevant tags
d966 1
d968 1
a968 1
  //  2. Mark starting points: vptr/vptrw'ed aos that are safe/unsafe
d979 1
a979 1
  //  2a: verbose output
d983 2
a984 1
    fprintf(stderr, "STARTING POINTS:\n");
d989 3
d994 3
a996 2
  //  3. Follow assignment edges: this time, don't filter by relmode, since
  //     non-safe/non-unsafe locs may still affect the deref points of interest
d1007 4
d1012 9
a1020 9
        suco_iterator<ECR *> ei(aei.Current()->getFrom().getECR().getAliasECRs());
        while(ei.Iterate()){
          //- We want to collect all locations that affect the value of the rhs expression.
          //  This means any loc-ao that's related to the rhs aos, including:
          //  - x if rhs is "op x" or "ext x" or "star x"
          //(Note that currently getAliasECRs() does not recognize x as an alias of
          // "op x" or "ext x", which is enough for lvalue settings, but not here)
//TODO: NOTE: getAliasECRs ALSO DOES NOT LOOKUP ALIASES OF "op star x"!
          suco_iterator<AO *> aoi(ei.Current()->getAOset());
d1022 7
a1028 10
            AO * target_ao = aoi.Current();
            while(1){ //- strip off op/ext/star
              if(target_ao->getKind() == AO::aoOp){
                target_ao = &((AOOp *)target_ao)->getTarget();
              } else if(target_ao->getKind() == AO::aoExt){
                target_ao = &((AOExt *)target_ao)->getTarget();
              } else if(target_ao->getKind() == AO::aoStar){
                target_ao = &((AOStar *)target_ao)->getTarget();
              } else {
                break;  //- done
d1030 1
a1030 4
            }
            if(!target_ao->dfa_relevant && target_ao->isLocArgRet()){
              target_ao->dfa_relevant = true;
              target_ao->getECR().collectInclFromECRs(from_affecting_ecrs);
d1034 42
a1075 7
        if(!from_affecting_ecrs.IsEmpty()){
          //- add assign edges leading into from_affecting_ecrs
          suco_iterator<ECR *> faei(from_affecting_ecrs);
          while(faei.Iterate()){
            suco_iterator<AO *> aoi(faei.Current()->getAOset());
            while(aoi.Iterate()){
              pending_list.Union(aoi.Current()->getIncomingAssignEdges());
d1081 3
d1086 1
a1086 1
  //  4. Diagnostic: count relevant aos
d1090 2
a1091 1
  fprintf(stderr, "Relevant AOs: %d, Total AOs: %d\n",
@


1.160
log
@Towards relevant-aos support for RAN analysis:
1. tca.cpp: fixed bug in markStartingPoints;
2. ao.cpp: changed constructor to set dfa_relevant
   tag to true by default;
3. ran.cpp: RAN analysis now keeps track of ranges
   only for dfa_relevant-tagged AOs!
(I.e., w/o relevant-aos flag, all AOs are marked
 dfa-relevant=true by default).
@
text
@d270 1
a270 1
bool TCAstate::msp_keep_safe = false;
d833 5
a837 3
//- Two modes, depending on flag:
//  1. msp_keep_safe=true: for MBU, mark only safe/exposed afflocs
//  2. msp_keep_safe=false: for RAN, mark only afflocs of unsafe derefs
d840 1
d845 4
a848 3
      if(TCAstate::msp_keep_safe){
        //-MBU MODE: mark only safe affaos
        suco_iterator<AO *> aoi(pev.getDesc().getAffAOs());
d850 4
a853 21
          if(aoi.Current()->getTSC() >= AO::TSC_EXPOSED){
            aoi.Current()->dfa_relevant = true;
          }
        }
      } else {
        //-RAN MODE: mark affaos of unsafe deref
        bool is_unsafe_deref = false;
        {
          suco_iterator<AO *> aoi(pev.getDesc().getAOs());
          while(aoi.Iterate()){
            if(aoi.Current()->getTSC() < AO::TSC_EXPOSED){
              is_unsafe_deref = true;
              break;
            }
          }
        }
        if(is_unsafe_deref){
          suco_iterator<AO *> aoi(pev.getDesc().getAffAOs());
          while(aoi.Iterate()){
            aoi.Current()->dfa_relevant = true;
          }
d856 13
d896 6
a901 1
  if(ao.dfa_relevant)
d903 1
d907 3
a909 3
//  a. MBU (keep_safe=true): start with safe and exposed afflocs,
//	and propagate from there.
//  b. RAN (keep_safe=false): start with afflocs of unsafe derefs,
d914 1
a914 1
void TCAstate::markRelevantLocs(bool readwrite, bool keep_safe)
d922 1
a922 1
  TCAstate::msp_keep_safe = keep_safe;
d931 12
a942 1
  //  3. Follow assignment edges: this time, don't filter by keep_safe, since
d954 1
a954 1
        suco_set<ECR *> to_affecting_ecrs;
d957 6
a962 1
          bool changed = false;
d965 15
a979 3
            if(!aoi.Current()->dfa_relevant){
              changed = true;
              aoi.Current()->dfa_relevant = true;
a981 3
          if(changed){
            ei.Current()->collectInclFromECRs(to_affecting_ecrs);
          }
d983 5
a987 5
        if(!to_affecting_ecrs.IsEmpty()){
          //- add assign edges leaving to_affecting_ecrs
          suco_iterator<ECR *> taei(to_affecting_ecrs);
          while(taei.Iterate()){
            suco_iterator<AO *> aoi(taei.Current()->getAOset());
d989 1
a989 1
              pending_list.Union(aoi.Current()->getAssignEdges());
a995 1
  TCstats::timer(0);
d1004 2
d1016 1
a1016 1
        this->markRelevantLocs(readwrite, true);
d1070 1
a1070 1
        this->markRelevantLocs(readwrite, false);
@


1.159
log
@Suppressed spurious "addAssignEdges" warnings when the
assignment-target is a "last arg" (AOArg[largno](AOFunction)).
@
text
@d834 2
a835 2
//  1. msp_keep_safe=true: keep only safe/exposed locs (for MBU)
//  2. msp_keep_safe=false: keep all but safe/exposed locs (for RAN-filter)
d842 25
a866 4
      suco_iterator<AO *> aoi(pev.getDesc().getAffAOs());
      while(aoi.Iterate()){
        if((TCAstate::msp_keep_safe) ^ (aoi.Current()->getTSC() < AO::TSC_EXPOSED)){	//- tricky xor: see comment above
          aoi.Current()->dfa_relevant = true;
d900 8
a907 6
//- Used for two complementary purposes: mark all relevant loc-AOs
//  that affect dereferences (write-only or read+write, depending
//  on "readwrite" argument), marking only:
//  a. safe and exposed locs (if keep_safe=true)
//  b. non-safe and non-exposed locs (if keep_safe=false)
//- The markings are in the AO::dfa_relevant flag.
d1037 3
@


1.158
log
@More work towards filtering relevant AOs:
 - Added flag -relevant-aos
 - AO added "dfa_relevant" bit for each AO
 - ECR added "collectInclFromECRs() helper that's
   needed when collecting relevant aos
 - TCA added a bunch of helpers:
   - markRelevantLocs() which calls
     1. clearRelevantTags() on each AO, to clear
        the dfa_relevant tags
     2. markStartingPoints(), which walks the
        assignment edges (in the CFG!) to populate
        the initial set of aos (based on readwrite
        flag and whether we want to mark safe AOs
        (for MBU) or unsafe ones (for RAN)).
     3. propagate along (flow-insensitive) assign
        edges.
@
text
@d507 11
a517 5
                fprintf(stderr, "addAssignEdges: no static type, setting to void type, in:\n  ");
                lao.dump_descr(stderr);
                fprintf(stderr, "\n  --ASSIGN--> ");
                rao.dump_descr(stderr);
                fprintf(stderr, "\n");
@


1.157
log
@FIXED VARARG HANDLING:
- to be compliant with new "finalizeECR" phase change
  model, I had to change AO::get_AOArg to possibly
  return null, and create new AO::get_or_create_AOArg
  for early use to construct AOArg objects as needed.
- the above change required more careful handling
  (in ran.cpp) of function call argument passing:
  specifically, at callsite fp(i,j,n) where fp
  points to foo(i), there will be only two AOArg
  objects created for foo (F X I foo i and l where
  l is "last argno/largno"), so we will do:
  - strong assign for actuals up to largno:
    F X I foo i <=strong= actual(i)
    F X I foo l <=strong= actual(j)
  - weak assign for actuals beyond that point:
    F X I foo l <=weak= actual(n)
  Note that this nicely handles varargs, where
  the ellipsis maps to largno.
@
text
@d125 3
d269 4
a272 2
LocSet * TCAstate::csp_locset = 0;
bool TCAstate::csp_readwrite = false;
d827 40
a866 1
bool TCAstate::collectStartingPoints(PgmExpr& pe)
d868 63
a930 9
  if(TCAstate::csp_locset){
    if(pe.getKind() == PgmExpr::fVerify){
      PExprVerify& pev = (PExprVerify&) pe;
      if((pev.getVpKind() == PExprVerify::vpPtrW) ||
	(TCAstate::csp_readwrite && (pev.getVpKind() == PExprVerify::vpPtr))){
        suco_iterator<AO *> aoi(pev.getDesc().getAffAOs());
        while(aoi.Iterate()){
          if(aoi.Current()->getTSC() >= AO::TSC_EXPOSED){	//- tracked or safe
            TCAstate::csp_locset->Insert(*aoi.Current());
d935 10
a944 2
    return true; //- continue traversal
  } else return false;
d954 2
a955 10
      //  1. Collect starting points: vptr/vptrw'ed aos that are safe
      LocSet mbuchk_locs;
      TCAstate::csp_locset = &mbuchk_locs;
      TCAstate::csp_readwrite = readwrite;
      suco_iterator<CFGfunction *> cfi(cfg.getFunctionList());
      while(cfi.Iterate()){
        suco_iterator<PgmStmt *> psi(cfi.Current()->getStmtList());
        while(psi.Iterate()){
          psi.Current()->traverseRootNodes(TCAstate::collectStartingPoints);
        }
a956 30
      TCAstate::csp_locset = 0;

      //  2. Follow assignment edges
      //Currently: not the most efficient way, but it works. TODO: better traversal strategy
      TCstats::timer("collect MBU relevant locset");
      suco_set<TCassignEdge *> aes;
      aes.InsertList(this->assigns);
      aes.InsertList(this->arg_ret_assigns);
      bool changed;
      do {
/**/fprintf(stderr, "MBU relevant locset size = %d, aes size = %d...\n", mbuchk_locs.numAOs(), aes.Length());
        changed = false;
        suco_iterator<TCassignEdge *> ai(aes);
        while(ai.Iterate()){
          if(mbuchk_locs.Intersects(ai.Current()->getTo().getECR().getAliasECRs())){
            suco_iterator<ECR *> ei(ai.Current()->getFrom().getECR().getAliasECRs());
            while(ei.Iterate()){
              suco_iterator<AO *> aoi(ei.Current()->getAOset());
              while(aoi.Iterate()){
                if(aoi.Current()->getTSC() >= AO::TSC_EXPOSED){	//- tracked or safe
                  changed |= mbuchk_locs.Insert(*aoi.Current());
                }
              }
            }
            ai.DeleteCurrent(); //- already handled; need not revisit (minor optimization)
          }
        }
      } while(changed);
      TCstats::timer(0);

d1494 2
d1650 4
d1846 1
@


1.156
log
@Changed AO/ECR relationship: added AO::getECR() function
that is to be called after pt-analysis finalization of
ECRs -- so, PRIOR to finalization, must use ECR::getECR()
(as is now done in pta.cpp), but AFTER, must only use
AO::getECR() which outputs a fatal error message if ECR
not found.
@
text
@d729 1
a729 1
      if(fao){
d731 1
a731 1
        suco_iterator<ECR *> ei(fao->get_AOArg(1).getECR().getPointsTo().getAliasECRs());
d736 1
a736 1
      } else fprintf(stderr, "WARNING (-ptr-heap): Free Function-AO Not Found\n");
@


1.155
log
@Added routines to "finalize" ecrset after pt-analysis:
- added new factory method to keep the set of all
  allocated ECRs, to allow garbage collection when
  "finalizing";
- finalizers are called in tca.cpp:supplementalPTanalysis.
In tca.cpp: started adding code to compute filter set
for ptr-MBU analysis -- current version is very slow.
@
text
@d275 1
a275 1
  ECR& e = ECR::getECR(ao);
d335 2
a336 2
  ECR& fromECR = ECR::getECR(edge.getFrom());
  ECR& toECR = ECR::getECR(edge.getTo());
d391 1
a391 1
	  ECR::getECR(ao).getPointsTo().markInvalid(true);
d411 1
a411 1
	  ECR::getECR(ao).getPointsTo().markInvalid(true);
d416 1
a416 1
	    ECR::getECR(ao).getPointsTo().markInvalid(true);
d599 1
a599 1
  ECR& ecr = ECR::getECR(ao);
d630 1
a630 1
  ECR& ecr = ECR::getECR(ao);
d645 1
a645 1
  ECR& ecr = ECR::getECR(ao);
d660 1
a660 1
  ECR& ecr = ECR::getECR(ao);
d679 1
a679 1
  ECR& ecr = ECR::getECR(ao);
d708 1
a708 1
    ECR::getECR(ao).markInvalid(false);
d731 1
a731 1
        suco_iterator<ECR *> ei(ECR::getECR(fao->get_AOArg(1)).getPointsTo().getAliasECRs());
d873 2
a874 2
          if(mbuchk_locs.Intersects(ECR::getECR(ai.Current()->getTo()).getAliasECRs())){
            suco_iterator<ECR *> ei(ECR::getECR(ai.Current()->getFrom()).getAliasECRs());
d1072 1
a1072 1
    traverseAOs(AO::assignEcrNos);
d1137 2
a1138 2
                suco_iterator<ECR *> ei((getpointsto) ? ECR::getECR(fao).getPointsTo().getAliasECRs()
						      : ECR::getECR(fao).getAliasECRs()
d1209 1
a1209 1
    suco_iterator<ECR *> ei(ECR::getECR(ao).getAliasECRs());
@


1.154
log
@Added -calltrace= option.
@
text
@d266 2
d465 8
d822 19
d843 1
a843 1
  if(flag_redundant | flag_range){
d845 62
@


1.153
log
@Added -callgraph/-callgraph-dot support to output
callgraph in tree form or in dot format.
Unfortunately, both formats are likely to be too
long to be useful for all but small programs.
@
text
@d1133 1
a1133 1
void TCAstate::writeCallgraph(FILE * outf, bool dot)
d1135 1
a1135 1
  cfg.writeCallgraph(outf, dot);
d1263 1
d1274 2
d1372 3
d1651 1
a1651 1
	    state.writeCallgraph(outf, callgraph_dot);
@


1.152
log
@Augmented longjmp check to check also
exec*, system, popen.
@
text
@d1133 5
d1258 1
a1258 1
  enum { tcm_pta, tcm_ptr, tcm_ptrw, tcm_full } mode = tcm_full;
d1262 1
d1271 2
d1324 1
a1324 1
			   "    [-no]-gref    compute GREF and filter at callsites (default=on)\n"
d1326 1
a1326 1
			   "     -wlmode[012] } worklist traversal mode (default = leaf):\n"
d1331 1
a1331 1
			   "                  worklist initialize topological order (default=topo)\n"
d1340 3
a1342 3
			   "    [-no]-fixnargs  Precompute max number of function args (default=on)\n"
			   "    [-no]-cde-incl  Cycle detection/elimination: incl-to (default=on)\n"
			   "    [-no]-cde-pt    Cycle detection/elimination: points-to (default=on)\n"
d1344 1
a1344 1
			   "    [-no]-recycle Recycle of type nodes (on by default)\n"
d1364 5
d1576 1
d1609 1
d1643 3
@


1.151
log
@Changed filter-backedge default behavior:
1. split flag_range_filter_backedge into two flags:
   flag_range_filter_[loop|call]_backedge.
   The former controls intra-procedural ("loop")
   backedges, while the latter controls callgraph
   backedges (from recursion and and "findRemainingBackedges").
2. default behavior now is: loop=yes but call=no.
@
text
@d928 22
d994 1
a994 1
  //- B. traverse argument to .longjmp, ._longjmp, .siglongjmp
d1017 2
a1018 4
            if((!strcmp(fid.getname(),".longjmp"))
		|| (!strcmp(fid.getname(),"._longjmp"))
		|| (!strcmp(fid.getname(),".siglongjmp"))){
              //-- found an argument to longjmp
d1021 1
a1021 1
                fprintf(outf, "# longjmp(");
d1027 2
a1028 1
                //  tracked-ness status of setjmp buffers.
d1045 1
a1045 1
                } else fprintf(stderr, "ERROR(writeTSoutput): longjmp argument static type unknown\n");
d1053 5
a1057 2
			aoi.Current()->getKind() != AO::aoStringLit){ //- filter out string literals!?
                      fprintf(outf, "#  ljmp(%c/%c): ",
@


1.150
log
@Added [-no]-inst-fields option to turn off
instantiation of all struct/union member AOs
at declaration point.
Originally did this to circumvent explosion in
mesa which has some huge structures -- but as
I think about it, leaving this feature off by
default should still get correct results!?!
@
text
@d76 5
a80 1
bool flag_range_filter_backedge = true;
d1280 4
a1283 2
			   "      -ran[-no]-filter-backedge\n"
			   "                  compute backedge filter? (default=yes)\n"
d1414 8
a1421 4
      } else if(!strcmp(argv[i], "-ran-filter-backedge")){
        flag_range_filter_backedge = true;
      } else if(!strcmp(argv[i], "-ran-no-filter-backedge")){
        flag_range_filter_backedge = false;
d1585 1
a1585 1
        fprintf(outf, " -range-%s (filter-backedge=%s)(widen %s)",
d1587 2
a1588 1
			(flag_range_filter_backedge)?"yes":"no",
d1646 2
a1647 1
    WRITE_FLAG_VALUE(flag_range_filter_backedge);
@


1.149
log
@Augmented RAN counters to count both "all" and "array"
versions of all four categories: all-vps, finite, half-finite,
inbounds.
@
text
@d118 3
d1294 2
d1436 4
d1619 1
@


1.148
log
@Added comments.
@
text
@d863 10
a872 4
          this->ran_num_all_vps = rcfh.countAllVPs();
          this->ran_num_finite_vps = rcfh.countFiniteVPs();
          this->ran_num_half_finite_vps = rcfh.countHalfFiniteVPs();
          this->ran_num_inbounds_vps = rcfh.countInboundsVPs();
a873 2
          this->ran_num_all_array_vps = rcfh.countAllArrayVPs();
          this->ran_num_inbounds_array_vps = rcfh.countInboundsArrayVPs();
a1056 1
      fprintf(outf, "# RAN-count vps-all-array = %d\n", this->ran_num_all_array_vps);
d1060 4
a1063 1
      fprintf(outf, "# RAN-count vps-inbounds-array = %d\n", this->ran_num_inbounds_array_vps);
@


1.147
log
@Added flag_range_exact_sizes to assume exact sizes
when doing type-mismatch transformations.
@
text
@d81 1
a81 1
//- range analysis: representation choices:
d84 1
a84 1
bool flag_range_do_sliding = true;	// true: allow sliding
d87 12
@


1.146
log
@Added mechanism to report static RAN-count of
direct-array accesses (all, and in-bounds only).
Entailed adding AO::isDirectArrayAccess() helper
funciton; a couple of counting helpers in
RANcFactHandler, and a place to store the
results in TCAstate.
@
text
@d86 1
d1247 2
d1359 4
d1603 1
@


1.145
log
@Added flag_range_handle_predicates to control whether
or not to try to improve ranges for predicates.

Predicate handling (cond_intersect) updated so that
two non-aliasing-loc -targeted ranges can set to top
only if they're both in-bounds.

Known-predicate stat-counter now only counts STMT and
QC predicates -- previously was double counting &&/||
predicates within a STMT predicate.
*NOTE*: the current flow-sensitive representation for
predicates are _BROKEN_ -- they're ad-hoc (OK for
redundant checks?), and don't look entirely correct
for RAN analysis evaluation!  Try e.g. (i++>0).
@
text
@d855 2
d1040 1
d1044 1
@


1.144
log
@Collecting RAN stats (all-vps, finite-vps, half-finite-vps, inbounds-vps,
known-preds):
 - RAN replaced checkInBounds() with getDerefRangeFor()
 - added reportKnownPredicate() helper to RAN[c]factHandler
 - added list accumulators to RANcFactHandler
 - added count holders to TCAstate

Interval::isTop() - now returns true of min > max!
(was returning only if min = +inf, max = -inf!)

Interval: added "modulo" to compute %.

AO::get_AOUDot/get_AOSDot() - unify ecr if called after pt-analysis.
@
text
@d85 1
d1240 2
d1348 4
d1591 1
@


1.143
log
@OVERHAUL: removed flag_range_target_aos, replaced with
 - flag_range_must_have_ao: do we support ao=bottom?
 - flag_ty_can_change: must interval's ty equal loc's ty?
 - flag_range_do_sliding: allow sliding transformation?
Changed command-line flags: -ran-DO, -ran-LO should be
the default ones to use, while the above flags can be
individually manipulated for data collection.

CHANGED Interval::adjustStructOffset to also change the
ao target (if possible; currently doesn't handle array-of
structs correctly sometimes).

CHANGED Interval::adjustTypes to support the full type
assumptions (incl |char|<=|short|<=|int|...).  This is
actually implemented in TCtype::countInstancesOf.
This resulted in greatly-streamlined code.

CHANGED Interval::cond_intersect to allow intersection
to go to Top in cases when we know the two sides don't
intersect.
@
text
@d86 3
d848 7
d1035 7
d1202 1
d1251 2
d1363 4
d1449 5
a1453 1

@


1.142
log
@Changed AO::write_string_rep and write_list_string_rep
to take a "readable" flag.
So now, flag_readable_output only affects the parts intended
for machine-reading by sml; the other auxiliary output
(e.g. via debug_dump, or for longjmp targets) will be
always readable.
@
text
@d81 4
a84 2
//- range analysis: interval with ao or elty
bool flag_range_target_aos = false;
d1212 1
a1212 1
			   "     -ran-intra/-ran-inter\n"
d1214 7
a1220 2
			   "      -ran-tgt[-elty|-ao]\n"
			   "                  interval target mode (default=elty)\n"
d1305 20
a1324 4
      } else if(!strcmp(argv[i],"-ran-tgt-elty")){
	flag_range_target_aos = false;
      } else if(!strcmp(argv[i],"-ran-tgt-ao")){
	flag_range_target_aos = true;
d1553 3
a1555 1
    WRITE_FLAG_VALUE(flag_range_target_aos);
@


1.141
log
@Added comment output to diagnose tracked-ness of
longjmp buffers.
@
text
@d952 1
a952 1
                fao.write_string_rep(outf);
d963 1
a963 1
                fao.write_string_rep(outf);
d997 1
a997 1
                      aoi.Current()->write_string_rep(outf);
d1041 1
a1041 1
    ao.write_string_rep(AO::aoWriteStream);
d1047 1
a1047 1
    AO::write_list_string_rep(AO::aoWriteStream, alias_aos);
d1084 1
a1084 1
    ai.Current()->getTo().write_string_rep(outf);
d1086 1
a1086 1
    ai.Current()->getFrom().write_string_rep(outf);
d1094 1
a1094 1
    arai.Current()->getTo().write_string_rep(outf);
d1096 1
a1096 1
    arai.Current()->getFrom().write_string_rep(outf);
@


1.140
log
@Added support for AO-targeted intervals:
 - global flag_range_target_aos
 - command line flags -ran-tgt-ao -ran-tgt-elty (default)
 - new ao member of Interval class
 - changed interval.cpp code to support ao-targeted mode,
   including code for ptrs_minus and precise handling
   of targeted intervals in predicates (cond_intersect()).
@
text
@d929 7
a935 3
  //- traverse arguments to free()
  //  check to see if points-to target is all tracked,
  //  all untracked, or a mix
d954 48
@


1.139
log
@Changed -full flag to -nt.
@
text
@d81 3
d1160 2
d1246 4
d1478 1
@


1.138
log
@Looks like I already had a flag to indicate whether strlit
should be writable (it was used only for the TRACKED-computation
phase).
I've eliminated the extra runtime arguments, and renamed the
flag to make it more global.
@
text
@a1133 1
			   "     -full        full type-safety analysis (default action)\n"
d1135 1
d1213 1
a1213 1
      } else if(!strcmp(argv[i],"-full")){
d1405 1
a1405 1
        case tcm_full: fprintf(outf, "# Full Type-Safty Analysis%s\n", ata); break;
@


1.137
log
@Added support for treating StringLits as read-only in RAN analysis.
 - commandline flag -ran-strlit-[readonly|readwrite];
   global flag flag_range_strlit_readonly
 - in Interval, added boolean tgt_readonly;
   updated each Interval function to properly propagate it
 - added readwrite argument to Interval::inBounds() and
   RANfact::checkInBounds().
Also, while updating Interval functions:
 - fixed some hidden but significant bugs in implementation:
   a typo in Plus; rudimentary overflow detection for
   Multiply;...
@
text
@d40 6
a45 2
//- mark stringlit as invalid: this is currently turned on by default in -ptrw mode
bool flag_mark_stringlit_invalid = false;
a80 3
//- range analysis: treat string literals as read-only
bool flag_range_strlit_readonly = true;

d383 1
a383 1
	  if(flag_mark_stringlit_invalid
a1168 2
			   "      -ran-strlit-[readonly|readwrite]\n"
			   "                  are string literals writable? (default=readonly)\n"
a1199 1
  bool local_strlit_writable = false;
d1220 1
a1220 1
        local_strlit_writable = true;
a1258 4
      } else if(!strcmp(argv[i], "-ran-strlit-readonly")){
	flag_range_strlit_readonly = true;
      } else if(!strcmp(argv[i], "-ran-strlit-readwrite")){
	flag_range_strlit_readonly = false;
d1339 1
a1339 1
    flag_mark_stringlit_invalid = !local_strlit_writable;
d1474 1
a1474 1
    WRITE_FLAG_VALUE(flag_range_strlit_readonly);
@


1.136
log
@CHANGE 1: wrote ECR::getAliasECRs(), which collects and
  caches an ecrset of alias ECRs.
  This function replaces the functionality of
  collectAliasECRs(), but should only be called after
  the points-to graph is finalized.
CHANGE 2: changed RAN and REDp to account for MayFree
  set (CFGfunction::getGFreeHeap()).
  For RAN, this affected: filterCallsiteFact,
  intraProcHandleCall, and handleFreeCall (previously
  empty).
  For RED, this affected only REDp::intraProcHandleCall.
  For CFGfunction: added gfreeheap_ecrs/getGFreeHeapEcrs()
  to cache the freeheap ecrset for use in the above
  phases.
@
text
@d77 3
d1168 2
d1261 4
d1480 1
@


1.135
log
@Added -unsafe-derefs flag, to do "tracked-only" analysis
(i.e., all derefs are treated as unsafe).
@
text
@d398 1
a398 1
    ECR::getECR(fpao).collectAliasECRs(alias_ecrs);
d688 1
a688 3
        suco_set<ECR *> ecrset;
        ECR::getECR(fao->get_AOArg(1)).getPointsTo().collectAliasECRs(ecrset);
        suco_iterator<ECR *> ei(ecrset);
a983 2
    suco_set<ECR *> alias_ecrs;
    ECR::getECR(ao).collectAliasECRs(alias_ecrs);
d985 1
a985 1
    suco_iterator<ECR *> ei(alias_ecrs);
@


1.134
log
@1. Changed AOMalloc representation to include <eltype, numelts>
   (previously had single <size> field)
2. Changed Interval to store <eltype, numelts> rather than AO
   as "target" field: potentially allows for "smarter" range
   analysis per Susan's suggestion.
(Added runtime flag -ran-[no-]malloc to turn on/off handling
 of malloc objects, now on by default)
TODO: account for elty in Interval::plus/minus (added signature,
      but not yet implemented)
@
text
@d25 3
d585 30
d711 5
d894 1
a894 1
  fprintf(outf, "# %s\n", (tsl)?"(addr-taken TSLs)":"(flow-insens TSCs)");
d1141 1
d1222 2
d1365 2
a1366 1
        state.invalidPtrAnalysis(mode == tcm_ptr);
@


1.133
log
@Changed flag_range_zero_special to be true by default.
@
text
@d74 3
d1126 2
d1211 4
d1433 1
@


1.132
log
@Added -ran-inter support: only started implementing
(not complete - don't run yet).
@
text
@d72 1
a72 1
bool flag_range_zero_special = false;
d1124 1
a1124 1
			   "                  treat zero specially (default=no)\n"
@


1.131
log
@Augmented -summary output to include assign edges.
(Debugging purposes only)
@
text
@d58 3
d780 1
a780 1
        RAN ranw(RANfactHandler::handler, RAN::WN_WIDEN, flag_range_widen_always);
d787 1
a787 1
        RAN rann(RANfactHandler::handler, RAN::WN_NARROW, flag_range_narrow_always);
d1113 2
d1186 6
d1368 2
a1369 1
        fprintf(outf, " -range (filter-backedge=%s)(widen %s)",
d1418 1
@


1.130
log
@Added -ran-zero-special: range analysis treats "zero" as
a special value, so allows tracking of intervals of the
form {0} U &ptr + [m,n].
Flag is off by default; must be turned on explicitly.
@
text
@d980 21
@


1.129
log
@Changed default state of backedge-filter to "yes".
@
text
@d68 3
d1097 2
d1174 4
d1389 1
@


1.128
log
@1. SUCO UPDATE: added copy constructor to suco_iterator,
   that sets the "list" pointer to the current pointer
   (this feature will be used in collecting backedge
   filter).
2. compute backedge filters: reshuffled interface, and
   wrote some preliminary untested code!
   The old version tried to recursively walk the cfg;
   the new one just walks the sequential list of nodes.
   Also added command line flag (-ran-[no-]filter-backedge).
TODO: fix high level bug that only handles true-false
edges differently when the predicate node gives a pair
of facts.
@
text
@d66 1
a66 1
bool flag_range_filter_backedge = false;
d1085 1
a1085 1
			   "     -range       do range analysis (-ptr/-ptrw only; NOT YET IMPL)\n"
d1093 1
a1093 1
			   "                  compute backedge filter? (default=no)\n"
@


1.127
log
@Modified behavior: in -ptrw mode, string literals are now invalid,
since they aren't writable on some platforms;
Added flag -strlit-writable to enable reversion to old behavior.
@
text
@d65 3
d1087 1
a1087 2
			   "                  range analysis: widen always or only on backedge\n"
			   "                  (default=backedge)\n"
d1092 2
d1169 4
d1327 3
a1329 1
        fprintf(outf, " -range (widen %s)", (flag_range_widen_always)?"always":"on backedge");
d1379 1
@


1.126
log
@1. Adjustment to "_" (untouched exposed aos) behavior: reports only
   one status, rather than a separate status for ptr/ptrw as was done
   before.  This is because the tsl analysis is already dependent on
   ptr/ptrw-ness, so it makes no sense to report both when doing one
   particular analysis.
   Involved change to ECR class definition (used to have two booleans
   touched_ptr/touched_ptrw; now just one).

2. Updated "/" (freearg) to account for untouched-ness: by adding
   a flag to AO::pointsToExposed/ECR::inclToExposed saying whether
   or not to check the touched flag.
@
text
@d37 3
d363 6
d1069 1
d1121 1
d1141 2
d1238 4
@


1.125
log
@1. Added code to find untouched exposed locations (so they
   can be unexposed/untracked):
   - in ECR, added members touched_ptr, touched_ptrw
   - in RANc(FactHandler), for each Verify, touch the
     affected ECRs
   - at the end, traverse all AOs, and for each EXPOSED
     ao that's untouched, output a "_ [T|U] [T|U] <O>"
     line (T=touched, U=untouched; 1st=ptr, 2nd=ptrw).
   - (sml code has concurrently been modified to read
     those lines and treat <O> as SAFE when untouched)
2. Behavioral change: -cde-incl and -cde-pt are now
   on by default!
@
text
@d775 1
a775 1
        RANcFactHandler rcfh(this->ran_results);
d882 2
a883 2
                else fprintf(outf, "/ %c %c ",  AO::exposedCode(fao.pointsToExposed(false)),
						AO::exposedCode(fao.pointsToExposed(true)));
@


1.124
log
@Minor assertion fprintf added.
@
text
@d65 5
a69 2
bool flag_collapse_inclto_cycle = false;
bool flag_collapse_ptsto_cycle = false;
d913 7
d1097 2
a1098 2
			   "    [-no]-cde-incl  Cycle detection/elimination: incl-to (default=off)\n"
			   "    [-no]-cde-pt    Cycle detection/elimination: points-to (default=off)\n"
@


1.123
log
@Added implementation of cycle detection and elimination
of points-to cycles (had previously only implemented
for includes-to cycles).
CAVEAT: it's unclear whether the two algorithms will
clash; am now testing.
@
text
@d417 4
a420 2
    suco_set<AO *>& laos = lecr->getAOset();
    suco_set<AO *>& raos = recr->getAOset();
@


1.122
log
@Tiny change: output timer info for collecting phase also.
@
text
@d63 2
d66 1
a66 1
bool flag_collapse_ptsto_cycle = false; //- (not yet implemented)
d1086 1
a1086 1
			   "    [-no]-cde-pt    Cycle detection/elimination: points-to (NOT IMPLEMENTED)\n"
@


1.121
log
@Removed redundant code:
 Earlier, there were two different versions of addReturnNodeAliases,
 with the old one involving an extra helper function.
 The new version was written but not thoroughly tested;
 it's now been "reasonably" tested, so I've deleted the old
 version.
@
text
@d767 1
a767 1
        if(flag_verbose) TCstats::timer("collecting range-analysis results");
d771 1
a771 1
        if(flag_verbose) TCstats::timer(0);
@


1.120
log
@Major update: implemeted narrowing.
Some restructuring: previously had different classes
RAN/RANnarrow/RANwiden; have consolidated them with
a flag indicating which mode the analysis will run in
(meet/narrow/widen; the first not currently used).
Also added runtime flags to turn on/off narrowing
phase, and also to control whether widen/narrow
is done always or on backedge only (previous implementation
was equivalent to one widen pass plus one meet pass;
current default is one widen(backedge) pass plus one
narrow(always) pass).
Note that the narrowing code is currently full of
debug printfs -- cases that shouldn't(?) occur.
@
text
@a362 11
AO * TCAstate::afr_ao = 0;

bool TCAstate::aliasFnReturns(AO& ao)
{
  if(afr_ao && ao.getKind() == AO::aoFunction){
    AO& ret = ((AOFunction &)ao).getTarget().get_AOReturn();
    ECR::getECR(*afr_ao).includesTo(ECR::getECR(ret));
  }
  return true;
}

a365 1
/**/if(flag_collapse_inclto_cycle){ /**/ //- new version
a380 5
/**/} else { /**/ //-old version
    AO& fpao = ((AOReturn&)ao).getParent();
    TCAstate::afr_ao = &ao;
    ECR::getECR(fpao).traverseAliases(TCAstate::aliasFnReturns); //- collect into cfr_aoset
/**/}
@


1.119
log
@Added interface skeleton for doing the bounds-check phase,
including:
  Interval::inBounds
  RANfact::checkInBounds
  RANfact::evalAddrRange (needed by both checkInBounds
                          and evalSubexpr/addrof case)
and changed RANc result type from a REDresult to a
list of PExprVerify's.
Next need to fill in, mainly evalAddrRange, but must
think of strategy to store object sizes.
@
text
@d55 7
d771 2
a772 1
        RANwiden ranw(RANfactHandler::handler);
d775 5
a779 3
      }{
        TCstats::timer("range analysis - narrowing");
        RANnarrow rann(RANfactHandler::handler);
d782 2
a783 1
      }{
d1076 7
d1141 14
d1304 4
a1307 1
      if(flag_range) fprintf(outf, " -range");
d1345 1
d1351 4
@


1.118
log
@Added -wli-topo/-wli-depth, which signals whether to
initialize the worklist in "breadth-first" order or
depth-first order. Previously, defaulted to depth-first,
but with widening, this is not a good initial scheme!
The "topo"/"breadth-first" order uses the traversal_id
computed for "leaf-first" traversal -- seems to do the
desirable thing.
Implementation (in dfa.h/dfa.cpp) is somewhat hackish
with respect to Worklist class and its set/list members,
so beware!.
@
text
@d906 5
a910 1
    this->ran_results.writeResults(outf);
d1021 6
a1026 1
    this->ran_results.debug_dump(outf);
@


1.117
log
@1. Added code (to CFG::assignId) to mark backedges in
   the CFG.
   May be buggy -- must test.
2. -MAJOR UPDATE-
   Added ran.cpp/ran.h for range checking.
   Thusfar, ran.cpp contains only empty skeletons to be
   filled in - do not run!
3. Renamed widen_narrow in CFG to is_backedge;
   also, now widen/narrow are specific to RAN/RANfact,
   rather than generic to DFA/DFAfact.
@
text
@d62 3
d1064 2
d1134 4
d1302 1
@


1.116
log
@Replaced malloc calls with new calls.
@
text
@d14 1
d52 3
d724 1
a724 1
  if(flag_redundant){
d727 3
a729 1
    if(readwrite){ //- ptr
d731 10
a740 4
      TCstats::timer("redundant-check (p) analysis");
      RED red(REDpFactHandler::handler);
      red.doAnalysis(cfg);
      TCstats::timer(0);
d742 1
a742 5
      if(flag_verbose) TCstats::timer("collecting redundant-check (p) results");
      REDpcFactHandler rcfh(this->red_results);
      REDc redc(rcfh);
      redc.collectResults(cfg);
      if(flag_verbose) TCstats::timer(0);
d744 4
a747 1
    } else { //- ptrw
d749 7
a755 4
      TCstats::timer("redundant-check (pw) analysis");
      RED red(REDpwFactHandler::handler);
      red.doAnalysis(cfg);
      TCstats::timer(0);
d757 19
a775 5
      if(flag_verbose) TCstats::timer("collecting redundant-check (pw) results");
      REDpwcFactHandler rcfh(this->red_results);
      REDc redc(rcfh);
      redc.collectResults(cfg);
      if(flag_verbose) TCstats::timer(0);
d900 5
d1011 6
d1052 1
d1107 2
d1254 1
@


1.115
log
@Fixed two "remote" bugs:
 1. In -addr mode,
    a. mark Malloc objects as Exposed (was not done before)
    b. mark all free args as "all tracked" to force
       instrumentation
 2. In -heap/-heapstack mode, for the ECR(s) pointed-to by
    free's arg1, not only must they be marked invalid (was
    done before), but exposed as well.  Without this, then
      c = malloc()
      free(c)
    would not have a "deref-for-writing" of c, thus c would
    be safe, and free(c) would not be instrumented, and also
    $malloc will not be exposed.
@
text
@d171 1
a171 1
              filestem = (char *) malloc(i+1);
@


1.114
log
@Gave the code the -Wall treatment: adjusted things to
get rid of warnings:
 - reordered initializers to match declaration order
 - made some destructors virtual (note that for many
   classes with no explicit destructors, I did not
   add explicit virtual destructors, so -Wall warnings
   remain)
 - made some signed/unsigned casts
 - made some pointer/unsigned int casts for printfs
 - filled in unaccounted-for cases in switch statements
@
text
@d21 3
d624 1
d633 4
a636 1
        while(ei.Iterate()) ei.Current()->markInvalid(false); // mark invalid, propagate up incl edges, but don't propagate down derefs
d781 3
d849 3
a851 2
                fprintf(outf, "/ %c %c ", AO::exposedCode(fao.pointsToExposed(false)),
					  AO::exposedCode(fao.pointsToExposed(true)));
a988 1
  bool do_addr_taken = false;
d1048 1
a1048 1
        do_addr_taken = true;
d1154 1
a1154 1
      if(do_addr_taken){
d1173 1
a1173 1
      if(do_addr_taken){
d1193 1
a1193 1
      const char * ata = (do_addr_taken)?" - Address Taken Analysis":"";
d1226 1
a1226 1
	    state.writeTSoutput(outf, (mode == tcm_full) && do_addr_taken);
d1237 1
a1237 1
    WRITE_FLAG_VALUE(do_addr_taken);
@


1.113
log
@Extended -addr flag to do address-taken analysis differently
under ptr/ptrw mode than in tc mode:
 the old version (tc mode) reverts to the old tsl of
  SAFE/UNSAFE: it marks all * and & targets as UNSAFE,
  and propagates them down various edges.
 the new version (ptr/ptrw mode only) marks all & targets
  as TRACKED, all * objects as POSS_INVALID. The code is
  simpler, and I believe achieves the desired effects.
  The only caveat was if we take &s.i, the current instrumentation
  mode will correctly track all of s, even though this
  -addr analysis will only mark s.i as tracked.
@
text
@d218 12
@


1.112
log
@HEAPSTACK UPDATE: enhance -ptr/-ptrw mode to optionally consider
freed-heap and stack locations as "possibly invalid" locations.

Changed input function to recognize new format with
storage-class designator (Auto|Heap|Static);
Added -ptr-heap -ptr-heapstack cmdline flags;
Modified assignTSC* functions to set POSS_INVALID only
on isRef() aos;
Added code to do the heap/heapstack stuff, including
adding two static helper functions (markAutoInvalidId,
markInvalidLocAO);
ECR::markInvalid has been modified to take an argument:
a flag indicating whether or not to propagate the
invalid down dereferences (p invalid =?=> *p invalid):
true for the old stuff (marking what VALUE_int points-to
as invalid, etc), and false for the new heapstack stuff
(marking an auto variable as invalid).
@
text
@d757 1
a757 1
void TCAstate::addrAssignAnalysis()
d759 10
a768 1
  traverseAOs(setAddrofDerefUDotUnsafe);
d962 1
a962 1
  enum { tcm_addr, tcm_pta, tcm_ptr, tcm_ptrw, tcm_full } mode = tcm_full;
d966 1
d1026 1
a1026 1
        mode = tcm_addr;
a1129 10
    case tcm_full:
      TCstats::timer("flow-insensitive TSC analysis");
      state.ptAnalysis();
      state.supplementalPTanalysis();
      state.possTypeAnalysis();
      state.tscAnalysis();
      TCstats::timer(0);
      state.tcFlowSensitiveAnalyses();
      break;

d1132 10
a1141 6
      TCstats::timer("flow-insensitive invalid-ptr analysis");
      state.ptAnalysis();
      state.supplementalPTanalysis();
      state.invalidPtrAnalysis(mode == tcm_ptr);
      TCstats::timer(0);
      state.ptrFlowSensitiveAnalyses(mode == tcm_ptr);
a1148 1
    case tcm_addr:
d1150 12
a1161 1
      state.addrAssignAnalysis();
d1171 1
d1174 2
a1175 3
        case tcm_full: fprintf(outf, "# Full Type-Safty Analysis\n"); break;
        case tcm_ptr:  fprintf(outf, "# Invalid Pointer Analysis\n"); break;
        case tcm_ptrw: fprintf(outf, "# Invalid Pointer (write-only) Analysis\n"); break;
d1178 1
a1178 1
        case tcm_addr: fprintf(outf, "# Address-Taken Analysis\n"); break;
d1204 1
a1204 1
	    state.writeTSoutput(outf, mode == tcm_addr);
d1215 1
@


1.111
log
@Changed TCstats::timer to remember a stack of (up to 10)
timers, which allows more simultaneous timings.
@
text
@d33 3
d106 2
a107 1
            char * cp = &buf[2];
d115 1
a115 1
            ID& aid = aidtab.getID(cp);
d119 2
a120 1
            char * cp = &buf[2];
d128 1
a128 1
            ID& pid = pidtab.getID(cp);
d303 2
a304 2
	  //-- mark ECR invalid, and propagate
	  ECR::getECR(ao).getPointsTo().markInvalid();
d323 2
a324 2
	  //-- mark ECR invalid, and propagate
	  ECR::getECR(ao).getPointsTo().markInvalid();
d519 1
a519 1
  if(ecr.isInvalid()){
d550 1
a550 1
  if(ecr.isInvalid() && ao.isAssigned()){
d569 1
a569 1
  if(ecr.isInvalid()){
d589 12
d607 20
d967 2
d1025 4
d1172 3
d1208 1
@


1.110
log
@Added REDt* REDtp* skeletons; just need to fill in
REDt* bodies.
Note however that there seems to be a logical flaw in REDp*.
@
text
@d1078 1
d1083 1
d1089 1
d1093 1
@


1.109
log
@Further split RED*handler classes to differentiate between
-ptr and -ptrw mode, with the latter inheriting from the former
(with only one change -- w.r.t. handleVerify).
Minimally tested.
@
text
@d648 2
a649 4
/**/fprintf(stderr, "TC/-red: redundant not yet implemented for TC mode\n");
/*
      TCstats::timer("redundant-check analysis");
      RED red(REDtFactHandler::handler);
d653 4
a656 3
      if(flag_verbose) TCstats::timer("collecting redundant-check results");
      REDtc redpc(this->red_results);
      redtc.collectResults(cfg);
a657 1
*/
d667 1
a667 6
    TCstats::timer("redundant-check analysis");
    RED red(readwrite ? (REDpFactHandler::handler)
		      : (REDpwFactHandler::handler)
	   );
    red.doAnalysis(cfg);
    TCstats::timer(0);
d669 6
a674 2
    if(flag_verbose) TCstats::timer("collecting redundant-check results");
    if(readwrite){ //- ptr
d678 2
d681 7
d691 1
a692 1
    if(flag_verbose) TCstats::timer(0);
@


1.108
log
@Major reshuffling (non-final):
1. output of RED realigned to be of one of four classes:
    -ptr all, -ptr write, -tag verify, -tag assign
2. specialized written RED analysis for ptr/ptrw only,
   wrote -ptr pieces though doesn't seem to work.
   TODO: split further between ptr and ptrw modes,
   since these are differentiated anyways by rtca!
@
text
@d664 1
a664 1
void TCAstate::ptrFlowSensitiveAnalyses()
d670 3
a672 1
    RED red(REDpFactHandler::handler);
d677 9
a685 2
    REDpc redpc(this->red_results);
    redpc.collectResults(cfg);
d1084 1
a1084 1
      state.ptrFlowSensitiveAnalyses();
@


1.107
log
@Adjusted -v settings to yield more manageable output
(for intra-proc analysis, don't need as much per-analysis
details as inter-proc analyses, for example).
@
text
@d597 1
a597 1
void TCAstate::flowSensitiveAnalyses()
d648 2
d651 1
a651 1
      RED red;
d656 2
a657 2
      REDc redc(this->red_results);
      redc.collectResults(cfg);
d659 1
d664 17
d1067 1
a1067 1
      state.flowSensitiveAnalyses();
d1075 1
a1075 1
      state.flowSensitiveAnalyses();
@


1.106
log
@Added timer mechanism to output rusage times for various
phases.
(current implementation: only one timer at a time, though).
@
text
@d71 4
a74 1
    fprintf(stderr, "--- processing %s ---\n", filename);
a177 1
    fprintf(stderr, "------ done processing %s\n", filename);
d1030 1
d1034 2
@


1.105
log
@Wrote different version of TCAstate::addReturnNodeAliases
for -cde-incl to prevent clash with includesTo (which may
result in non-terminating recursion, due to sharing of
ECR::traverseTag). Note: cde seems significantly slower --
not sure if due to the cde or to the change in this function.
@
text
@d267 1
a267 1
    if(flag_verbose) fprintf(stderr, "Computing maxnargs...\n");
d269 2
a270 1
    if(flag_verbose) fprintf(stderr, "... done Computing maxnargs = %d\n", ECRargRet::getMaxNargs());
d274 1
a274 1
  if(flag_verbose) fprintf(stderr, "Initializing ECRs...\n");
d280 2
a281 2
  if(flag_verbose) fprintf(stderr, "(pointers)");
  if(flag_verbose) fprintf(stderr, "\n... done Initializing ECRs\n");
d283 1
d285 1
d371 1
a371 1
  if(flag_verbose) fprintf(stderr, "Adding Arg-Ret Assignments ...\n");
d374 2
a375 3
  if(flag_verbose)
    fprintf(stderr, "... done Adding Arg-Ret Assignments (%d argrets processed).\n",
						insertArgRetAssignEdges_doneset.Length());
d379 1
a379 1
  if(flag_verbose) fprintf(stderr, "Adding Return-Node Aliases ...\n");
d381 1
a381 1
  if(flag_verbose) fprintf(stderr, "... done adding Return-Node Aliases.\n");
d483 1
a483 1
  if(flag_verbose) fprintf(stderr, "Initializing possible-type...\n");
d485 1
a485 1
  if(flag_verbose) fprintf(stderr, "\n... done initializing possible-type\n");
d487 1
a487 1
  if(flag_verbose) fprintf(stderr, "Building possible-types constraints...\n");
d494 1
a494 1
  if(flag_verbose) fprintf(stderr, "\n... done building possible-types constraints\n");
d499 1
a499 1
  if(flag_verbose) fprintf(stderr, "Solving possible-type constraints...\n");
d501 1
a501 1
  if(flag_verbose) fprintf(stderr, "... done solving possible-type constraints\n");
d577 1
a577 1
  if(flag_verbose) fprintf(stderr, "Assigning type-safety categories...\n");
d579 1
a579 1
  if(flag_verbose) fprintf(stderr, "... done assigning type-safety categories\n");
d590 1
a590 1
  if(flag_verbose) fprintf(stderr, "Assigning type-safety categories...\n");
d592 1
a592 1
  if(flag_verbose) fprintf(stderr, "... done assigning type-safety categories\n");
d601 1
a601 1
      if(flag_verbose) fprintf(stderr, "Doing reaching-defs analysis...\n");
d604 1
a604 1
      if(flag_verbose) fprintf(stderr, "... done reaching-defs analysis.\n");
d607 2
a608 1
      if(flag_verbose) fprintf(stderr, "Doing may-be-uninit analysis (level %d)...\n", flag_may_be_uninit);
d611 1
a611 1
      if(flag_verbose) fprintf(stderr, "... done may-be-uninit analysis.\n");
d618 1
a618 1
        if(flag_verbose) fprintf(stderr, "Collecting reaching-def/may-be-uninit results...\n");
d620 1
a620 1
        if(flag_verbose) fprintf(stderr, "... done collecting reaching-def/may-be-uninit results.\n");
d627 1
a627 1
        if(flag_verbose) fprintf(stderr, "Collecting may-be-uninit/delta results...\n");
d639 1
a639 1
        if(flag_verbose) fprintf(stderr, "... done collecting may-be-uninit/delta results.\n");
d646 1
a646 1
      if(flag_verbose) fprintf(stderr, "Doing redundant-check analysis...\n");
d649 1
a649 1
      if(flag_verbose) fprintf(stderr, "... done redundant-check analysis.\n");
d651 1
a651 1
      if(flag_verbose) fprintf(stderr, "Collecting redundant-check results...\n");
d654 1
a654 1
      if(flag_verbose) fprintf(stderr, "... done collecting redundant-check results.\n");
@


1.104
log
@Added -cde-incl and -cde-pt flags -- only the latter
has been implemented: in ECR::includesTo, check for
cycle, and collapse these ECRs; also, remove redundant
inclTo/inclFrom edges as a result of the collapse.
Also, the output for -pta mode has been modified to
be more a summary, to allow better comparison between differnet
versions.
@
text
@d338 17
d358 1
d595 2
a596 1
  cfg.prepareCFG();
d598 11
a608 11
  if(flag_reaching_defs){
    if(flag_verbose) fprintf(stderr, "Doing reaching-defs analysis...\n");
    RDA rda;
    rda.doAnalysis(cfg);
    if(flag_verbose) fprintf(stderr, "... done reaching-defs analysis.\n");
  }
  if(flag_may_be_uninit){
    if(flag_verbose) fprintf(stderr, "Doing may-be-uninit analysis (level %d)...\n", flag_may_be_uninit);
    MBU mbu(flag_mbu_inter);
    mbu.doAnalysis(cfg);
    if(flag_verbose) fprintf(stderr, "... done may-be-uninit analysis.\n");
d610 1
a610 1
    if(flag_reaching_defs){ // collect mbu-rda results
d612 2
a613 2
      RDMBfactHandler rmh(this->mbu_results);
      MBUc rdmb(rmh, this->mbu_results, flag_mbu_inter);
d615 3
a617 3
      if(flag_verbose) fprintf(stderr, "Collecting reaching-def/may-be-uninit results...\n");
      rdmb.collectResults(cfg);
      if(flag_verbose) fprintf(stderr, "... done collecting reaching-def/may-be-uninit results.\n");
d619 2
a620 2
      //- for each result index object, propagateExposed on its ecr
      this->mbu_results.markAOsExposed();
d622 1
a622 1
    } else { // collect mbu-delta results
d624 1
a624 1
      if(flag_verbose) fprintf(stderr, "Collecting may-be-uninit/delta results...\n");
d626 4
a629 4
      MBUc1factHandler c1h(this->mbu_results);
      MBUc mbuc1(c1h, this->mbu_results, flag_mbu_inter);
      if(flag_verbose) fprintf(stderr, "(phase 1)");
      mbuc1.collectResults(cfg);
d631 4
a634 4
      MBUc2factHandler c2h(this->mbu_results);
      MBUc mbuc2(c2h, this->mbu_results, flag_mbu_inter);
      if(flag_verbose) fprintf(stderr, "(phase 2)");
      mbuc2.collectResults(cfg);
d636 1
a636 1
      if(flag_verbose) fprintf(stderr, "... done collecting may-be-uninit/delta results.\n");
d638 14
a651 2
      //- for each result index object, propagateExposed on its ecr
      this->mbu_results.markAOsExposed();
a652 11
  }
  if(flag_redundant){
    if(flag_verbose) fprintf(stderr, "Doing redundant-check analysis...\n");
    RED red;
    red.doAnalysis(cfg);
    if(flag_verbose) fprintf(stderr, "... done redundant-check analysis.\n");

    if(flag_verbose) fprintf(stderr, "Collecting redundant-check results...\n");
    REDc redc(this->red_results);
    redc.collectResults(cfg);
    if(flag_verbose) fprintf(stderr, "... done collecting redundant-check results.\n");
@


1.103
log
@Moved markInvalidNodes call from supplementalPTanalysis
to head of possTypeAnalysis -- to mirror markInvalidNodeNonNull
call at head of invalidPtrAnalysis.
Also, added call to flowSensitiveAnalyses in -ptr/-ptrw
cases.
@
text
@d45 4
d748 10
a757 5
    fprintf(AO::aoWriteStream, "---Aliases for ");
    ao.debug_dump(AO::aoWriteStream);
    fprintf(AO::aoWriteStream, ":\n");
    ECR::getECR(ao).traverseAliases(AO::writeAO);
    fprintf(AO::aoWriteStream, "----\n");
d884 2
a885 4
			   "     -gref/-no-gref\n"
			   "                  compute GREF and filter at callsites (on by default)\n"
			   "     -bblocks/-no-bblocks\n"
			   "                  use basic blocks (off by default)\n"
d896 3
a898 2
			   "     -fixnargs,   } turn on/off precomputation of maximum number of\n"
			   "     -no-fixnargs }  function arguments (on by default)\n"
d900 1
a900 2
			   "     -recycle,    } turn on/off recycling of type nodes\n"
			   "     -no-recycle  }  (on by default)\n"
d964 8
d1069 2
d1089 2
@


1.102
log
@Wrote redundant analysis collection function.
Entailed creation of REDresults class and REDcFactHandler, etc.
Resulted in modifying suco_set (olist, actually) to have a
different Contains function that uses the compare function
rather than ==. (Future work: may want to extend to some
other functions).
@
text
@d342 1
a342 2
//   1. insert argRet assignment edges
//   2. mark invalid nodes
a357 3

  //-- mark invalid nodes
  traverseAOs(TCAstate::markInvalidNode);
d455 3
d1010 1
d1012 1
@


1.101
log
@Filled in skeleton of REDundant analysis -- including
CFG nodes' red_fact and red_is_useless members.
TODO: fill in the important meat of the analysis in
handleVerify, handle*Assign, etc.
Also, must write REDc collector.
@
text
@d625 5
a629 1
//TODO: collect
d735 5
d834 6
@


1.100
log
@Added -mbu-intra flag; starting to add intra-procedural
analysis mechanism -- wrote some skeletal setups, but
not done.
Should be only two pieces to write to do MBU intraprocedurally
(I don't think we can/should do RDA intraprocedurally).
@
text
@d42 3
d620 7
d858 1
d909 2
d1028 4
a1031 1
      if(flag_may_be_uninit) fprintf(outf, " -mbu%d", flag_may_be_uninit);
@


1.99
log
@Added informational output to file, summarizing the
flow-sensitive analyses performed in this pass.
@
text
@d36 3
d575 1
d581 1
d588 1
a588 1
      MBUc rdmb(rmh, this->mbu_results);
d602 1
a602 1
      MBUc mbuc1(c1h, this->mbu_results);
d607 1
a607 1
      MBUc mbuc2(c2h, this->mbu_results);
d840 2
a841 2
			   "     -mbu[123]    may-be-uninit analysis level\n"
			   "                  1: full\n"
d845 2
a877 2
  TCAstate state;

d898 6
d961 2
d1045 1
@


1.98
log
@Minor change: -debug now turns on -readable.
@
text
@d991 7
a997 7
        switch(mode){
          case tcm_full: fprintf(outf, "# Full Type-Safty Analysis\n"); break;
          case tcm_ptr:  fprintf(outf, "# Invalid Pointer Analysis\n"); break;
          case tcm_ptrw: fprintf(outf, "# Invalid Pointer (write-only) Analysis\n"); break;
          case tcm_pta:  fprintf(outf, "# Points-To Analysis\n"); break;
          default:
          case tcm_addr: fprintf(outf, "# Address-Taken Analysis\n"); break;
d999 6
@


1.97
log
@Added call to MBUc2 in tca.cpp;
added handler functions for MBUc2 for all but handleReturn case.
That one needs a small overhaul...
@
text
@d852 1
a852 1
			   "     -debug       dump full debug output\n"
d927 1
@


1.96
log
@Removed RDMBc class; replaced by instantiation of
general MBUc class (for collecting may-be-uninit
results in a RDAfact object).
Added MBUc1factHandler class, and skeleton for MBUc2factHandler.
@
text
@d594 2
d598 7
a605 2
      if(flag_verbose) fprintf(stderr, "Collecting may-be-uninit/delta results...\n");
      mbuc1.collectResults(cfg);
d608 2
a609 2
      //-TODO: c2
      //-TODO: propagateExposed? (see above)
@


1.95
log
@Major restructuring:
 1. added DFAfactHandler class to encapsulate functions
    that process a DFAfact based on the CFG node.
    Created a handler for each fact class thusfar
    (MBU, RDA, cMBU->RDMB)
 2. renamed cMBU to RDMB, to represent the pair (RDA,MBU).
    The collection analysis class is now called RDMBc.
    Use this new convention for naming?: end in "c" for
    a "collecting" analysis class (and "a" for "analysis"?)
@
text
@d581 4
d590 13
a602 1
      rdmb.getResults().markAOsExposed();
a603 1
    //- TODO: else collect mbu-delta results
d707 1
a707 1
    rdmb.getResults().writeResults(outf);
d801 1
a801 1
    rdmb.getResults().debug_dump(outf, false);
@


1.94
log
@Added RDAfact::markAOsExposed to traverse mbu results
and mark all "index" AOs (and their aliases) exposed.
@
text
@d582 1
a582 1
      cmbu.collectResults(cfg);
d586 1
a586 1
      cmbu.getResults().markAOsExposed();
d692 1
a692 1
    cmbu.getResults().writeResults(outf);
d786 1
a786 1
    cmbu.getResults().debug_dump(outf, false);
@


1.93
log
@Change of approach: the points-to graph will now contain
include-edges for function return nodes, so that the alias
set of Return(Star(exp)) will include Return(Id(foo)) for
all exp-aliased functions foo.
This negates previous hack approaches (treating function
calls as a special case when handling an assignment RHS),
which have been removed.
NOTE: the addition of the new include edges is done in
tca.cpp (TCAstate); perhaps should migrate to a better
place (pta.cpp?).

Also, cMBU fact-collection now includes non-location objects,
and the result set will include the reaching-defs of aliases.
For example, the cMBU result set might now include
{ *p : defn(i), defn(j) } where i and j are aliases of *p.
This was previously omitted, erroneously.
@
text
@d584 3
@


1.92
log
@Changed behavior so -rda and -mbu are independent;
if both are on, then will collect mbu-rda results;
TODO: else collect mbu-only results (Susan's delta
approach).
@
text
@d311 23
d343 1
a343 1
  traverseAOs(insertArgRetAssignEdges);
d347 7
d355 1
a355 1
  traverseAOs(markInvalidNode);
d383 1
a383 1
                fprintf(stderr, "insertArgRetAssignEdge: no static type, setting to void type, in:\n  ");
@


1.91
log
@Added cMBU class to collect may-be-uninit results (after
running RDA and MBU); new class is in cmbu.cpp.
Appears to be working, though a few open issues remain:
 - lookupNodeFact needs a complement (releaseNodeFact),
   since cMBU returns a new node (though neither MBU
   nor RDA do)
 - mode_iterating/mode_collecting -- should get rid
   of this flag cleanly
 - absorbAndCompare -- should obsolesce this, or migrate
   it to DFA/MBU/RDA
Longer term:
 - RDA should use GMOD, but when collecting, will need
   to refer to GREF.
@
text
@d540 1
a540 1
  if(flag_reaching_defs || flag_may_be_uninit){
d550 6
a555 1
    cmbu.collectResults(cfg);
@


1.90
log
@Major update:
Added -rda (reaching-defs analysis) in new class RDA:DFA.
Basically, copied the meat from MBU, making minimal changes.
Compiles, runs, verified against small examples.
NEED TO REVIEW CODE IN DETAIL, and verify against larger
examples.
Potential problem: seems rather slow, may want to compute
GMOD?
@
text
@d540 1
a540 1
  if(flag_reaching_defs){
d549 2
d654 1
a654 1
    mbu.getResults().writeResults(outf);
d748 1
a748 1
    mbu.getResults().debug_dump(outf);
@


1.89
log
@Removed experimental CFG numbering schemes (in-order DFS, post-order DFS,
successor-wait), sticking with post-order DFS as the only reasonable scheme.
Also, updated certain flag defaults: -leaf and -gref are now on by default.
@
text
@d36 3
d540 5
d778 1
d829 2
d963 1
@


1.88
log
@SIGNIFICANT UPDATE:
 - added -gref flag, to enable GREF filtering
 - added code to first compute IREF for each function,
   then collect them into GREFs
 - this makes use of recursion_id/callgraph_id traversal
   order (verify that this correctly computes GREF with
   complex callgaphs?)
 - the recursion_id/callgraph_id ordering is encoded by
   the function CFGfunction::compareByCallgraphId, which
   has been absorbed into the worklist ordering function,
   so a slight behavior change there as well.
@
text
@d31 1
a31 1
bool flag_gref_filter = false;
d37 1
a37 4
enum wl_mode flag_worklist_mode = WL_MODE_FIFO;

//- cfg numbering mode
enum ct_mode flag_cfg_traverse_mode = CT_MODE_IN_DFS;
d772 5
a776 3
			   "     -gref        compute GREF and filter at callsites\n"
			   "     -bblocks     use basic blocks\n"
			   "     -wlmode[012] } worklist traversal mode (default = fifo):\n"
a779 7
			   "     -indfs/-postdfs/-succlast\n"
			   "                  CFG node numbering (for leaf priority):\n"
			   "                  -indfs: in-order depth-first\n"
			   "                  -postdfs: post-order depth-first\n"
			   "                  -succlast: successor-last\n"
			   "                  NOTE: currently, in & post are equiv (?) and optimal\n"
			   "                        succlast is logically-flawed (inferior)\n"
d792 1
a792 1
			   "     -v[1234]     verbose execution mode (-v == -v2)\n"
a833 6
      } else if(!strcmp(argv[i],"-indfs")){
        flag_cfg_traverse_mode = CT_MODE_IN_DFS;
      } else if(!strcmp(argv[i],"-postdfs")){
        flag_cfg_traverse_mode = CT_MODE_POST_DFS;
      } else if(!strcmp(argv[i],"-succlast")){
        flag_cfg_traverse_mode = CT_MODE_SUCC_WAIT;
d840 2
d858 2
a952 1
    WRITE_FLAG_VALUE(flag_cfg_traverse_mode);
@


1.87
log
@Added flag for different DFA traversal mode (numbering
of CFGnodes in different order).
Currently has:
 1. in-order --> seems the best?
                 (note: is misnomer -- should in fact be post-order)
 2. post-order --> with CFG node ordering, turns out
                   to be equivalent to in-order?
 3. succ-last --> turns out to be logically flawed
                   (suboptimal).
In short -- added much overhead for a debug experiment that failed.
May want to remove succ-last, which numbers them in opposite
priority order -- so we can simplify worklist comparison function.
@
text
@d30 3
d775 1
d868 2
d960 1
@


1.86
log
@Added verbose output of number of aids and pids.
@
text
@d36 3
d777 7
d838 6
d956 1
@


1.85
log
@Fixed minor typo in usage message.
@
text
@d573 4
a576 2
  unsigned int n = aidtab.assignUIDs(1);
  pidtab.assignUIDs(n);
@


1.84
log
@1. Added -ltsize flag which when determining "lowerThan"
   uses the length of the MBUfact set rather than explicit
   comparison; a consequent change is the storing of a
   "num_elts" field to MBUfact, which must be updated
   on each change. This doesn't seem to be a significant
   improvement over the old version of length() which
   traverses the nodelist to count elements.
2. eliminated lowerThan() function, incorporating the
   "lowerThan" check into the meet() function. This
   eliminates a redundancy which speeds things up a bit.
@
text
@d789 1
a789 1
			   "                  4: DFA full trace\n"
@


1.83
log
@1. Added mechanism to output full trace with -v4.
2. Modified trigger counter output mechanism to output
   a full histogram rather than just some stats on the
   max.  Currently implemented as static functions
   within dfa.cpp; should absorb into one of the
   classes?
@
text
@d36 3
d765 1
d769 3
a771 3
			   "     -fifo        } 0: fifo\n"
			   "     -lifo        } 1: lifo\n"
			   "     -leaf        } 2: leaf-first in call-graph\n"
d826 2
d927 15
@


1.82
log
@Added worklist traversal mode (fifo, lifo, leaf-first),
the last sorting the worklist in call-graph leaf-first
order (non-recursive first), and within each function,
sorting by a traversal_id which is a bottom-up numbering
of CFGnodes.
@
text
@d785 1
@


1.81
log
@Changed flag_verbose to be an integer indicating verbose
level: 1 (default) only lists current analysis phase;
2 gives progress dots; 3 supplies other "normal" verbose
information; 4 is for debug stuff.
@
text
@d33 2
a34 2
//- dfa worklist: fifo (queue) or lifo (stack)
bool flag_worklist_fifo = true;
a761 1
			   "     -fifo/-lifo  worklist traversal mode (default: fifo)\n"
d764 4
d780 1
a780 1
			   "     -v[1234]     verbose execution mode\n"
d811 4
d816 1
a816 1
        flag_worklist_fifo = true;
d818 3
a820 1
        flag_worklist_fifo = false;
d846 1
a846 1
			: 1;
@


1.80
log
@Modified main function to cache filenames and process
commandline flags, before opening and reading the files.
@
text
@d21 2
a22 2
//- verbose output
bool flag_verbose = false;
d193 1
a193 1
  if(flag_verbose){
d207 1
a207 1
  if(flag_verbose)
d230 1
a230 1
    if(flag_verbose){
d261 1
a261 1
  if(flag_verbose) fprintf(stderr, "... done Initializing ECRs\n");
d399 1
a399 1
      if(flag_verbose){
d417 1
a417 1
  if(flag_verbose) fprintf(stderr, "... done initializing possible-type\n");
d426 1
a426 1
  if(flag_verbose) fprintf(stderr, "... done building possible-types constraints\n");
d428 1
a428 1
  if(flag_verbose) possTypeConstraintRoots.debug_dump(stderr);
d777 5
a781 1
			   "     -v           verbose execution\n"
d834 4
a837 2
      } else if(!strcmp(argv[i],"-v")){
        flag_verbose = true;
@


1.79
log
@Added -bblocks flag; partially separated bblock and non-bblock
mode of DFA; many bblock components not yet written.
@
text
@a777 1
			   " Note: arguments parsed in order!\n"
d782 2
d836 1
a836 1
      state.processFile(argv[i]);
d839 4
@


1.78
log
@Modified so that prepareCFG is called always, even if -mbu0.
This is so that we can do a -debug dump of the CFG without
doing the DFA analyses.
@
text
@d40 3
d764 1
d809 2
@


1.77
log
@Changed flag_callsite_top to default to true (OK with recursive
fix); changed cmdline argument from -calltop to -callmeet, which
disables that flag (should soon be obsolescent).
@
text
@d843 1
a843 2
      if(flag_may_be_uninit)
        state.flowSensitiveAnalyses();
@


1.76
log
@Wrote basic block mechanism, and routines to construct it.
Currently builds, runs, but not yet used.
Also, consolidated CFG initialization into one function:
CFG:: prepareCFG, called by tca.cpp.
Makefile dependencies updated.
@
text
@d36 3
a38 2
//- dfa: on function call, ignore pre-call facts? (optimistic; unsafe when recursive?)
bool flag_callsite_top = false;
d760 1
a760 1
			   "     -calltop     at non-empty callsites, ignore pre-call facts\n"
d803 2
a804 2
      } else if(!strcmp(argv[i],"-calltop")){
        flag_callsite_top = true;
@


1.75
log
@Changed default to fifo, which turns out to be more efficient
than lifo.
@
text
@d525 1
a525 7
  if(flag_verbose) fprintf(stderr, "Collecting function local variables...\n");
  cfg.collectLocalDecls();
  if(flag_verbose) fprintf(stderr, "... done collecting function local variables\n");

  if(flag_verbose) fprintf(stderr, "Connecting supergraph (call/return assignments)...\n");
  cfg.connectSuperGraph();
  if(flag_verbose) fprintf(stderr, "... done connecting supergraph\n");
@


1.74
log
@Added -calltop flag -- so that for function calls,
the pre-call facts are met into the result of the
calls (by default; -calltop disables this).
@
text
@d34 1
a34 1
bool flag_worklist_fifo = false;
d764 1
a764 1
			   "     -fifo/-lifo  worklist traversal mode (default: lifo)\n"
@


1.73
log
@Changed worklist to a queue/stack, with two execution modes
(fifo/lifo):
 - added command-line flags "fifo" or "lifo"
 - in suco, made stack inherit queue publicly, so a stack
   object can be used as both a stack and a queue
   (an unsafe thing to do?)
 - added a flag in CFGnodes to indicate if a node is in the
   worklist -- should make it faster than checking for
   worklist membership each time, though we have to make
   sure the bookkeeping is correct.
@
text
@d36 3
d765 1
d808 2
@


1.72
log
@Bug Fixes:
 SUCO: fixed tail-assignment in suco_set::Union()
 DFA:  fixed copyFact to union, rather than copy, facts.
 TCA:  added mbu-result output to -debug dump.
@
text
@d33 3
d761 1
d800 4
@


1.71
log
@1. in TCAstate, mbu is now a member -- it stores the results
   to be output later.
2. MBU now contains a result fact, and DFA analysis now
   progresses in two modes: iterating and collecting,
   the latter calling collectResultsVerifyTag(/Ptr)
   to accumulate the results.
3. in cfg.cpp/h, DFAdecl now has filestem_id argument,
   needed for consistent output.
Current state of program: compiles, runs without crashing,
but results are wrong (no output on many examples, suspect
function call handling error?).
@
text
@d722 7
@


1.70
log
@Removed previously commented-out stuff (old aid/aidnos).
Also, moved CFG::writeFileStemMap to AID::writeFileStemMap.
@
text
@a528 1
    MBU mbu;
d632 1
a632 1
//    cfg.writeMBUresults(outf);
@


1.69
log
@Changed CFG nodes' AID member to be of type AID, which
is a pair <filestem_id, aid>; MBUfacts now tracks a set
of (references to) these, so we can have access to the
filestem_id for output.
Old code commented out -- will clear out in next checkin.
@
text
@d631 1
a631 1
  cfg.writeFileStemMap(outf);
@


1.68
log
@Added 4 levels of -mbu, which turns off, in order:
return-value assignments, formal assignments, and
assignment-GENs altogether.
@
text
@d629 6
@


1.67
log
@Suco change (major):
 1. Added new file suco_usage.cpp as a hack to instantiate
    the suco code only once, rather than once-per-file as
    before.
 2. Suco now has node-recycling mechanism in place, which
    seems to help with rtca performance.
@
text
@d742 4
a745 3
			   "                  1: \n"
			   "                  2: \n"
			   "                  3: \n"
@


1.66
log
@Reorganized global flags, stat-collection and output;
moved TCcollectStats to diag.cpp/h, renamed to TCstats,
and absorbed what used to be in diag.cpp/h.
Global flags have been moved to flags.h, (they're defined
in tca.cpp, for now).
Removed the -stat flag: the "stat" output is now always
dumped, to the output file rather than stderr.
Added -mbu# flag, though haven't done anything with the
different mbu levels yet.
@
text
@d789 1
d792 1
@


1.65
log
@Resturctured:
 1. may-be-uninit analysis is now called directly from
    tca.cpp to mbu.doAnalysis, rather than with an intermediate
    cfg.mayBeUninitAnalysis.
 2. updated CFG data structures, so that
    a. each CFG has a unique entry node (with no DFA content,
       so that its facts can be assigned after computing
       global facts). Note that while this node's parent is
       set to main, it doesn't count as main's entry node.
    b. DFAcall nodes now have mbu_facts, and pointers to
       their parents.
 3. in DFA, refined further analysis process, so that all
    that remains to be written are
    a. handleFormal(), which will look up the callsites
       and compute whatever facts are needed, and
    b. fCall case, which needs to handle return values
       as well (may be non-trivial, this one).
@
text
@d6 1
d16 18
d158 3
d527 6
a532 4
  if(flag_verbose) fprintf(stderr, "Doing may-be-uninit analysis...\n");
  MBU mbu;
  mbu.doAnalysis(cfg);
  if(flag_verbose) fprintf(stderr, "... done may-be-uninit analysis.\n");
d576 2
a577 2
  TCcollectStats::doAssigns(outf, assigns);
  traverseAOs(TCcollectStats::doAO);
d581 1
a581 1
  TCcollectStats::print(outf);
a720 273
int TCcollectStats::num_aos = 0,
    TCcollectStats::num_addrof = 0,
    TCcollectStats::num_deref = 0,
    TCcollectStats::num_unsafe = 0,
    TCcollectStats::num_tracked = 0;

int TCcollectStats::num_poss_bottom = 0,
    TCcollectStats::num_poss_scalar = 0,
    TCcollectStats::num_poss_zero = 0,
    TCcollectStats::num_poss_top = 0;

int TCcollectStats::num_safe_ptr = 0,
    TCcollectStats::num_unsafe_ptr = 0,
    TCcollectStats::num_safe_struct_ptr = 0,
    TCcollectStats::num_unsafe_struct_ptr = 0,
    TCcollectStats::num_safe_written_ptr = 0,
    TCcollectStats::num_unsafe_written_ptr = 0,
    TCcollectStats::num_safe_struct_written_ptr = 0,
    TCcollectStats::num_unsafe_struct_written_ptr = 0,
    TCcollectStats::num_safe_fnptr = 0,
    TCcollectStats::num_unsafe_fnptr = 0,
    TCcollectStats::num_safe_struct_fnptr = 0,
    TCcollectStats::num_unsafe_struct_fnptr = 0,
    TCcollectStats::num_tracked_loc = 0,
    TCcollectStats::num_untracked_loc = 0,
    TCcollectStats::num_tracked_fnptr = 0,
    TCcollectStats::num_untracked_fnptr = 0,
    TCcollectStats::num_tracked_struct_fnptr = 0,
    TCcollectStats::num_untracked_struct_fnptr = 0;

void TCcollectStats::doAO(AO& ao)
{
  if(ao.isLib()) return; //- skip library objects

  num_aos++;
  if(ao.getKind() == AO::aoAddrOf) num_addrof++;
  if(ao.getKind() == AO::aoStar) num_deref++;
  switch(ao.getTScode()){
    case 'U': num_unsafe++; break;
    case 'T': num_tracked++; break;
  }

  switch(ECR::getECR(ao).possType().getKind()){
    case TClatType::tclBottom:
	 num_poss_bottom++; break;
    case TClatType::tclZero:
	 num_poss_zero++; break;
    case TClatType::tclTop:
	 num_poss_top++; break;
    default: //- scalar type
	 num_poss_scalar++; break;
  }

  switch(ao.getKind()){
    case AO::aoSDot:
    case AO::aoUDot: {
	 //- if ao is a pointer, and it is a direct decendent of an Id,
	 //  then count as pointer declaration
	 AO * dao = ao.find(AO::aoStar);
	 if(dao){ //- this indicates that ao is a pointer (note: static type not set for sdot/udot aos)
	   //- find root container
	   AO * pao = &ao;
	   do {
	     pao = (pao->getKind() == (AO::aoSDot)) ? &((AOSDot *)pao)->getParent()
						    : &((AOUDot *)pao)->getParent();
	   } while(pao->getKind() == AO::aoSDot || pao->getKind() == AO::aoUDot);

	   if(pao->getKind() == AO::aoId){

	     //- identify fnptr by presence of return ao
	     if(dao->find(AO::aoReturn)){
	       //-- count safe/unsafe
	       if(dao->getTSC() == AO::TSC_POSS_INVALID)
	         num_unsafe_struct_fnptr++;
	       else
	         num_safe_struct_fnptr++;
	       //-- count tracked/untracked
	       // NOTE: this count is technically inaccurate in current implementation,
	       //       since any tracked member of a struct will force the whole thing
	       //       to be tracked -- but this should be a measure of "potential" benefit
	       if(ao.getTSC() == AO::TSC_SAFE)
		 num_untracked_struct_fnptr++;
	       else
		 num_tracked_struct_fnptr++;
	     } else { //- non-function pointer
	       //- non-function pointer
	       if(dao->getTSC() == AO::TSC_POSS_INVALID)
	         num_unsafe_struct_ptr++;
	       else
	         num_safe_struct_ptr++;
	       if(dao->isAssigned()){
	         if(dao->getTSC() == AO::TSC_POSS_INVALID)
	           num_unsafe_struct_written_ptr++;
	         else
	           num_safe_struct_written_ptr++;
	       }
	     }
	   }
	 }
      } break;
    case AO::aoId: {
	 //- categorize pointers
	 AO * dao = ao.find(AO::aoStar);
	 if(dao){ //- this indicates that ao is a pointer (note: no need to use static type)
	   if(!ao.find(AO::aoFunction)){
	     //- identify fnptr by presence of return ao
	     if(dao->find(AO::aoReturn)){
	       //-- count safe/unsafe
	       if(dao->getTSC() == AO::TSC_POSS_INVALID)
	         num_unsafe_fnptr++;
	       else
	         num_safe_fnptr++;
	       //-- count tracked/untracked
	       if(ao.getTSC() == AO::TSC_SAFE)
		 num_untracked_fnptr++;
	       else
		 num_tracked_fnptr++;
	       break; // function pointer: don't fallthrough!
	     } else { //- non-function pointer
	       //- non-function pointer
	       if(dao->getTSC() == AO::TSC_POSS_INVALID)
	         num_unsafe_ptr++;
	       else
	         num_safe_ptr++;
	       if(dao->isAssigned()){
	         if(dao->getTSC() == AO::TSC_POSS_INVALID)
	           num_unsafe_written_ptr++;
	         else
	           num_safe_written_ptr++;
	       }
	     }
	   } else { // regular function: don't fallthrough!
	     break;
	   }
	 }
      } // fallthrough (if id is not function or function pointer)
    case AO::aoStringLit:
    case AO::aoMalloc: { // count tracked/untracked locations
	 if(ao.getTSC() == AO::TSC_SAFE)
	   num_untracked_loc++;
	 else
	   num_tracked_loc++;
      }
  }
}

void TCcollectStats::doAssigns(FILE * outf, suco_llist<TCassignEdge *>& assigns)
{
  //------- tabulate per undefined function
  struct entry {
    const char * fnname;
    int literal,
	tracked, untracked,
	pt_tracked, pt_untracked;
    struct entry * next;
  } * list = 0;
  //---------------------------------------
  suco_iterator<TCassignEdge *> aei(assigns);
  while(aei.Iterate()){
    if(aei.Current()->getTo().getKind() == AO::aoArg){
      AOArg& aao = (AOArg&)aei.Current()->getTo();
      if(aao.getParent().getKind() == AO::aoStar){
	AO& tgtao = ((AOStar&)aao.getParent()).getTarget();
	if(tgtao.getKind() == AO::aoId){
	  AOId& idao = (AOId&) tgtao;
	  AOFunction * fao = (AOFunction *) idao.find(AO::aoFunction);
	  if(fao && (!fao->getLargNo() || fao->isLib())){ // id is defined and non-library
	    ID& pid = idao.getPid();
	    const char * fnname = pid.getname();
	    // find entry, or add if not found
	    struct entry ** lp = &list;
	    int cf = 1;
	    while((*lp) && (cf = strcmp((*lp)->fnname, fnname)) < 0)
	      lp = &(*lp)->next;
	    if(cf){ //- entry not found
	      struct entry * tail = *lp;
	      *lp = (struct entry *)malloc(sizeof(struct entry));
	      (*lp)->fnname = fnname;
	      (*lp)->literal = 0;
	      (*lp)->tracked = 0;
	      (*lp)->untracked = 0;
	      (*lp)->pt_tracked = 0;
	      (*lp)->pt_untracked = 0;
	      (*lp)->next = tail;
	    }

	    //- categorize fromAO
	    AO& fromao = aei.Current()->getFrom();
	    if(fromao.isVal()){
	      (*lp)->literal++;
	    } else {
	      //- determine trackedness
	      if(fromao.getTSC() == AO::TSC_SAFE){
	        (*lp)->untracked++;
	      } else {
	        (*lp)->tracked++;
	      }
	      //- determine pointer-target trackedness
	      if(aei.Current()->getType().getKind() == TCtype::tcPointer){
//		if(fromao.hasECR() && ECR::getECR(fromao).pointsToExposed()){
		AO::exposed_status es = fromao.pointsToExposed();
		if(es == AO::esSome || es == AO::esAll){
		  (*lp)->pt_tracked++;
		} else {
		  (*lp)->pt_untracked++;
		}
	      }
	    }
	  } // else function is true fnptr, or implicit (not declared)
	} // else function is not regular fn or fnptr
/**/  } else if(aao.getParent().getKind() == AO::aoId){
/**/    fprintf(stderr, "Assignment into Arg Id _\n");
      }
    }
  }
  //------- print undefined function summary
  struct entry * ep;
  if(list)
    fprintf(outf, "# undef-fns: (tracked/untracked/pt-tracked/pt-untracked/literal)\n");
  for(ep = list; ep; ep = ep->next)
    fprintf(outf, "# undef-fn %s: %d/%d/%d/%d/%d\n",
			ep->fnname, ep->tracked, ep->untracked,
				    ep->pt_tracked, ep->pt_untracked,
				    ep->literal);
}

void TCcollectStats::print(FILE * outf)
{
  fprintf(outf, "# AOs = %d\n"
		"# AddrOf = %d\n"
		"# Deref = %d\n"
		"# Unsafe = %d\n"
		"# Tracked = %d\n"
	, num_aos, num_addrof, num_deref, num_unsafe, num_tracked);
  if(flag_stat){
    fprintf(stderr, "# poss-type bottom = %d\n"
		    "# poss-type scalar = %d\n"
		    "# poss-type zero = %d\n"
		    "# poss-type top = %d\n"
		, num_poss_bottom, num_poss_scalar,
		  num_poss_zero, num_poss_top);
  }
  fprintf(outf, "# safe ptrs = %d\n"
		"# unsafe ptrs = %d\n"
		"# safe ptrs in struct = %d\n"
		"# unsafe ptrs in struct = %d\n"
		"# safe written-ptrs = %d\n"
		"# unsafe written-ptrs = %d\n"
		"# safe written-ptrs in struct = %d\n"
		"# unsafe written-ptrs in struct = %d\n"
		"# safe fnptrs = %d\n"
		"# unsafe fnptrs = %d\n"
		"# safe fnptrs in struct = %d\n"
		"# unsafe fnptrs in struct = %d\n"
		"# tracked locs = %d\n"
		"# untracked locs = %d\n"
		"# tracked fnptrs = %d\n"
		"# untracked fnptrs = %d\n"
		"# tracked fnptrs in struct = %d\n"
		"# untracked fnptrs in struct = %d\n"
	, num_safe_ptr, num_unsafe_ptr,
	  num_safe_struct_ptr, num_unsafe_struct_ptr,
	  num_safe_written_ptr, num_unsafe_written_ptr,
	  num_safe_struct_written_ptr, num_unsafe_struct_written_ptr,
	  num_safe_fnptr, num_unsafe_fnptr,
	  num_safe_struct_fnptr, num_unsafe_struct_fnptr,
	  num_tracked_loc, num_untracked_loc,
	  num_tracked_fnptr, num_untracked_fnptr,
	  num_tracked_struct_fnptr, num_untracked_struct_fnptr);
}

//------------------------------------------------------

a727 1
  bool flow_sensitive = false;
a737 1
			   "                  (not yet implemented; currently --> -ptr)\n"
d740 5
a756 1
			   "     -stat        dump stat (currently, counts recycle)\n"
d778 5
a782 3
        flow_sensitive = true;
      } else if(!strcmp(argv[i],"-stat")){
        flag_stat = true;
d819 1
a819 1
      if(flow_sensitive)
a871 3

  if(flag_stat)
    diag_print_stats(stderr);
@


1.64
log
@CFG: wrote MBUfacts test for intersection between a MBUfact
and an AOset's alias set (done using ECR::traverseAliases).
Cascaded changes to AO/ECR include:
1. AO::ts_categ is now explicitly enumerated to allow >=
   comparison
2. ECR::traverseAliases now takes bool functions, and
   returns a bool, true if all applications return true,
   and false if *any* application returns false (and also
   halts traversal -- this is an optimization for the
   intersection check added: once an intersection is found,
   no further traversal is needed).
@
text
@d12 1
d506 3
a508 2
  cfg.mayBeUninitAnalysis();
  if(flag_verbose) fprintf(stderr, "... done may-be-uninit analysis.n");
@


1.63
log
@1. Added collectLocalDecls/collectLocalVars to collect
   the set of local variables in each function.
2. Readjusted function exit handling so that (a) all exit
   nodes are annotated RETURN, (b) each function is associated
   with a set of exitnodes, rather than a single exitnode,
2a.Each CFGnode now has a pointer to its parent function
2b.Return nodes now handle the AOs that were previously
   not output by tc -assign.
@
text
@d288 1
a288 1
void TCAstate::collectInclToArgRets(ECR& e)
d291 2
a292 3
  if(ear){
    collectInclToArgRets_ECRs.Insert(ear);
  }
@


1.62
log
@Added initial framework for flow-sensitive stuff in tca.cpp/h.
Wrote functions to connect call/return nodes to function nodes
to create supergraph.
Minor change in id.cpp/h: get_AOId returns reference to AOId
rather than AO object; similarly for get_AOStringLit/get_AOMalloc.
@
text
@d497 4
@


1.61
log
@Reduced scope of AOlist class: this is only to be used
specially within the AO tree to look up AOs.
All other occurrences (in ecr, cfg, etc) have been converted
to use suco_set<AO *>.
Should be no change in behavior.
@
text
@d495 11
d968 1
a968 1
  enum { tcm_addr, tcm_pta, tcm_ptr, tcm_ptrw, tcm_full } mode = tcm_addr;
d972 1
d978 2
a979 1
			   "     -addr        address-taken analysis (default action)\n"
d984 3
a986 1
			   "     -full        full flow-insensitive analysis\n"
d1019 2
d1059 2
@


1.60
log
@Augmented cfg DFfacts with references to AOs;
the respective read functions call AO::stringToAOs,
which requires the pidmap and aidmap arguments from tca,
so a new class InputState was created (in tca.h) to
pass these around conveniently.
Also, added another helper function AO::stringToAOlist
to read in lists of AOs, separated by ',', terminated by
'.'.
@
text
@d299 6
a304 6
    AOlist& laol = lecr->getAOlist();
    AOlist& raol = recr->getAOlist();
    if(!laol.isEmpty() && !raol.isEmpty()){
      AOlistIterator li(laol); //-- note: laol may contain more than one member: due to unification?
      while(li.iterate()){
        AO& lao = *li.current();
d306 3
a308 3
          AOlistIterator ri(raol); //-- note: raol may contain more than one member: due to unification?
          while(ri.iterate()){
            AO& rao = *ri.current();
@


1.59
log
@Incorporated cfg.cpp/cfg.h into rtca project.
Modified DFfacts to be abstract, and have many children;
CFGfunction now stores a "filestem" argument;
tca -debug mode now dumps the CFG as well;
currently cfg input reads aid and other integral arguments
of DFfacts; yet to do: read in AO arguments.
@
text
@d26 1
d115 1
a115 1
	    cfg.read(inf, buf, filestem);
@


1.58
log
@In computing freearg status, we now ignode Value objects.
@
text
@d11 1
d105 11
d666 2
a667 1
  fprintf(outf, "---Dumping ECRs/Points-to Graph---\n");
d672 3
@


1.57
log
@Added freearg handling: for each assignment to the first
argument of free, check to see if the argument points to
none, some, or all exposed objects -- with current implementation
it is sufficient to check the exposed flag of the corresponding
ECR objects (but must still follow inclTo edges).
Note -- attributes for two policies are computed, one considering
all AOs, another considering only Malloc AOs. The latter is unsafe
(but "usually safe", one would hope), but likely more efficient.
Output is "/ A M O" where A is the status for all AOs, M for malloc
AOs only, and O the AO in question.
@
text
@d564 6
a569 4
              fprintf(outf, "/ %c %c ", AO::exposedCode(fao.pointsToExposed(false)),
					AO::exposedCode(fao.pointsToExposed(true)));
              fao.write_string_rep(outf);
              fprintf(outf, "\n");
@


1.56
log
@Normalized vargs/largno/islib:
1. Directive from instr-ast is now 'f' for defined function,
   and 'v' for vararg function.
2. library functions are now processed in rtca/id.cpp, which
   recognized (and strips out) the _rtclib_ prefix; the islib
   property is propagated to children AOs as they are created.
3. stat counters and the undef-fn output both now filter out
   isLib objects.
@
text
@d538 5
a542 3
  AO::aoWriteStream = outf;
  traverseAOs(AO::assignEcrNos);
  AO::aoWriteStream = 0;
d546 1
a546 2
  if(tsl) traverseAOs(AO::writeTSlevel);
  else    traverseAOs(AO::writeTScateg);
d549 25
d861 3
a863 1
		if(fromao.hasECR() && ECR::getECR(fromao).pointsToExposed()){
@


1.55
log
@Removed aoArray object.
@
text
@d90 2
a91 1
        case 'f': { //- function definition
d96 1
a96 1
              ((AOFunction *)ao)->setLargNo(largno);
a103 9
        case 'v': { //- vararg indicator
            char * cp = &buf[2];
            unsigned int vargno = strtoul(cp, &cp, 10);
            AO * ao = AO::stringToAO(cp, &cp, aidmap, pidmap, values);
            if(ao){
              ao->setVargNo(vargno);
              vararglist.insert(*ao);
            }
	  } break;
d668 2
d802 1
a802 1
	  if(fao && !fao->getLargNo()){ // id is regular function, and defined
@


1.54
log
@Added mechanism to collect stats about safe/unsafe tracked/untracked
pointer/fnptr/ptrs-in-structs/locations; involved various new additions
(including 'f' defined-function directive from instr-ast.sml)
@
text
@a778 1
    case AO::aoArray:
@


1.53
log
@Wrote -ptrw version, which only propagates exposed and
influential from assigned-to invalid AOs.
@
text
@d90 13
d531 1
d655 19
d695 170
d883 27
@


1.52
log
@Added -ptrw flag, but currently only placeholder which
behaves identically to -ptr
@
text
@d417 19
d464 1
a464 1
void TCAstate::invalidPtrAnalysis()
d473 1
a473 1
  traverseAOs(assignTSCderef);
d777 1
a777 1
      state.invalidPtrAnalysis();
@


1.51
log
@Added vargno handling:
Each AO now has a vargno argument, which if nonzero indicates
a vararg function. This is set by the new "v" directive from
tc-assign. When an AO has a non-zero vargno, we merge the ECRs
of all argret nodes from vargno up to maxnargs.
NOTE: may want to reimplement better: make vargno an argument
of only aoFunction...
@
text
@d668 1
a668 1
  enum { tcm_addr, tcm_pta, tcm_ptr, tcm_full } mode = tcm_addr;
d680 2
d711 2
d756 1
d782 1
@


1.50
log
@Added invalid-pointer analysis (-ptr flag) that only marks
non-null possibly-invalid dereferences, and their points-to
targets as exposed -- to be used by new security tool
@
text
@d90 9
d293 7
a299 10
              if(rst){
                TCassignEdge * edge = lao.assignTo(rao, *rst);
                if(edge) static_arg_ret_assigns->Append(edge);
	        lao.setRequiredType(*rst); //- add assignment type to reqd-type
              } else {
                fprintf(stderr, "insertArgRetAssignEdge: ");
                lao.debug_dump(stderr);
                fprintf(stderr, " --ASSIGN--> ");
                rao.debug_dump(stderr);
                fprintf(stderr, ": no static type! Edge not added.\n");
d301 4
@


1.49
log
@Major Revision: include ECR number and incl-to edges in output.
@
text
@d222 20
d407 19
d435 13
d658 1
a658 1
  enum { tcm_addr, tcm_pta, tcm_full } mode = tcm_addr;
d669 1
d697 2
d741 5
d764 7
@


1.48
log
@Minor usage-message changes.
@
text
@d450 5
@


1.47
log
@Added Type-safety Category assignment.
(major change).
Appears working, tested on gcc, verified on small examples,
not thoroughly verified.
Also, added -readable flag.
@
text
@d433 2
d609 1
a609 1
			   "     -o outfile   output filename (default a.tc_asgs)\n"
d612 1
a612 1
			   "     -full        full analysis (not yet fully implemented)\n"
@


1.46
log
@Introduced "write-type" to assist in computation of
poss-type constraints -- performance improves drastically!
Verified results on gcc, ijpeg.
@
text
@d356 32
a387 1
void TCAstate::tslAnalysis()
d391 3
a393 1
//TODO
d425 1
a425 1
void TCAstate::writeTSlevels(FILE * outf)
d431 1
a431 1
  fprintf(stderr, "---Outputting ts_levels\n");
d450 2
a451 1
  traverseAOs(AO::writeTSlevel);
d612 1
d651 2
d676 1
a676 1
      state.tslAnalysis();
a700 2
      } else if(mode == tcm_pta){
        state.writeAliases(outf);
d702 8
a709 1
        state.writeTSlevels(outf);
@


1.45
log
@Added -summary flag.
@
text
@d155 1
a159 17
void TCAstate::applyAssignConstraint(ECR& fromECR, ECR& toECR)
{
  if(toECR.traverseTag == ECR::traverseCounter) return;
  toECR.traverseTag = ECR::traverseCounter;

  //- the assignment constraint
  toECR.possType().constrainLE(fromECR.possType());

  //- follow incl edges forward
  suco_iterator<ECR *> ii(toECR.inclToECRs());
  while(ii.Iterate())
    applyAssignConstraint(fromECR, *ii.Current());

  //- do inclusions
  initPossTypeConstraintsInclusion(toECR);
}

d167 3
a169 1
    applyAssignConstraint(fromECR, toECR);
@


1.44
log
@Added -verbose-mode dot-output for possible-type constraint
initialization and assignment-processing.
@
text
@d343 1
a343 1
void TCAstate::rtAnalysis()
d457 19
d581 1
d591 2
a592 1
			   "     -debug       dump debug output\n"
d630 2
d645 1
a645 1
    outfile = (debug_mode)?"a.debug_dump":"a.tc_tsls";
d652 1
a652 1
      state.rtAnalysis();
d676 2
@


1.43
log
@Fixed oversight in applyAssignConstraint -- was not propagating down
inclusion edges.
Added STAT debug output, etc.
@
text
@d133 6
d147 4
d184 6
@


1.42
log
@Added constraint solving -- not thoroughly tested, though
it appears to work on some sample tests.
@
text
@d157 5
d493 5
d507 12
d529 8
@


1.41
log
@Finished (but not tested) initialization of poss-type
constraints.
This entailed creation of a root set (encapsulated by
the class TClatRootSet).
Also, to manipulate the traverseCounter, TCAstate is now
a friend of ECR -- I'm not sure I like this arrangement.
@
text
@d344 3
a346 3
//  if(flag_verbose) fprintf(stderr, "Solving possible-type constraints...\n");
//TODO
//  if(flag_verbose) fprintf(stderr, "... done solving possible-type constraints\n");
@


1.40
log
@Intermediate checkin: started writing poss-type constraint
generation: added some needed data structures to ECR and
TClatType; initialized AO constraints and wrote helper
to process inclusion edges from a given ECR;
need to finally process assignments.
@
text
@d110 2
d118 2
a119 4
        e.possType().meet( (valty.getKind() == TCtype::tcVoid)
			   ? TClatType::tclBottom
			   : TClatType::getKind(valty)
			 );
d122 3
a124 1
        e.possType().meet(TClatType::getKind(((AOOp&)ao).getTy()));
d127 1
a127 1
        e.possType().setKind(TClatType::tclBottom);
d130 1
a130 1
        e.possType().meet(TClatType::tclPointer);
d149 12
d163 9
a171 1
//TODO
d341 4
a344 2
  //- propagate runtime-types
//  if(flag_verbose) fprintf(stderr, "Propagating runtime-types...\n");
d346 1
a346 1
//  if(flag_verbose) fprintf(stderr, "... done propagating runtime-types\n");
@


1.39
log
@Added setting of required-types:
 - file interface now delivers two kinds of assignment edges:
   "true" ('=') and "pseudo" ('-'), the latter for function
   and array object assignments as well as void return assignments.
 - added to AO reqdType member, which is just an enum;
   modified TClatType meet/join functions to work directly on
   enums;
The setting of required types is done:
 1. on file input, for each typed-true-assignment and verify-tag
 2. during arg/ret assignment adding
Finally, AO's debug_dump function has been modified to supply
more diagnostic information; this entailed the renaming of
the virtual portion of the function to dump_descr.
@
text
@d112 1
d115 5
a119 2
        ECR& e = ECR::getECR(ao);
        e.possType().meet(TClatType::getKind(((AOValue&)ao).getTy()));
a121 1
        ECR& e = ECR::getECR(ao);
a124 1
        ECR& e = ECR::getECR(ao);
a127 1
        ECR& e = ECR::getECR(ao);
d130 14
@


1.38
log
@Revamped TClatType;
renamed ECR::rtType to poss_type;
rewrote TCAstate functions for initializing poss-types;
also left a skeleton function for generating constraints.
Todo: augment TClatType with constraint graph capabilities,
generate contraints, and solve.
Also, AO needs to have required-type.
@
text
@d38 2
a39 1
        case '=': { //- assign source
d45 1
d82 1
a82 1
            if(ao && ty) ao->setVerifyTagType(*ty);
d223 1
d288 1
a288 1
  //-- compute rttypes
@


1.37
log
@Added routine to mark dereference nodes.
@
text
@d108 1
a108 3
suco_set<ECR *> TCAstate::rtWorklist;

void TCAstate::initializeRTtypes(AO& ao)
a111 1
        TClatType ty(((AOValue&)ao).getTy());
d113 1
a113 2
        e.rtType().meet(ty);
        rtWorklist.Insert(&e);
a115 1
        TClatType ty(((AOOp&)ao).getTy());
d117 5
a121 2
        e.rtType().meet(ty);
        rtWorklist.Insert(&e);
a123 3

        AOAddrOf& ado = (AOAddrOf&) ao;
        AO& tgt = ado.getTarget();
d125 1
a125 10

        TCtype& lty = tgt.lvalType();
        if((lty.getKind() == TCtype::tcVoid)
	   || (lty.getKind() == TCtype::tcZero)){
          e.rtType().setBottom();
        } else {
          e.rtType().meet(TClatType::validPtrType(lty));
        }
        rtWorklist.Insert(&e);

d130 5
d288 12
a299 3
  if(flag_verbose) fprintf(stderr, "Initializing runtime-types...\n");
  traverseAOs(initializeRTtypes);
  if(flag_verbose) fprintf(stderr, "... done initializing runtime-types\n");
@


1.36
log
@Modified debug output to dump enough information to
reconstruct pt-graph.
@
text
@d169 16
d191 1
d198 2
@


1.35
log
@Split initializeECR into three phases:
1. basic - instantiate ECRs, and build argRets
2. aggregate - do struct/unions (currently collapseAlways)
3. pointers - setup initial points-to relations*
   * reincorporated change to p --pt--> x <--incl-- *p
     from p --pt--> *p
     - this effectively fixes a flaw with *op and *ext
       nodes, where before *+p and *p were combined in
       the same ECR, making it imprecise to propagate
       invalidity. The alternate solution would've been
       to keep the *p rule, but change the *op and *ext
       rules.
@
text
@d411 1
a411 1
  fprintf(outf, "---Dumping ECRs/Points-to Sets---\n");
@


1.34
log
@ELIMINATED TCassignEdgeList, TCassignEdgeSet, and TCassignEdgeIterator;
replaced by SUCO equivalents;
entailed writing a new edge compare function.
@
text
@d158 6
a163 1
  traverseAOs(PTanalysis::initializeECR_collapseAlways);
@


1.33
log
@Finished "add arg-ret assignment" functionality;
entailed adding "mainParent" member to ECRargRet, which
refers to the main parent, which is used as the basis
for finding function pointer resolutions -- make sure
mainParent is set correctly -- that is, getArg is only
called in the PTA initialization function.
Also added a couple of static helper functions in tca,
and made a bunch of ECR/ECRargRet accessors public.
@
text
@d43 1
a43 1
              if(e) assigns.append(*e);
d205 1
a205 1
                if(edge) static_arg_ret_assigns->append(*edge);
d221 1
a221 1
TCassignEdgeList * TCAstate::static_arg_ret_assigns = 0;
d398 2
a399 1
  assigns.debug_dump(outf);
d403 2
a404 1
  arg_ret_assigns.debug_dump(outf);
@


1.32
log
@Added skeleton framework for adding argret assignments;
also replaced ECRset with suco_set.
@
text
@d170 1
d173 3
d182 37
d223 2
d227 1
d231 5
a235 1
    if(ear){
d238 1
a238 1
      ecr.traverseAliases(0, collectInclToArgRets);
d244 18
a261 1
//- TODO
d400 4
d448 1
d458 1
d495 2
d531 4
a534 9
  FILE * outf = fopen(outfile, "w");
  if(!outf){
    fprintf(stderr, "Error opening output file %s\n", outfile);
  } else {
    fprintf(stderr, "Writing output to file [%s]\n", outfile);
    if(debug_mode){
      state.debug_dump(outf);
    } else if(mode == tcm_pta){
      state.writeAliases(outf);
d536 9
a544 1
      state.writeTSlevels(outf);
a545 1
    fclose(outf);
@


1.31
log
@Transferred PTA assignment processing from tca.cpp to pta.cpp/h
@
text
@d108 1
a108 1
ECRset TCAstate::rtWorklist;
d117 1
a117 1
        rtWorklist.insert(e);
d123 1
a123 1
        rtWorklist.insert(e);
d138 1
a138 1
        rtWorklist.insert(e);
d164 38
d441 1
d448 1
@


1.30
log
@Added points-to set output option: -pta now dumps points-to sets
(alias groups)...
 - ao: added isRef flag/accessor
 - ecr.cpp/h: modified traversePointsToSet - is now traverseAliases
 - tca.cpp/h: top level callers.
@
text
@d161 1
a161 22
  // - process assignment edges
  if(flag_verbose) fprintf(stderr, "Processing Assignment Edges...\n"
				   "(each dot is 100 assignments, 50 dots per row)\n");
  {
    int counter = 0;
    TCassignEdgeIterator ei(assigns);
    while(ei.iterate()){
      TCassignEdge& e = *ei.current();
      if(!e.getTo().isVal()){ //- don't process assignments into Value nodes
        ECR& rhs = ECR::getECR(e.getFrom());
        ECR& lhs = ECR::getECR(e.getTo());
        lhs.getPointsTo().includesTo(rhs.getPointsTo());
        if(flag_verbose){
          if(++counter % 100 == 0)
            fprintf(stderr, ".");
          if(counter % 5000 == 0)
            fprintf(stderr, "\n");
        }
      }
    }
  }
  if(flag_verbose) fprintf(stderr, "... done Processing Assignment Edges\n");
@


1.29
log
@Added skeleton for lvalType(), with initial seeding rules
in tca.cpp, and ECR debug_dump to include rttype.
Must rethink strategy for solving constraints before
proceeding
@
text
@d267 18
d446 2
@


1.28
log
@Added staticType (+).
@
text
@d126 1
d129 11
a139 1
        //--TODO
@


1.27
log
@Small change: -pta doesn't set debug_mode to true by default anymore.
@
text
@d70 6
@


1.26
log
@Minor cmdline adjustments: added -pta flag; set default
fixnargs to true.
@
text
@d333 1
a333 1
			   "     -pta         points-to analysis only (turns on debug mode)\n"
a357 1
        debug_mode = true;
@


1.25
log
@Started adding RT-analysis stuff - barebones only.
@
text
@d127 1
a127 1
void TCAstate::fullAnalysis()
d166 1
d168 2
d182 1
d184 2
d187 1
a187 1
  //-- compute rttypes
d324 2
a325 2
  char * outfile = "a.tc_tsls";
  enum { tcm_addr, tcm_full } mode = tcm_addr;
d330 15
a344 8
			   "       [options] are:\n"
			   "       -o outfile   output file (default %s)\n"
			   "       -addr        address-taken analysis (default action)\n"
			   "       -full        full analysis (not yet fully implemented)\n"
			   "       -debug       dump debug output\n"
			   "       -norecycle   turn off recycling of type nodes (on by default)\n"
			   "       -stat        dump stat (currently, counts recycle)\n"
			   "       -v           verbose execution\n"
d346 1
a346 1
			, argv[0], outfile);
d356 3
d361 2
d365 5
a369 3
      } else if(!strcmp(argv[i],"-stat")){
        flag_stat = true;
      } else if(!strcmp(argv[i],"-norecycle")){
d383 3
d389 7
a395 1
      state.fullAnalysis();
@


1.24
log
@Changed verifyPtr from a boolean flag to a type.
@
text
@d102 25
d168 1
a168 1
  //- TODO: compute rt-types, assign ts_levels, etc
d170 13
@


1.23
log
@Incorporated new format that includes typed-assignments
(: <T> <O>) and verifyTag/verifyPtr (} <T> <O>, ] <O>).
@
text
@d78 1
d80 1
a80 1
            if(ao) ao->setVerifyPtrFlag();
@


1.22
log
@renamed fixnargs to maxnargs
@
text
@d26 1
d34 1
d36 1
d42 1
a42 1
              TCassignEdge * e = aosrc->assignTo(*aotgt);
d70 11
@


1.21
log
@3) added -fixnargs flag to compute max nargs and use
   that for all argrets. simpler solution...

4) added fwdptr to argret - necessary to ensure
   correctness (?).
   This resulted in a major overhaul - argret::absorb
   must now be wary of clashes with ecr::absorb -
   added recursive trick, etc.
   Currently seems to work, but have not validated results.
   NOTE: this change resulted in a crash that was eliminated
   only after I removed both deletes of argrets. FIND BUG!?!
@
text
@d96 1
a96 1
    if(flag_verbose) fprintf(stderr, "... done Computing maxnargs = %d\n", ECRargRet::getFixNargs());
d105 1
a105 1
  if(flag_verbose) fprintf(stderr, "Processing Assignment Edgesi...\n"
@


1.20
log
@Major change: added ArgRet handling stuff:
defined ECRargRet class, wrote functions
ECR::processArgRetFlow/simulateAssign/collectArgRetFrontier...
Only aspect not handled: after simulating assignment for
argrets with different nargs, must propagate the delta
(forward or backward) - requires non-trivial change
to data structure.
@
text
@d91 8
d292 2
@


1.19
log
@Added flag_verbose
@
text
@d97 2
a98 1
  if(flag_verbose) fprintf(stderr, "Processing Assignment Edges...\n");
d100 1
d108 6
@


1.18
log
@Added -stat,-norecycle flags, incorporated diag.h/cpp
@
text
@d92 1
d94 1
d97 1
d109 1
d256 1
d260 1
d262 1
a262 2
			   "       -norecycle   turn off recycling of type nodes (on by default)\n"
			   "       -o outfile   output file (default %s)\n"
d282 2
@


1.17
log
@Simplified addrof analysis to mark *all* addrof nodes as
unsafe, not just those immediately on the rhs of an assignment
(as was previously done). Basically merged setDerefUnsafe and
setUDotUnsafe and code in addrAssignAnalysis into one helper
function setAddrofDerefUDotUnsafe().
@
text
@d6 1
d255 2
d258 1
d271 4
d310 3
@


1.16
log
@Added mechanism to count stats about the number of each
type of node, and prepend it to the output.
@
text
@d111 1
a111 1
void TCAstate::setDerefUnsafe(AO& ao)
d113 10
a122 1
  if(ao.getKind() == AO::aoStar)
d124 1
a124 1
}
d126 2
a127 2
void TCAstate::setUDotUnsafe(AO& ao)
{
d137 1
a137 19
  //----------------------------------------
  //-- walk edges, and mark address-taken AOs
  {
    TCassignEdgeIterator ei(assigns);
    while(ei.iterate()){
      AO& rhs = ei.current()->getFrom();
      if(rhs.getKind() == AO::aoAddrOf){
        AOAddrOf& ado = (AOAddrOf&) rhs;
        ado.getTarget().setTS_UNSAFE(); //- propagates along assign edges
      }
    }
  }
  //----------------------------------------
  //-- find all dereference nodes, mark as unsafe
  traverseAOs(setDerefUnsafe);

  //----------------------------------------
  //-- find all union-dot nodes, mark as unsafe
  traverseAOs(setUDotUnsafe);
@


1.15
log
@Added TCAstate::setUDotUnsafe to mark all union objects
as unsafe.
@
text
@d157 8
d218 29
@


1.14
log
@Stripped out debug print ifdef'ed-out code.
@
text
@d117 9
d143 4
@


1.13
log
@Program now takes two flags: -addr for addr-taken analysis,
and -full for full analysis (not yet implemented, but currently
includes points-to analysis); as well as -debug to dump debug
trace.
Addr-taken analysis + assign propagation fully done.
@
text
@a5 2
//#define DBGPRINT

a28 3
#ifdef DBGPRINT
/**/  fprintf(stderr, " doing : %s", buf);
#endif //DBGPRINT
a32 7
#ifdef DBGPRINT
/**/        if(aotgt){
/**/		fprintf(stderr, "ASTGT: ");
/**/		aotgt->debug_dump(stderr);
/**/		fprintf(stderr, "\n");
/**/	    }
#endif //DBGPRINT
a36 7
#ifdef DBGPRINT
/**/        if(aosrc){
/**/		fprintf(stderr, "  SRC: ");
/**/		aosrc->debug_dump(stderr);
/**/		fprintf(stderr, "\n");
/**/	    }
#endif //DBGPRINT
a75 8
#ifdef DBGPRINT
/**/fprintf(stderr, "AIDMAP:\n");
/**/aidmap.debug_dump(stderr);
/**/fprintf(stderr, "PIDMAP:\n");
/**/pidmap.debug_dump(stderr);
/**/fprintf(stderr, "EDGES:\n");
/**/assigns.debug_dump(stderr);
#endif // DBGPRINT
@


1.12
log
@Added calls to newly-implemented points-to analysis.
@
text
@d106 8
a113 1
void TCAstate::addrAssignAnalysis()
d134 3
d138 9
d154 1
a154 4
        ado.getTarget().setTS_UNSAFE();

  //-- propagage unsafe-ness via assign edges
//TODO
d158 3
a160 7
}

void TCAstate::traverseAOs(void (*fp)(AO&))
{
  values.traverseAOs(fp);
  aidtab.traverseAOs(fp);
  pidtab.traverseAOs(fp);
d231 2
a232 1
  enum { tcm_addr, tcm_addr_assign, tcm_dump } mode = tcm_addr;
d238 2
a239 1
			   "       -dump        dump debug output\n"
d251 4
a254 4
      } else if(!strcmp(argv[i],"-addr-assign")){
        mode = tcm_addr_assign;
      } else if(!strcmp(argv[i],"-dump")){
        mode = tcm_dump;
d264 10
a273 1
  state.addrAssignAnalysis();
d281 4
a284 10
    switch(mode){
      case tcm_dump:
        state.debug_dump(outf);
        break;

      case tcm_addr:
      default:
        state.writeTSlevels(outf);
        break;

@


1.11
log
@renamed AOAddrOf target() to getTarget()
@
text
@d11 1
d108 20
d129 7
a135 6
  TCassignEdgeIterator ei(assigns);
  while(ei.iterate()){
    AO& rhs = ei.current()->getFrom();
    if(rhs.getKind() == AO::aoAddrOf){
      AOAddrOf& ado = (AOAddrOf&) rhs;
      ado.getTarget().setTS_UNSAFE();
d139 1
d206 5
d249 3
a251 2
//-- PT analysis
  state.traverseAOs(PTanalysis::initializeECR_collapseAlways);
a257 6
/**/
AO::aoWriteStream = outf;
fprintf(outf, "---ECRs---\n");
state.traverseAOs(AO::writeECR);
AO::aoWriteStream = 0;
/**/
a264 1
        state.addrAssignAnalysis();
@


1.10
log
@Added calls to newly-written ECR-assignment function,
with debug output.
@
text
@d113 1
a113 1
      ado.target().setTS_UNSAFE();
@


1.9
log
@Added assignEdgeSet to AOs, and mechanism to insert into
the set without duplication.
Next: use this info to propagate UNSAFE from addr-taken
nodes.
@
text
@d10 1
d121 7
d144 3
a146 5
  AO::writeTSstream = outf;
  values.traverseAOs(AO::writeTSlevel);
  aidtab.traverseAOs(AO::writeTSlevel);
  pidtab.traverseAOs(AO::writeTSlevel);
  AO::writeTSstream = 0;
d221 3
d229 6
@


1.8
log
@Added type-safety level to AO; improved analysis output
function to tag address-taken objects as UNSAFE, and later
output them; the old function (writeAddrofTSlevels) is now
obsolete and should be removed.
@
text
@d54 4
a57 2
            if(aosrc && aotgt)
              assigns.insert(*new TCedge(*aotgt,*aosrc));
d107 1
a107 1
  TCedgeIterator ei(assigns);
a112 2
    }
  }
d116 2
d137 1
a137 1
  values.traverse(AO::writeTSlevel);
a143 27
void TCAstate::writeAddrofTSlevels(FILE * outf)
{
  //-- assign unique IDs to aidtab and pidtab entries
  unsigned int n = aidtab.assignUIDs(1);
  pidtab.assignUIDs(n);

  fprintf(stderr, "---Outputting ts_levels\n");

  //-- first: for address-taken analysis, default ts-level is SAFE
  fprintf(outf, "^ S\n");

  aidtab.output_aliases(outf, '@@');
  pidtab.output_aliases(outf, '%');

  TCedgeIterator ei(assigns);
  while(ei.iterate()){
    AO& rhs = ei.current()->getFrom();
    if(rhs.getKind() == AO::aoAddrOf){
      AOAddrOf& ado = (AOAddrOf&) rhs;
      fprintf(outf, "~ U "); //- unsafe
      ado.target().write_string_rep(outf);
      fprintf(outf, "\n");
    }
  }
  fprintf(stderr, "---Done Outputting ts_levels\n");
}

d162 1
a162 1
  values.traverse(dump_ao_fun);
a190 1
			   "       -addr-assign address-taken+assignment analysis\n"
d225 2
a226 1
      case tcm_addr_assign:
a230 3
      case tcm_addr:
      default:
        state.writeAddrofTSlevels(outf);
@


1.7
log
@Added mechanism to store AOs in an AOlist in each AO.
Included mechanism for traversing all AOs, and debug output
functions.
Fairly complete, but not thoroughly tested (especially TypeList
destructors?)
@
text
@d102 1
a102 1
void TCAstate::writeTSlevels(char * filename)
d104 60
a163 25
  FILE * outf = fopen(filename, "w");
  if(!outf){
    fprintf(stderr, "Error opening output file %s\n", filename);
  } else {
    //-- assign unique IDs to aidtab and pidtab entries
    unsigned int n = aidtab.assignUIDs(1);
    pidtab.assignUIDs(n);

    fprintf(stderr, "---Outputting ts_levels in [%s]\n", filename);

    //-- first: for address-taken analysis, default ts-level is SAFE
    fprintf(outf, "^ S\n");

    aidtab.output_aliases(outf, '@@');
    pidtab.output_aliases(outf, '%');

    TCedgeIterator ei(assigns);
    while(ei.iterate()){
      AO& rhs = ei.current()->getFrom();
      if(rhs.getKind() == AO::aoAddrOf){
        AOAddrOf& ado = (AOAddrOf&) rhs;
        fprintf(outf, "~ U "); //- unsafe
        ado.target().write_string_rep(outf);
        fprintf(outf, "\n");
      }
a164 2
    fprintf(stderr, "---Done Outputting ts_levels\n");
    fclose(outf);
d166 1
d172 1
a172 1
void TCAstate::debug_dump(char * filename)
d174 1
a174 5
  FILE * outf = fopen(filename, "w");
  if(!outf){
    fprintf(stderr, "Error opening output file %s\n", filename);
  } else {
    fprintf(stderr, "---Dumping State into [%s]:\n", filename);
d176 25
a200 25
    fprintf(stderr, " --Dumping Aidtab...\n");
    fprintf(outf, "--AIDTAB:\n");
    aidtab.debug_dump(outf);

    fprintf(stderr, " --Dumping Pidtab...\n");
    fprintf(outf, "--PIDTAB:\n");
    pidtab.debug_dump(outf);

    daf_outf = outf;
    fprintf(stderr, " --Dumping Value-AOs...\n");
    fprintf(outf, "--VALUE-AOs:\n");
    values.traverse(dump_ao_fun);

    fprintf(stderr, " --Dumping Aid-AOs...\n");
    fprintf(outf, "--AID-AOs:\n");
    aidtab.traverseAOs(dump_ao_fun);

    fprintf(stderr, " --Dumping Pid-AOs...\n");
    fprintf(outf, "--PID-AOs:\n");
    pidtab.traverseAOs(dump_ao_fun);
    daf_outf = 0;

    fprintf(stderr, " --Dumping Assignments...\n");
    fprintf(outf, "--ASSIGNS:\n");
    assigns.debug_dump(outf);
d202 1
a202 3
    fprintf(stderr, "---Done Dumping State\n");
    fclose(outf);
  }
d210 1
a210 1
  enum { tcm_addr, tcm_dump } mode = tcm_addr;
d215 4
a218 3
			   "       -addr       address-taken analysis (default action)\n"
			   "       -dump       dump debug output\n"
			   "       -o outfile  output file (default %s)\n"
d229 2
d241 20
a260 8
  switch(mode){
    case tcm_dump:
      state.debug_dump(outfile);
      break;

    case tcm_addr:
    default:
      state.writeTSlevels(outfile);
@


1.6
log
@Addeed default ts-level output (one line added).
@
text
@d35 1
a35 1
            aotgt = AO::stringToAO(cp, &cp, aidmap, pidmap);
d46 1
a46 1
            AO * aosrc = AO::stringToAO(cp, &cp, aidmap, pidmap);
a91 2
/**/fprintf(stderr, "AIDTAB:\n");
/**/aidtab.debug_dump(stderr);
a93 2
/**/fprintf(stderr, "PIDTAB:\n");
/**/pidtab.debug_dump(stderr);
d135 4
a138 1
void TCAstate::dumpAssigns(char * filename)
d144 26
a169 1
    fprintf(stderr, "---Dumping Assignment Edges into [%s]\n", filename);
d171 2
a172 1
    fprintf(stderr, "---Done Dumping Assignment Edges\n");
d212 1
a212 1
      state.dumpAssigns(outfile);
@


1.5
log
@Fixed address-of analysis to output the addr-of target
rather than the addr-of object as unsafe.
@
text
@d118 3
@


1.4
log
@Added -dump option to dump assignment edges in human-readable form
@
text
@d125 1
a125 1
/*TODO:skip the dummy "x = &x" edges for functions - how to tell function from legit cases?*/
d127 1
a127 1
        rhs.write_string_rep(outf);
@


1.3
log
@Added writeTSlevels to output address-taken analysis
type-safety levels to a file.
@
text
@d131 4
d136 10
a145 1
    fprintf(stderr, "---Done Outputting ts_levels\n");
d154 1
d157 6
a162 2
    return fprintf(stderr, "Usage: %s [-o outfile] files\n"
			   "       Default outfile is a.tc_tsls\n", argv[0]);
d167 10
a176 2
    if(!strcmp(argv[i],"-o")){
      if(i+1 < argc) outfile = argv[++i];
d182 9
a190 1
  state.writeTSlevels(outfile);
@


1.2
log
@Insert assignments into edge list, and debug-output.
@
text
@d6 2
d17 3
a19 1
  if(inf){
d29 1
d31 1
d36 1
d42 1
d47 1
d53 1
d55 1
a55 1
              assigns.insert(*new TCedge(*aosrc,*aotgt));
d91 1
d102 9
d112 21
a132 1
    fprintf(stderr, "Error opening file %s\n", filename);
d140 2
d143 2
a144 1
    return fprintf(stderr, "Usage: %s files\n", argv[0]);
d148 9
a156 2
  for(int i = 1; i < argc; ++i)
    state.processFile(argv[i]);
@


1.1
log
@Initial revision
@
text
@d44 2
d89 2
@
