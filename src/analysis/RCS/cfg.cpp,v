head	1.139;
access;
symbols;
locks; strict;
comment	@// @;


1.139
date	2004.07.19.22.59.54;	author suan;	state Exp;
branches;
next	1.138;

1.138
date	2004.07.18.01.14.25;	author suan;	state Exp;
branches;
next	1.137;

1.137
date	2004.07.16.21.27.34;	author suan;	state Exp;
branches;
next	1.136;

1.136
date	2004.07.16.19.46.35;	author suan;	state Exp;
branches;
next	1.135;

1.135
date	2004.06.29.20.02.32;	author suan;	state Exp;
branches;
next	1.134;

1.134
date	2004.06.28.22.20.13;	author suan;	state Exp;
branches;
next	1.133;

1.133
date	2004.06.22.16.19.28;	author suan;	state Exp;
branches;
next	1.132;

1.132
date	2004.06.15.18.55.35;	author suan;	state Exp;
branches;
next	1.131;

1.131
date	2004.05.24.20.08.15;	author suan;	state Exp;
branches;
next	1.130;

1.130
date	2004.05.17.22.33.16;	author suan;	state Exp;
branches;
next	1.129;

1.129
date	2004.05.14.22.41.56;	author suan;	state Exp;
branches;
next	1.128;

1.128
date	2004.05.13.16.01.34;	author suan;	state Exp;
branches;
next	1.127;

1.127
date	2004.05.12.18.53.04;	author suan;	state Exp;
branches;
next	1.126;

1.126
date	2004.05.11.21.50.54;	author suan;	state Exp;
branches;
next	1.125;

1.125
date	2004.05.11.15.01.15;	author suan;	state Exp;
branches;
next	1.124;

1.124
date	2004.05.10.14.50.59;	author suan;	state Exp;
branches;
next	1.123;

1.123
date	2004.05.07.21.21.52;	author suan;	state Exp;
branches;
next	1.122;

1.122
date	2004.05.07.19.52.39;	author suan;	state Exp;
branches;
next	1.121;

1.121
date	2004.05.07.18.49.38;	author suan;	state Exp;
branches;
next	1.120;

1.120
date	2004.05.07.14.37.59;	author suan;	state Exp;
branches;
next	1.119;

1.119
date	2004.05.04.15.31.15;	author suan;	state Exp;
branches;
next	1.118;

1.118
date	2004.05.03.22.56.17;	author suan;	state Exp;
branches;
next	1.117;

1.117
date	2004.05.03.20.45.59;	author suan;	state Exp;
branches;
next	1.116;

1.116
date	2004.05.02.18.50.18;	author suan;	state Exp;
branches;
next	1.115;

1.115
date	2004.05.02.18.26.36;	author suan;	state Exp;
branches;
next	1.114;

1.114
date	2004.04.29.18.44.41;	author suan;	state Exp;
branches;
next	1.113;

1.113
date	2004.04.29.15.09.01;	author suan;	state Exp;
branches;
next	1.112;

1.112
date	2004.04.21.18.59.26;	author suan;	state Exp;
branches;
next	1.111;

1.111
date	2004.04.21.18.35.11;	author suan;	state Exp;
branches;
next	1.110;

1.110
date	2004.04.14.15.26.53;	author suan;	state Exp;
branches;
next	1.109;

1.109
date	2004.04.14.00.22.35;	author suan;	state Exp;
branches;
next	1.108;

1.108
date	2004.04.12.20.14.03;	author suan;	state Exp;
branches;
next	1.107;

1.107
date	2004.04.08.23.20.42;	author suan;	state Exp;
branches;
next	1.106;

1.106
date	2004.04.08.18.08.11;	author suan;	state Exp;
branches;
next	1.105;

1.105
date	2004.04.07.19.25.59;	author suan;	state Exp;
branches;
next	1.104;

1.104
date	2004.04.05.18.16.29;	author suan;	state Exp;
branches;
next	1.103;

1.103
date	2004.04.05.17.32.18;	author suan;	state Exp;
branches;
next	1.102;

1.102
date	2004.04.05.17.27.02;	author suan;	state Exp;
branches;
next	1.101;

1.101
date	2004.04.05.15.50.07;	author suan;	state Exp;
branches;
next	1.100;

1.100
date	2004.04.02.00.26.12;	author suan;	state Exp;
branches;
next	1.99;

1.99
date	2004.03.29.16.29.36;	author suan;	state Exp;
branches;
next	1.98;

1.98
date	2004.03.22.20.08.26;	author suan;	state Exp;
branches;
next	1.97;

1.97
date	2004.03.18.21.21.28;	author suan;	state Exp;
branches;
next	1.96;

1.96
date	2004.02.25.22.12.54;	author suan;	state Exp;
branches;
next	1.95;

1.95
date	2004.02.24.16.42.15;	author suan;	state Exp;
branches;
next	1.94;

1.94
date	2004.02.18.22.33.22;	author suan;	state Exp;
branches;
next	1.93;

1.93
date	2004.02.18.16.06.52;	author suan;	state Exp;
branches;
next	1.92;

1.92
date	2004.02.17.20.22.40;	author suan;	state Exp;
branches;
next	1.91;

1.91
date	2004.01.16.21.47.26;	author suan;	state Exp;
branches;
next	1.90;

1.90
date	2003.12.18.20.05.49;	author suan;	state Exp;
branches;
next	1.89;

1.89
date	2003.12.16.22.57.18;	author suan;	state Exp;
branches;
next	1.88;

1.88
date	2003.12.11.21.03.59;	author suan;	state Exp;
branches;
next	1.87;

1.87
date	2003.11.14.22.47.57;	author suan;	state Exp;
branches;
next	1.86;

1.86
date	2003.11.14.16.22.54;	author suan;	state Exp;
branches;
next	1.85;

1.85
date	2003.11.14.15.58.36;	author suan;	state Exp;
branches;
next	1.84;

1.84
date	2003.11.13.20.12.23;	author suan;	state Exp;
branches;
next	1.83;

1.83
date	2003.11.13.20.04.29;	author suan;	state Exp;
branches;
next	1.82;

1.82
date	2003.11.13.00.23.51;	author suan;	state Exp;
branches;
next	1.81;

1.81
date	2003.11.04.20.45.59;	author suan;	state Exp;
branches;
next	1.80;

1.80
date	2003.10.22.21.23.32;	author suan;	state Exp;
branches;
next	1.79;

1.79
date	2003.10.17.23.00.17;	author suan;	state Exp;
branches;
next	1.78;

1.78
date	2003.10.08.23.31.07;	author suan;	state Exp;
branches;
next	1.77;

1.77
date	2003.10.02.22.59.37;	author suan;	state Exp;
branches;
next	1.76;

1.76
date	2003.10.01.22.18.32;	author suan;	state Exp;
branches;
next	1.75;

1.75
date	2003.06.18.20.08.46;	author suan;	state Exp;
branches;
next	1.74;

1.74
date	2003.04.07.23.14.51;	author suan;	state Exp;
branches;
next	1.73;

1.73
date	2003.03.29.20.00.59;	author suan;	state Exp;
branches;
next	1.72;

1.72
date	2003.03.26.15.53.05;	author suan;	state Exp;
branches;
next	1.71;

1.71
date	2003.03.20.23.01.22;	author suan;	state Exp;
branches;
next	1.70;

1.70
date	2003.02.25.16.43.05;	author suan;	state Exp;
branches;
next	1.69;

1.69
date	2003.02.24.22.54.30;	author suan;	state Exp;
branches;
next	1.68;

1.68
date	2003.02.24.21.53.17;	author suan;	state Exp;
branches;
next	1.67;

1.67
date	2003.02.22.18.04.11;	author suan;	state Exp;
branches;
next	1.66;

1.66
date	2003.02.21.20.37.30;	author suan;	state Exp;
branches;
next	1.65;

1.65
date	2003.02.21.17.40.11;	author suan;	state Exp;
branches;
next	1.64;

1.64
date	2003.02.18.23.27.37;	author suan;	state Exp;
branches;
next	1.63;

1.63
date	2003.02.17.20.21.32;	author suan;	state Exp;
branches;
next	1.62;

1.62
date	2003.02.14.20.55.04;	author suan;	state Exp;
branches;
next	1.61;

1.61
date	2003.02.14.18.24.47;	author suan;	state Exp;
branches;
next	1.60;

1.60
date	2003.02.14.17.12.21;	author suan;	state Exp;
branches;
next	1.59;

1.59
date	2003.01.16.17.45.59;	author suan;	state Exp;
branches;
next	1.58;

1.58
date	2003.01.13.17.39.03;	author suan;	state Exp;
branches;
next	1.57;

1.57
date	2003.01.09.00.19.00;	author suan;	state Exp;
branches;
next	1.56;

1.56
date	2003.01.03.18.43.48;	author suan;	state Exp;
branches;
next	1.55;

1.55
date	2002.12.25.17.03.50;	author suan;	state Exp;
branches;
next	1.54;

1.54
date	2002.12.24.21.22.32;	author suan;	state Exp;
branches;
next	1.53;

1.53
date	2002.12.21.00.01.06;	author suan;	state Exp;
branches;
next	1.52;

1.52
date	2002.12.20.23.06.38;	author suan;	state Exp;
branches;
next	1.51;

1.51
date	2002.12.19.22.03.44;	author suan;	state Exp;
branches;
next	1.50;

1.50
date	2002.12.19.19.44.08;	author suan;	state Exp;
branches;
next	1.49;

1.49
date	2002.12.19.00.24.06;	author suan;	state Exp;
branches;
next	1.48;

1.48
date	2002.12.18.00.24.34;	author suan;	state Exp;
branches;
next	1.47;

1.47
date	2002.12.17.22.01.28;	author suan;	state Exp;
branches;
next	1.46;

1.46
date	2002.12.16.23.32.20;	author suan;	state Exp;
branches;
next	1.45;

1.45
date	2002.12.11.17.43.59;	author suan;	state Exp;
branches;
next	1.44;

1.44
date	2002.11.29.21.26.17;	author suan;	state Exp;
branches;
next	1.43;

1.43
date	2002.11.29.16.45.56;	author suan;	state Exp;
branches;
next	1.42;

1.42
date	2002.11.28.00.28.46;	author suan;	state Exp;
branches;
next	1.41;

1.41
date	2002.11.27.22.23.07;	author suan;	state Exp;
branches;
next	1.40;

1.40
date	2002.11.27.21.15.17;	author suan;	state Exp;
branches;
next	1.39;

1.39
date	2002.11.27.19.52.44;	author suan;	state Exp;
branches;
next	1.38;

1.38
date	2002.11.27.18.46.20;	author suan;	state Exp;
branches;
next	1.37;

1.37
date	2002.11.27.17.16.25;	author suan;	state Exp;
branches;
next	1.36;

1.36
date	2002.11.27.17.11.24;	author suan;	state Exp;
branches;
next	1.35;

1.35
date	2002.11.27.00.51.52;	author suan;	state Exp;
branches;
next	1.34;

1.34
date	2002.11.27.00.28.10;	author suan;	state Exp;
branches;
next	1.33;

1.33
date	2002.11.26.23.18.36;	author suan;	state Exp;
branches;
next	1.32;

1.32
date	2002.11.26.20.23.21;	author suan;	state Exp;
branches;
next	1.31;

1.31
date	2002.11.26.00.57.59;	author suan;	state Exp;
branches;
next	1.30;

1.30
date	2002.11.25.22.49.51;	author suan;	state Exp;
branches;
next	1.29;

1.29
date	2002.11.25.19.30.25;	author suan;	state Exp;
branches;
next	1.28;

1.28
date	2002.11.21.16.50.28;	author suan;	state Exp;
branches;
next	1.27;

1.27
date	2002.11.21.00.35.53;	author suan;	state Exp;
branches;
next	1.26;

1.26
date	2002.11.20.19.09.02;	author suan;	state Exp;
branches;
next	1.25;

1.25
date	2002.11.19.20.09.12;	author suan;	state Exp;
branches;
next	1.24;

1.24
date	2002.11.18.22.49.59;	author suan;	state Exp;
branches;
next	1.23;

1.23
date	2002.11.18.22.15.52;	author suan;	state Exp;
branches;
next	1.22;

1.22
date	2002.11.15.17.49.43;	author suan;	state Exp;
branches;
next	1.21;

1.21
date	2002.11.14.21.26.46;	author suan;	state Exp;
branches;
next	1.20;

1.20
date	2002.11.14.16.53.55;	author suan;	state Exp;
branches;
next	1.19;

1.19
date	2002.11.14.16.48.12;	author suan;	state Exp;
branches;
next	1.18;

1.18
date	2002.11.13.01.42.39;	author suan;	state Exp;
branches;
next	1.17;

1.17
date	2002.11.12.21.17.30;	author suan;	state Exp;
branches;
next	1.16;

1.16
date	2002.11.12.20.08.51;	author suan;	state Exp;
branches;
next	1.15;

1.15
date	2002.11.12.16.04.54;	author suan;	state Exp;
branches;
next	1.14;

1.14
date	2002.11.12.00.44.01;	author suan;	state Exp;
branches;
next	1.13;

1.13
date	2002.11.11.22.23.34;	author suan;	state Exp;
branches;
next	1.12;

1.12
date	2002.11.11.19.32.15;	author suan;	state Exp;
branches;
next	1.11;

1.11
date	2002.11.11.03.40.09;	author suan;	state Exp;
branches;
next	1.10;

1.10
date	2002.11.07.21.04.04;	author suan;	state Exp;
branches;
next	1.9;

1.9
date	2002.11.07.00.40.47;	author suan;	state Exp;
branches;
next	1.8;

1.8
date	2002.11.06.20.03.20;	author suan;	state Exp;
branches;
next	1.7;

1.7
date	2002.11.05.21.20.30;	author suan;	state Exp;
branches;
next	1.6;

1.6
date	2002.10.01.17.43.44;	author suan;	state Exp;
branches;
next	1.5;

1.5
date	2002.10.01.16.55.22;	author suan;	state Exp;
branches;
next	1.4;

1.4
date	2002.09.30.22.25.22;	author suan;	state Exp;
branches;
next	1.3;

1.3
date	2002.09.30.21.04.24;	author suan;	state Exp;
branches;
next	1.2;

1.2
date	2002.09.30.18.03.34;	author suan;	state Exp;
branches;
next	1.1;

1.1
date	2002.09.27.17.28.44;	author suan;	state Exp;
branches;
next	;


desc
@CFG data structures.
@


1.139
log
@Added -mbu-intra-iref flag to collect iref in addition
to gref, and to just use iref for MBU analysis -- hopefully
will lead to smaller facts and faster analysis.
Also: observed that "gmodref_skip_locals" has been set
all along (for ran?), so mbu may not have been correct??
Fixed --- at least partially, for mbu --- I think...
@
text
@#include <ctype.h>
#include <stdio.h>
#include <stdlib.h> // for strtoul
#include <string.h>
#include "ao.h"
#include "ecr.h"
#include "id.h"
#include "cfg.h"
#include "tca.h" // for TCA_BUF_SIZE
#include "flags.h" // for flag_verbose, flag_use_bblocks, flag_range_filter_*_backedge
#include "diag.h" // for timer

//----------------------------------
// AID
//----------------------------------

AID AID::zero(0,0);
suco_llist<const char *> AID::filestemlist;

//- assign and write map of number to function name
void AID::writeFileStemMap(FILE * outf)
{
  int fnid = 0;
  suco_iterator<const char *> fli(AID::filestemlist);
  while(fli.Iterate()){
    fnid++;
    fprintf(outf, "! @@ %d %s\n", fnid, fli.Current());
  }
}

const char * AID::lookupFileStem()
{
  const char * ret = AID::filestemlist.ElementAt(this->filestem_id);
  return ret?ret:"**ERROR**";
}

//----------------------------------
// EXP DESCR
//----------------------------------

int Dependency::compare(Dependency * ldep, Dependency * rdep)
{
  return &ldep->key - &rdep->key;
}

int DependencyMap::aoset_compare(suco_set<AO *> * laos, suco_set<AO *> * raos)
{
  suco_iterator<AO *> laoi(*laos);
  suco_iterator<AO *> raoi(*raos);
  while(laoi.Iterate() & raoi.Iterate()){
    int ret = laoi.Current() - raoi.Current();
    if(ret) return ret;
  }
  return (laoi.Current() - raoi.Current());
}

//- consumes depset
void DependencyMap::addDirectedDependency(suco_set<AO *>& keyset, suco_set<AO *>& depset)
{
  suco_iterator<AO *> kaoi(keyset);
  while(kaoi.Iterate()){
    AO& key_ao = *kaoi.Current();
    bool found = false;
    //- look for key_ao's entry
    suco_iterator<Dependency *> depi(this->deps);
    while(depi.Iterate()){
      if(&depi.Current()->getKey() == &key_ao){
        found = true;
        depi.Current()->getAOs().UnionConsume(depset);
        break;
      }
    }
    if(!found){
      Dependency * newdep = new Dependency(key_ao);
      newdep->getAOs().Attach(depset);
      this->deps.Insert(newdep);
    }
  }
}

//- consumes depset
void DependencyMap::addDependencySet(suco_set<AO *>& depset)
{
  suco_set<AO *> * newset = new suco_set<AO *>;
  newset->Attach(depset);
  if(!this->aosets.Insert(newset))
    delete newset;
}

void DependencyMap::debug_dump(FILE * outf)
{
  fprintf(outf, "Directed Dependencies:\n");
  suco_iterator<Dependency *> depi(this->deps);
  while(depi.Iterate()){
    fprintf(outf, " - ");
    depi.Current()->getKey().write_string_rep(outf, true);
    fprintf(outf, " : ");
    AO::write_list_string_rep(outf, depi.Current()->getAOs(), true);
    fprintf(outf, "\n");
  }
  fprintf(outf, "Undirected Dependency Sets:\n");
  suco_iterator<suco_set<AO *> *> aosi(this->aosets);
  while(aosi.Iterate()){
    fprintf(outf, " - ");
    AO::write_list_string_rep(outf, *aosi.Current(), true);
    fprintf(outf, "\n");
  }
}

//----------------------------------
// EXP DESCR
//----------------------------------

ExpDescr::~ExpDescr()
{
   if(affecrs) delete affecrs;
   if(aliasecrs) delete aliasecrs;
}

char * ExpDescr::stringToEstr(char * str, char ** nptr)
{
  if(*str == '{'){
    char * ep;
    for(ep = str; *ep && *ep != '}'; ++ep);
    if(*ep == '}') ep++;
    else fprintf(stderr, "ExpDescr::stringToEstr: Missing end-delimiter: %s", str);
    {
      int slen = ep - str;
      char * estr = new char[slen+1];
      if(estr){
        strncpy(estr, str, slen);
        estr[slen] = '\0';
        if(nptr) *nptr = ep;
        return estr;
      } else {
        fprintf(stderr, "ExpDescr::stringToEstr: MALLOC(new) ERROR\n");
        return "@@";
      }
    }
  } else if(*str == '@@'){
    if(nptr) *nptr = str+1;
    return "@@";
  } else {
    fprintf(stderr, "ExpDescr::stringToEstr: Invalid expr-string: %s", str);
    return "@@";
  }
}

int ExpDescr::compare(ExpDescr * lex, ExpDescr * rex)
{
  int ret = strcmp(lex->estr, rex->estr);

  if(!ret){ //- estr are equal, now compare afflocs
    suco_iterator<AO *> li(lex->estr_aos);
    suco_iterator<AO *> ri(rex->estr_aos);

    while(!ret && (li.Iterate() & ri.Iterate()))
      ret = ((int)li.Current() - (int)ri.Current());

    if(!ret)
      ret = ((int)li.Current() - (int)ri.Current());
  }

  return ret;
}

//--------------------------------------
// This is the filter function to decide
// whether this is a singleton location,
// to decide e.g. strong vs weak assignment.
// - returns ao if this is a location that
//   doesn't include a union or array component.
//   (e.g. a[0], a[0].i.j) The latter is because
//   of the way we map a[0] to I <a> directly,
//   but I<a> represents all elements of the array.
//--------------------------------------
AO * ExpDescr::getSingletonLoc()
{
  AO * ret = 0;
  suco_iterator<AO *> aoi(this->getAOs());
  while(aoi.Iterate()){
    AO& ao = *aoi.Current();
    if(ao.isLoc()){
      if(ret) return 0; //-- more than one locs
      ret = &ao;
    } else if(!ao.isVal()){
      return 0; //-- non-val and non-loc
    }
  }
  if(!ret) return 0;

  //- at this point, ret is a singleton
  //- now check for array or union component in access path
  AO * temp_ao = ret;
  while(1){
    TCtype * sty = temp_ao->getStaticType();
    if(sty && sty->getKind() == TCtype::tcArray){
      return 0;
    } else if(temp_ao->getKind() == AO::aoUDot || (sty && sty->getKind() == TCtype::tcUnion)){
      return 0;
    } else if(temp_ao->getKind() == AO::aoSDot){
      temp_ao = &((AOSDot *)temp_ao)->getParent();
    } else { //- end of the line: return
      return ret;
    }
  }
}

void ExpDescr::instantiateAffEcrs()
{
  //- instantiate affecrs: the ECRs of deref-aos deref'ed one level
  if(!this->affecrs){
    this->affecrs = new suco_set<ECR *>;
    suco_iterator<AO *> aoi(this->getAOs());
    while(aoi.Iterate()){
      AO * deref_ao = aoi.Current()->derefOneLevel();
      if(deref_ao && deref_ao->isRef() && !deref_ao->isVal()){
        this->affecrs->Union(deref_ao->getECR().getAliasECRs());
      }
    }
  }
}

bool ExpDescr::affLocsIntersects(suco_set<AO *>& aoset)
{
  //- a. check estr_aos: Ids which directly occur in the expression
  if(aoset.Intersects(this->getEstrAOs())){
    return true;
  }

  //- b. check aliases of deref-aos
  if(!this->affecrs)
    this->instantiateAffEcrs();

  if(this->affecrs->IsEmpty()){ //- optimize if nothing to check
    //- translate aoset -> ecrset 
    suco_set<ECR *> ecrset;

    suco_iterator<AO *> aoi(aoset);
    while(aoi.Iterate()){
      AO& ao = *aoi.Current();
      if(!ao.isVal())
        ecrset.Insert(&ao.getECR()); //- omit aliases!?
    }

    return this->affecrs->Intersects(ecrset);

  } else return false;
}

bool ExpDescr::affLocsIntersects(suco_set<ECR *>& ecrset)
{
  //- a. check estr_aos
  suco_iterator<AO *> aoi(this->getEstrAOs());
  while(aoi.Iterate()){
    AO& ao = *aoi.Current();
    if(!ao.isVal() && ecrset.Contains(&ao.getECR())){
      return true;
    }
  }  

  //- b. check affecrs
  if(!this->affecrs)
    this->instantiateAffEcrs();

  return this->affecrs->Intersects(ecrset);
}

//- include also this->estr_aos not covered by this->aos
void ExpDescr::collectAffectingAliasLocECRs(suco_set<ECR *>& eset)
{
  suco_iterator<AO *> aoi(this->getAOs());
  while(aoi.Iterate()){
    aoi.Current()->getECR().collectAliasECRs(eset, true); //- true=follow de-starred aos' aliases
  }
  suco_iterator<AO *> eaoi(this->getEstrAOs());
  while(eaoi.Iterate()){
    eaoi.Current()->getECR().collectAliasECRs(eset, true); //- true=follow de-starred aos' aliases
  }
  ECR::filterLocArgRet(eset);
}

//- Collect aos on which this ExpDescr depend:
//  namely, the union of this->aos and this->estr_aos,
//  less aos in this->estr_aos for which this->aos
//  contains its "addrof".
//  If uncaptured=true, then only collect those that
//  are not in this->aos.
//  ~> this arises in array indexing (A[i]), in which
//	this->aos is just "op A" and not "op i".
void ExpDescr::collectDependencies(suco_set<AO *>& dep, bool uncaptured)
{
  //- compute addrof_filter: { x | "addrof x" in this->aos }
  suco_set<AO *> addrof_filter;
  suco_iterator<AO *> taoi(this->getAOs());
  while(taoi.Iterate()){
    if(taoi.Current()->getKind() == AO::aoAddrOf){
      addrof_filter.Insert(&((AOAddrOf *)taoi.Current())->getTarget());
    }
  }

  if(uncaptured){ //- collect only uncaptured dependencies
    suco_set<ECR *>& alias_ecrs = this->getAliasECRs();
    suco_iterator<AO *> eaoi(this->getEstrAOs());
    while(eaoi.Iterate()){
      if(!alias_ecrs.Contains(&eaoi.Current()->getECR()) &&
	 !addrof_filter.Contains(eaoi.Current())){
        dep.Insert(eaoi.Current());
      }
    }
  } else { //- collect all dependencies
    dep.Union(this->getAOs());
    suco_iterator<AO *> eaoi(this->getEstrAOs());
    while(eaoi.Iterate()){
      if(!addrof_filter.Contains(eaoi.Current())){
        dep.Insert(eaoi.Current());
      }
    }
  }
}

suco_set<ECR *>& ExpDescr::getAliasECRs()
{
  //- check cache; if empty, compute
  if(!this->aliasecrs){

    this->aliasecrs = new suco_set<ECR *>;

    suco_iterator<AO *> aoi(this->getAOs());
    while(aoi.Iterate()){
      AO& ao = *aoi.Current();
      if(!ao.isVal()){
        if(ao.isLoc()) this->aliasecrs->Insert(&ao.getECR()); //- slight optimization: improves precision
								 //  TODO: however, not safe w.r.t. unions?
        else this->aliasecrs->Union(ao.getECR().getAliasECRs());
      }
    }
  }

  return *this->aliasecrs;
}

//----------------------------------
// LOC SET
//----------------------------------

LocSet * const CFGnode::ALL_AOS = (LocSet *)1;

//TODO: using AO::isLocArgRet to filter --
//      for arg/ret, should only filter "[FR] X I <>" and not "[FR] D <>"?

int ECRlocSet::numAOs()
{
  int ret = 0;
  suco_iterator<ECR *> ei(this->ecrset);
  while(ei.Iterate()){
    suco_iterator<AO *> aoi(ei.Current()->getAOset());
    while(aoi.Iterate()){
      if(aoi.Current()->isLocArgRet()){
        ret++;
      }
    }
  }
  return ret;
}

bool ECRlocSet::Insert(AO& ao)
{
  return ao.isLocArgRet() && this->ecrset.Insert(&ao.getECR());
}
 
bool ECRlocSet::Contains(AO& ao)
{
  return this->ecrset.Contains(&ao.getECR());
}

void ECRlocSet::AbsorbConsume(suco_set<ECR *>& ecrset)
{
  //- filter out non-Loc'ed ecrs
  suco_iterator<ECR *> ei(ecrset);
  while(ei.Iterate()){
    bool has_loc = false;
    suco_iterator<AO *> ai(ei.Current()->getAOset());
    while(ai.Iterate()){
      if(ai.Current()->isLocArgRet()){
        has_loc = true;
        break;
      }
    }
    if(!has_loc){
      ei.DeleteCurrent();
    }
  }
  this->ecrset.UnionConsume(ecrset);
}

void ECRlocSet::addToAOset(suco_set<AO *>& aoset)
{
  suco_iterator<ECR *> ei(this->ecrset);
  while(ei.Iterate()){
    aoset.Union(ei.Current()->getAOset());
  }
  //- filter out non-location AOs
  suco_iterator<AO *> ai(aoset);
  while(ai.Iterate()){
    if(!ai.Current()->isLoc())
      ai.DeleteCurrent();
  }
}
 
void ECRlocSet::debug_dump(FILE * outf)
{
  suco_iterator<ECR *> ecri(this->ecrset);
  while(ecri.Iterate())
    AO::write_list_string_rep(outf, ecri.Current()->getAOset(), true);
  fprintf(outf, "\n");
}

bool ECRlocSet::Intersects(suco_set<AO *>& aoset)
{
  suco_iterator<AO *> aoi(aoset);
  while(aoi.Iterate()){
    if(this->ecrset.Contains(&aoi.Current()->getECR())){
      return true;
    }
  }
  return false;
}

bool AOlocSet::Intersects(suco_set<ECR *>& ecrset)
{
  suco_iterator<AO *> aoi(this->aoset);
  while(aoi.Iterate()){
    if(ecrset.Contains(&aoi.Current()->getECR())){
      return true;
    }
  }
  return false;
}

void ECRlocSet::writeIntersectingAOs(BaseLocSet& lset, suco_set<AO *>& aoset)
{
  lset.addToAOset(aoset);
  suco_set<AO *> tmp;
  this->addToAOset(tmp);
  aoset.Intersect(tmp);
}

void AOlocSet::writeIntersectingAOs(BaseLocSet& lset, suco_set<AO *>& aoset)
{
  lset.addToAOset(aoset);
  aoset.Intersect(this->aoset);
}

void AOlocSet::AbsorbConsume(suco_set<ECR *>& ecrset)
{
  suco_iterator<ECR *> ecri(ecrset);
  while(ecri.Iterate()){
    this->aoset.Union(ecri.Current()->getAOset());
  }
  //- filter out non-loc AOs
  suco_iterator<AO *> aoi(this->aoset);
  while(aoi.Iterate()){
    if(!aoi.Current()->isLoc()){
      aoi.DeleteCurrent();
    }
  }
}

void AOlocSet::addToEcrSet(suco_set<ECR *>& ecrset)
{
  suco_iterator<AO *> aoi(this->aoset);
  while(aoi.Iterate()){
    ecrset.Insert(&aoi.Current()->getECR());
  }
}

//----------------------------------
// READ FUNCTIONS
//----------------------------------

PgmExpr * PgmExpr::read(InputState& is, char * buf, PgmStmt * parent)
{
  PgmExpr * df = 0;

  if(!buf[0]) fgets(buf, TCA_BUF_SIZE, is.inf);
  int fsid = (parent)?(parent->getParentFunction().getFileStemId()):0;

  if(buf[0] == mPfx){
    switch(buf[2]){
      case mCall: {
        if(!parent){
          fprintf(stderr, "Reading call node with no parent PgmStmt!\n");
        } else {
          char * cp = &buf[4];
          int aidno = strtoul(cp, &cp, 10);
          suco_set<AO *>& faos = (suco_set<AO *>&) AO::stringToAOlist(true, cp, &cp, is.aidmap, is.pidmap, is.values);
          int nargs = strtoul(cp, &cp, 10);
          PExprCall& dfc = *new PExprCall(AID(fsid,aidno), faos, nargs, parent);
          df = &dfc;
          for(int i = 0; i < nargs; ++i){
            int argaid = strtoul(cp, &cp, 10);
            suco_set<AO *>& argaos = (suco_set<AO *>&) AO::stringToAOlist(true, cp, &cp, is.aidmap, is.pidmap, is.values);
            suco_llist<AO *>& argestr_aos = AO::stringToAOlist(false, cp, &cp, is.aidmap, is.pidmap, is.values);
            while(*cp && isspace(*cp)) cp++;
            char * argestr = ExpDescr::stringToEstr(cp, &cp);
            dfc.args[i] = new PExprArg(AID(fsid, argaid), argaos, argestr_aos, argestr);
          }
        }
      } break;
      case mAssign: {
        char * cp = &buf[4];
        int aidno = strtoul(cp, &cp, 10);
        suco_set<AO *>& e1aos = (suco_set<AO *>&) AO::stringToAOlist(true, cp, &cp, is.aidmap, is.pidmap, is.values);
        suco_set<AO *>& e2aos = (suco_set<AO *>&) AO::stringToAOlist(true, cp, &cp, is.aidmap, is.pidmap, is.values);
        suco_llist<AO *>& e1str_aos = AO::stringToAOlist(false, cp, &cp, is.aidmap, is.pidmap, is.values);
        suco_llist<AO *>& e2str_aos = AO::stringToAOlist(false, cp, &cp, is.aidmap, is.pidmap, is.values);
        while(*cp && isspace(*cp)) cp++;
        char * e1str = ExpDescr::stringToEstr(cp, &cp);
        char * e2str = ExpDescr::stringToEstr(cp, &cp);
        df = new PExprAssign(AID(fsid,aidno), e1aos, e1str_aos, e1str, e2aos, e2str_aos, e2str, parent);
      } break;
      case mPredicate: {
        enum PExprPredicate::prKind prk = PExprPredicate::prStmt;
        switch(buf[4]){
          case mPrAnd:	  prk = PExprPredicate::prAnd; break;
          case mPrOr:	  prk = PExprPredicate::prOr; break;
          case mPrQC:	  prk = PExprPredicate::prQC; break;
          case mPrStmt:	  prk = PExprPredicate::prStmt; break;
          case mPrSwitch: prk = PExprPredicate::prSwitch; break;
          default :
            fprintf(stderr, "Invalid Predicate Kind (%c) in input line: %s\n", buf[4], buf);
            return 0;
        }
        char * cp = &buf[6];
        int aidno = strtoul(cp, &cp, 10);
        suco_llist<AO *>& estr_aos = AO::stringToAOlist(false, cp, &cp, is.aidmap, is.pidmap, is.values);
        while(*cp && isspace(*cp)) cp++;
        char * estr = ExpDescr::stringToEstr(cp, &cp);
        df = new PExprPredicate(AID(fsid,aidno), estr_aos, estr, prk, parent);
      } break;
      case mFormal: {
        char * cp = &buf[4];
        int argno = strtoul(cp, &cp, 10);
        int pidno = strtoul(cp, &cp, 10);
        ID * pid = is.pidmap.lookup(pidno);
        if(pid) df = new PExprDecl(pid->get_AOId(false), fsid, PExprDecl::dFormal, parent, false, argno);
        else fprintf(stderr, "Invalid Pid (%d) read for CFG formal node\n", pidno);
      } break;
      case mVerify: {
        enum PExprVerify::vtKind vtk = PExprVerify::vtNone;
        enum PExprVerify::vpKind vpk = PExprVerify::vpNone;
        switch(buf[4]){
          case mVTag:	  vtk = PExprVerify::vtTag;  vpk = PExprVerify::vpNone; break;
          case mVTagPtr:  vtk = PExprVerify::vtTag;  vpk = PExprVerify::vpPtr;  break;
          case mVTagPtrW: vtk = PExprVerify::vtTag;  vpk = PExprVerify::vpPtrW; break;
          case mVRhs:	  vtk = PExprVerify::vtRhs;  vpk = PExprVerify::vpNone; break;
          case mVRhsPtr:  vtk = PExprVerify::vtRhs;  vpk = PExprVerify::vpPtr;  break;
          case mVPtr:	  vtk = PExprVerify::vtNone; vpk = PExprVerify::vpPtr;  break;
          case mVPtrW:	  vtk = PExprVerify::vtNone; vpk = PExprVerify::vpPtrW; break;
          default :
            fprintf(stderr, "Invalid Verify Kind (%c) in input line: %s\n", buf[4], buf);
            return 0;
        }
        char * cp = &buf[6];
        int aidno = strtoul(cp, &cp, 10);
        suco_set<AO *>& aos = (suco_set<AO *>&) AO::stringToAOlist(true, cp, &cp, is.aidmap, is.pidmap, is.values);
        suco_llist<AO *>& estr_aos = AO::stringToAOlist(false, cp, &cp, is.aidmap, is.pidmap, is.values);
        while(*cp && isspace(*cp)) cp++;
        char * estr = ExpDescr::stringToEstr(cp, &cp);
        df = new PExprVerify(vtk, vpk, AID(fsid,aidno), aos, estr_aos, estr, parent);
      } break;
      case mLocalDecl: {
        char * cp = &buf[4];
        bool iszeroed = false;
        if(*cp == 'z'){
          iszeroed = true;
          cp += 2;
        }
        int pidno = strtoul(cp, &cp, 10);
        ID * pid = is.pidmap.lookup(pidno);
        if(pid) df = new PExprDecl(pid->get_AOId(iszeroed), fsid, PExprDecl::dLocal, parent, iszeroed);
        else fprintf(stderr, "Invalid Pid (%d) read for CFG local-decl node\n", pidno);
      } break;
      case mStaticDecl: {
        char * cp = &buf[4];
        int pidno = strtoul(cp, &cp, 10);
        ID * pid = is.pidmap.lookup(pidno);
        if(pid) df = new PExprDecl(pid->get_AOId(true), fsid, PExprDecl::dStatic, parent, true);
        else fprintf(stderr, "Invalid Pid (%d) read for CFG static-decl node\n", pidno);
      } break;
      case mMallocDecl: {
        char * cp = &buf[4];
        bool iszeroed = false;
        bool isalloca = false;
        if(*cp == 'z'){
          iszeroed = true;
          cp += 2;
        } else if(*cp == 'a'){
          isalloca = true;
          cp += 2;
        }
        int aidno = strtoul(cp, &cp, 10);
        ID * aid = is.aidmap.lookup(aidno);
        suco_set<AO *>& eaos = (suco_set<AO *>&) AO::stringToAOlist(true, cp, &cp, is.aidmap, is.pidmap, is.values);
        suco_llist<AO *>& estr_aos = AO::stringToAOlist(false, cp, &cp, is.aidmap, is.pidmap, is.values);
        while(*cp && isspace(*cp)) cp++;
        char * estr = ExpDescr::stringToEstr(cp, &cp);
        if(aid) df = new PExprDecl(aid->get_AOMalloc(isalloca,iszeroed), fsid, PExprDecl::dMalloc, parent, iszeroed, 0,
					new ExpDescr(estr_aos, estr, eaos));
        else fprintf(stderr, "Invalid Aid (%d) read for CFG malloc-decl node\n", aidno);
      } break;
      case mStart: {
        switch(buf[4]){
          case mParallel: {
            df = &PExprParallel::read(is, buf, parent);
          } break;
          case mBranch: {
            df = &PExprBranch::read(is, buf, parent);
          } break;
          default: {
            // not valid PgmExpr; return 0
          } break;
        }
      } break;
      case mNext:
      case mEnd: {
        // end of PgmExpr list; return 0
      } break;
      default: {
        fprintf(stderr, "PgmExpr::read: invalid node ignored: %s", buf);
      } break;
    }
  } else fprintf(stderr, "PgmExpr::read: bad prefix on line %s", buf);

  return df;
}

void PgmExpr::readlist(InputState& is, char * buf, suco_llist<PgmExpr *>& nodelist, PgmStmt * parent)
{
  while(!feof(is.inf)){
    PgmExpr * df = PgmExpr::read(is,buf,parent);
    if(df) nodelist.Append(df);
    else break; // non-node item; break out
    buf[0] = 0;
  }
}

PExprParallel& PExprParallel::read(InputState& is, char * buf, PgmStmt * parent)
{
  PExprParallel * df = new PExprParallel(parent);

  if(!buf[0]) fgets(buf, TCA_BUF_SIZE, is.inf);

  //-- process node start header: read numlists (redundant)
  if(buf[0] == mPfx && buf[2] == mStart && buf[4] == mParallel){
    char * cp = &buf[6];
    int numlists = strtoul(cp, &cp, 10);

    //-- process nodelists
    int countlists = 0;
    fgets(buf, TCA_BUF_SIZE, is.inf);
    while(!feof(is.inf) && buf[0] == mPfx && buf[2] == mNext && buf[4] == mParallel){
      suco_llist<PgmExpr *>& nodelist = *new suco_llist<PgmExpr *>;
      buf[0] = 0;
      PgmExpr::readlist(is, buf, nodelist, parent);
      df->nodelists.Append(&nodelist);
      countlists++;
    }

    // (assert end marker)
    if(buf[0] != mPfx || buf[2] != mEnd || buf[4] != mParallel)
      fprintf(stderr, "PExprParallel::read: expecting end marker on line %s", buf);
    // (assert numlists)
    if(countlists != numlists)
      fprintf(stderr, "PExprParallel::read: numlist mismatch: header = %d, count = %d\n", numlists, countlists);

  } else fprintf(stderr, "PExprParallel::read: bad start marker on line %s", buf);

  return *df;
}

PExprBranch& PExprBranch::read(InputState& is, char * buf, PgmStmt * parent)
{
  PExprBranch * df = new PExprBranch(parent);

  if(!buf[0]) fgets(buf, TCA_BUF_SIZE, is.inf);

  //-- process node start header: assert numlists
  if(buf[0] != mPfx || buf[2] != mStart || buf[4] != mBranch
     || strtoul(buf+6, 0, 10) != 3)
    fprintf(stderr, "PExprBranch::read: bad start marker on line %s", buf);

  //-- process predicate nodelist
  fgets(buf, TCA_BUF_SIZE, is.inf);
  if(buf[0] == mPfx && buf[2] == mNext && buf[4] == mBranch){
    buf[0] = 0;
    suco_llist<PgmExpr *> prednodelist;
    PgmExpr::readlist(is, buf, prednodelist, parent);
    if(prednodelist.Length() == 1){
      if(prednodelist.Head()->getKind() == PgmExpr::fPredicate)
        df->prednode = (PExprPredicate *) prednodelist.Head();
      else fprintf(stderr, "PExprBranch::read: prednode is not a predicate node.\n");
    } else if(prednodelist.Length() > 1)
      fprintf(stderr, "PExprBranch::read: prednode list has %d elements (should be <=1)\n", prednodelist.Length());
  }
  else fprintf(stderr, "PExprBranch::read: expecting predicate list in %s", buf );

  //-- process true nodelist
  if(!buf[0]) fgets(buf, TCA_BUF_SIZE, is.inf);
  if(buf[0] == mPfx && buf[2] == mNext && buf[4] == mBranch){
    buf[0] = 0;
    PgmExpr::readlist(is, buf, df->tnodelist, parent);
  }
  else fprintf(stderr, "PExprBranch::read: expecting true list in %s", buf );

  //-- process false nodelist
  if(!buf[0]) fgets(buf, TCA_BUF_SIZE, is.inf);
  if(buf[0] == mPfx && buf[2] == mNext && buf[4] == mBranch){
    buf[0] = 0;
    PgmExpr::readlist(is, buf, df->fnodelist, parent);
  }
  else fprintf(stderr, "PExprBranch::read: expecting false list in %s", buf );

  if(!buf[0]) fgets(buf, TCA_BUF_SIZE, is.inf);
  // (assert end marker)
  if(buf[0] != mPfx || buf[2] != mEnd || buf[4] != mBranch)
    fprintf(stderr, "PExprBranch::read: expecting end marker on line %s", buf);

  return *df;
}

PgmStmt& PgmStmt::read(InputState& is, CFGfunction& par, char * buf)
{
  PgmStmt * cfgn = new PgmStmt(par);

  if(!buf[0]) fgets(buf, TCA_BUF_SIZE, is.inf);

  //-- process node start header: read aid and numlabels
  if(buf[0] == mPfx && buf[2] == mStart && buf[4] == mNode){
    char * cp = &buf[6];

    cfgn->aid.aid = strtoul(cp, &cp, 10);
    cfgn->aid.filestem_id = par.getFileStemId();
    cfgn->nlabels = strtoul(cp, &cp, 10);

    //-- process labels
    if(cfgn->nlabels){
      cfgn->labels = new char * [cfgn->nlabels];
      for(int i = 0; i < cfgn->nlabels; ++i){
        fgets(buf, TCA_BUF_SIZE, is.inf);
        char * cp = &buf[4];
        if(buf[0] == mPfx && buf[2] == mLabel
           && cfgn->aid.aid == (int) strtoul(cp, &cp, 10)){ // asserts, and advances cp!
          while(isspace(*cp)) ++cp;
          int s = strlen(cp) - 1;
          while(isspace(cp[s])) --s;
          cp[++s] = 0;
          cfgn->labels[i] = new char[s+1];
          strcpy(cfgn->labels[i], cp);
        } else fprintf(stderr, "PgmStmt::read: bad label marker on line %s", buf);
      }
    }

    //-- process node next (assert)
    {
      fgets(buf, TCA_BUF_SIZE, is.inf);
      if(buf[0] != mPfx || buf[2] != mNext || buf[4] != mNode)
        fprintf(stderr, "PgmStmt::read: next assertion failed on line %s", buf);
    }

    //-- process nodes, until node end
    fgets(buf, TCA_BUF_SIZE, is.inf);
    while(!feof(is.inf) && (buf[0] != mPfx || buf[2] != mEnd || buf[4] != mNode)){
      cfgn->exprlist.Append(PgmExpr::read(is, buf, cfgn));
      fgets(buf, TCA_BUF_SIZE, is.inf);
    }

  } else fprintf(stderr, "PgmStmt::read: bad start marker on line %s", buf);

  return *cfgn;
}

void PgmStmt::readlist(InputState& is, CFGfunction& par, char * buf, PgmStmt *& current, suco_llist<PgmStmt *>& nodelist)
{
  if(!buf[0]) fgets(buf, TCA_BUF_SIZE, is.inf);
/**//*SY:see if following condition is preferable?*/
  while(!feof(is.inf)){ // && (buf[0] != mPfx || (buf[2] != mNext && buf[2] != mEnd))){
    if(!PgmStmt::readentry(is,par,buf,current,nodelist))
      return;
    fgets(buf, TCA_BUF_SIZE, is.inf);
  }
}

bool PgmStmt::readentry(InputState& is, CFGfunction& par, char * buf, PgmStmt *& current, suco_llist<PgmStmt *>& nodelist)
{
  if(!buf[0]) fgets(buf, TCA_BUF_SIZE, is.inf);

  int fsid = par.getFileStemId();

  if(buf[0] == mPfx){
    switch(buf[2]){
      case mStart: {
	switch(buf[4]){
          case mWhile: {

	    //-- predicate node
	    buf[0] = 0;
	    PgmStmt& pred_node = PgmStmt::read(is, par, buf);
	    pred_node.annot.kind = Annot::aWhile;

	    //-- while next marker / verify
	    fgets(buf, TCA_BUF_SIZE, is.inf);
	    if(buf[0] != mPfx || buf[2] != mNext || buf[4] != mWhile)
	      fprintf(stderr, "PgmStmt::readentry: expecting while next on line %s", buf);

	    //-- attach pred_node's predecessor, set current, add to nodelist
	    if(current) current->addSuccessor(pred_node);
	    pred_node.initSuccsCount(2);
	    current = &pred_node;
	    nodelist.Append(&pred_node);

	    //-- statements (until while end marker)
	    buf[0] = 0;
	    suco_llist<PgmStmt *> snodelist;
	    PgmStmt * scurrent = &pred_node;
	    PgmStmt::readlist(is, par, buf, scurrent, snodelist);

	    //-- while end marker / verify
	    if(buf[0] != mPfx || buf[2] != mEnd || buf[4] != mWhile)
	      fprintf(stderr, "PgmStmt::readentry: expecting while end on line %s", buf);

	    if(snodelist.IsEmpty()){ // empty while-body: self-loop

	      pred_node.initPredsCount(2);
	      pred_node.addSuccessor(pred_node);

	    } else {

	      //-- collect break and continue nodes
	      suco_llist<PgmStmt *> continuenodes;
	      suco_llist<PgmStmt *> breaknodes;

	      suco_iterator<PgmStmt *> sni(snodelist);
	      while(sni.Iterate()){
	        PgmStmt * n = sni.Current();
		if(n->annot.kind == Annot::aContinue && !n->succs)
		  continuenodes.Append(n);
		if(n->annot.kind == Annot::aBreak && !n->succs)
		  breaknodes.Append(n);
	      }

	      //-- attach statement exit / continue nodes to pred_node
	      if(continuenodes.Length()){
	        //-- add scurrent (if non-null) to continuenodes
	        if(scurrent) continuenodes.Append(scurrent);

	        pred_node.initPredsCount(1 + continuenodes.Length());
	        suco_iterator<PgmStmt *> cni(continuenodes);
	        while(cni.Iterate()) cni.Current()->addSuccessor(pred_node);

	      } else {

	        pred_node.initPredsCount(2);
	        if(scurrent) scurrent->addSuccessor(pred_node);

	      }

	      //-- attach breaks, if any, to dummy outnode
	      if(breaknodes.Length()){

	        //-- create dummy outnode
	        PgmStmt * outnode = new PgmStmt(par);
		outnode->annot.kind = Annot::aOutNode;
	        snodelist.Append(outnode);

	        pred_node.addSuccessor(*outnode);
	        current = outnode;

	        outnode->initPredsCount(1 + breaknodes.Length());
	        suco_iterator<PgmStmt *> bni(breaknodes);
	        while(bni.Iterate()) bni.Current()->addSuccessor(*outnode);
	      }

	      //-- attach into nodelist; note: can only do this after we've "processed" snodelist
	      nodelist.Attach(snodelist);
	    }

          } break;

          case mDoWhile: {

	    //-- predicate node
	    buf[0] = 0;
	    PgmStmt& pred_node = PgmStmt::read(is, par, buf);
	    pred_node.annot.kind = Annot::aDoWhile;

	    //-- while next marker / verify
	    fgets(buf, TCA_BUF_SIZE, is.inf);
	    if(buf[0] != mPfx || buf[2] != mNext || buf[4] != mDoWhile)
	      fprintf(stderr, "PgmStmt::readentry: expecting do-while next on line %s", buf);

	    //-- statements (until do-while end marker)
	    buf[0] = 0;
	    suco_llist<PgmStmt *> snodelist;
	    PgmStmt::readlist(is, par, buf, current, snodelist);

	    //-- while end marker / verify
	    if(buf[0] != mPfx || buf[2] != mEnd || buf[4] != mDoWhile)
	      fprintf(stderr, "PgmStmt::readentry: expecting do-while end on line %s", buf);

	    //-- attach pred_node's predecessor, set current
	    if(current) current->addSuccessor(pred_node);
	    pred_node.initSuccsCount(2);
	    current = &pred_node;

	    if(snodelist.IsEmpty()){ // empty do-while body: self-loop

	      pred_node.initPredsCount(2);
	      pred_node.addSuccessor(pred_node);
	      nodelist.Append(&pred_node);

	    } else {

	      //-- attach pred_node to snodelist.head
	      snodelist.Head()->initPredsCount(2);
	      pred_node.addSuccessor(*snodelist.Head());

	      //-- collect break and continue nodes
	      suco_llist<PgmStmt *> continuenodes;
	      suco_llist<PgmStmt *> breaknodes;

	      suco_iterator<PgmStmt *> sni(snodelist);
	      while(sni.Iterate()){
	        PgmStmt * n = sni.Current();
		if(n->annot.kind == Annot::aContinue && !n->succs)
		  continuenodes.Append(n);
		if(n->annot.kind == Annot::aBreak && !n->succs)
		  breaknodes.Append(n);
	      }

	      //-- attach into nodelist; note: can only do this after we've "processed" snodelist
	      nodelist.Attach(snodelist);

	      //-- for the sake of debugging readability, will append nodes in "expected" order
	      nodelist.Append(&pred_node);

	      //-- attach continue nodes, if any, to pred_node
	      if(continuenodes.Length()){

	        pred_node.initPredsCount(1 + continuenodes.Length());
	        suco_iterator<PgmStmt *> cni(continuenodes);
	        while(cni.Iterate()) cni.Current()->addSuccessor(pred_node);

	      }

	      //-- attach breaks, if any, to dummy outnode
	      if(breaknodes.Length()){

	        //-- create dummy outnode
	        PgmStmt * outnode = new PgmStmt(par);
		outnode->annot.kind = Annot::aOutNode;
	        nodelist.Append(outnode);

	        outnode->initPredsCount(1 + breaknodes.Length());

	        pred_node.addSuccessor(*outnode);
	        current = outnode;

	        suco_iterator<PgmStmt *> bni(breaknodes);
	        while(bni.Iterate()) bni.Current()->addSuccessor(*outnode);
	      }
	    }

          } break;

          case mFor: {

	    //-- node1
	    buf[0] = 0;
	    PgmStmt& node1 = PgmStmt::read(is, par, buf);
	    node1.annot.kind = Annot::aFor;

	    //-- node2
	    buf[0] = 0;
	    PgmStmt& node2 = PgmStmt::read(is, par, buf);

	    //-- node3
	    buf[0] = 0;
	    PgmStmt& node3 = PgmStmt::read(is, par, buf);

	    //-- for next marker / verify
	    fgets(buf, TCA_BUF_SIZE, is.inf);
	    if(buf[0] != mPfx || buf[2] != mNext || buf[4] != mFor)
	      fprintf(stderr, "PgmStmt::readentry: expecting for next on line %s", buf);

	    //-- attach node1's predecessor, node1 to node 2, node 3 to node 2,
	    //   set current, add to nodelist
	    if(current) current->addSuccessor(node1);
	    node1.addSuccessor(node2);
	    node2.initPredsCount(2);
	    node2.initSuccsCount(2);
	    node3.addSuccessor(node2);
	    nodelist.Append(&node1);
	    nodelist.Append(&node2);
	    nodelist.Append(&node3);
	    current = &node2;

	    //-- statements, until for end marker
	    buf[0] = 0;
	    suco_llist<PgmStmt *> snodelist;
	    PgmStmt * scurrent = &node2;
	    PgmStmt::readlist(is, par, buf, scurrent, snodelist);

	    //-- for end marker / verify
	    if(buf[0] != mPfx || buf[2] != mEnd || buf[4] != mFor)
	      fprintf(stderr, "PgmStmt::readentry: expecting for end on line %s", buf);

	    if(snodelist.IsEmpty()){ // empty for-body: link node2 to node3

	      node2.addSuccessor(node3);

	    } else {

	      //-- collect break and continue nodes
	      suco_llist<PgmStmt *> continuenodes;
	      suco_llist<PgmStmt *> breaknodes;

	      suco_iterator<PgmStmt *> sni(snodelist);
	      while(sni.Iterate()){
	        PgmStmt * n = sni.Current();
		if(n->annot.kind == Annot::aContinue && !n->succs)
		  continuenodes.Append(n);
		if(n->annot.kind == Annot::aBreak && !n->succs)
		  breaknodes.Append(n);
	      }

	      //-- attach statement exit / continue nodes to node3
	      if(continuenodes.Length()){
	        //-- add scurrent (if non-null) to continuenodes
	        if(scurrent) continuenodes.Append(scurrent);

	        node3.initPredsCount(continuenodes.Length());
	        suco_iterator<PgmStmt *> cni(continuenodes);
	        while(cni.Iterate()) cni.Current()->addSuccessor(node3);

	      } else {

	        if(scurrent){
	          node3.initPredsCount(2);
 		  scurrent->addSuccessor(node3);
		}

	      }

	      //-- attach breaks, if any, to dummy outnode
	      if(breaknodes.Length()){

	        //-- create dummy outnode
	        PgmStmt * outnode = new PgmStmt(par);
		outnode->annot.kind = Annot::aOutNode;
	        snodelist.Append(outnode);

	        node2.addSuccessor(*outnode);
	        current = outnode;

	        outnode->initPredsCount(1 + breaknodes.Length());
	        suco_iterator<PgmStmt *> bni(breaknodes);
	        while(bni.Iterate()) bni.Current()->addSuccessor(*outnode);
	      }

	      //-- attach into nodelist; note: can only do this after we've "processed" snodelist
	      nodelist.Attach(snodelist);
	    }

          } break;

          case mIf: {

	    //-- predicate node
	    buf[0] = 0;
	    PgmStmt& pred_node = PgmStmt::read(is, par, buf);
	    pred_node.annot.kind = Annot::aIf;

	    //-- attach pred_node's predecessor
	    if(current) current->addSuccessor(pred_node);
	    pred_node.initSuccsCount(2);
	    nodelist.Append(&pred_node);

	    //-- if next marker / verify
	    fgets(buf, TCA_BUF_SIZE, is.inf);
	    if(buf[0] != mPfx || buf[2] != mNext || buf[4] != mIf)
	      fprintf(stderr, "PgmStmt::readentry: failed verify if next on line %s", buf);

	    //-- true statements, until if next marker
	    buf[0] = 0;
	    current = &pred_node;
	    PgmStmt::readlist(is, par, buf, current, nodelist);

	    //-- create dummy exit node; connect from current
	    PgmStmt * outnode = new PgmStmt(par);
	    outnode->annot.kind = Annot::aOutNode;
	    outnode->initPredsCount(2);
	    if(current) current->addSuccessor(*outnode);

	    //-- if next marker
	    if(buf[0] != mPfx || buf[2] != mNext || buf[4] != mIf)
	      fprintf(stderr, "PgmStmt::readentry: expecting if next on line %s", buf);

	    //-- false statements, until if end marker
	    buf[0] = 0;
	    current = &pred_node; // reset current
	    PgmStmt::readlist(is, par, buf, current, nodelist);

	    //-- connect current to outnode
	    if(current) current->addSuccessor(*outnode);

	    //-- if end marker
	    if(buf[0] != mPfx || buf[2] != mEnd || buf[4] != mIf)
	      fprintf(stderr, "PgmStmt::readentry: expecting if end on line %s", buf);

	    //-- set current, add to nodelist
	    current = outnode;
	    nodelist.Append(outnode);

          } break;

          case mSwitch: {

	    //-- predicate node
	    buf[0] = 0;
	    PgmStmt& pred_node = PgmStmt::read(is, par, buf);
	    pred_node.annot.kind = Annot::aSwitch;

	    //-- attach pred_node's predecessor, add to nodelist
	    if(current) current->addSuccessor(pred_node);
	    nodelist.Append(&pred_node);

	    //-- predicate next marker / verify
	    fgets(buf, TCA_BUF_SIZE, is.inf);
	    if(buf[0] != mPfx || buf[2] != mNext || buf[4] != mSwitch)
	      fprintf(stderr, "PgmStmt::readentry: expecting switch next on line %s", buf);

	    //-- statements, until switch end marker
	    buf[0] = 0;
	    PgmStmt * scurrent = 0;
	    suco_llist<PgmStmt *> snodelist;
	    PgmStmt::readlist(is, par, buf, scurrent, snodelist);

	    //-- switch end marker
	    if(buf[0] != mPfx || buf[2] != mEnd || buf[4] != mSwitch)
	      fprintf(stderr, "PgmStmt::readentry: expecting switch end on line %s", buf);

	    //-- piece together

	    if(snodelist.IsEmpty()){ //- empty switch!?!
	      current = &pred_node;
	    } else {

	      //-- collect case/break nodes
	      suco_llist<PgmStmt *> casenodes;
	      suco_llist<PgmStmt *> breaknodes;
	      bool hasdefault = false;

	      suco_iterator<PgmStmt *> sni(snodelist);
	      while(sni.Iterate()){
	        PgmStmt * n = sni.Current();
		if(n->annot.kind == Annot::aCaseLabel && !n->hasSwitchPred())
		  casenodes.Append(n);
		if(n->annot.kind == Annot::aDefaultLabel && !n->hasSwitchPred()){
		  casenodes.Append(n);
		  hasdefault = true;
		}
		if(n->annot.kind == Annot::aBreak && !n->succs)
		  breaknodes.Append(n);
	      }

	      //-- create dummy exit node
	      PgmStmt * outnode = new PgmStmt(par);
	      outnode->annot.kind = Annot::aOutNode;

	      //-- if no default label, add outnode to casenodes
	      if(!hasdefault) casenodes.Append(outnode);

	      //-- if scurrent, add to breaknodes
	      if(scurrent) breaknodes.Append(scurrent);

	      //-- attach pred_node to casenodes
	      if(!casenodes.IsEmpty()){
	        pred_node.initSuccsCount(casenodes.Length());
	        suco_iterator<PgmStmt *> cni(casenodes);
	        while(cni.Iterate()){
		  if(cni.Current()->preds) cni.Current()->initPredsCount(2);
		  pred_node.addSuccessor(*cni.Current());
	        }
	      }

	      //-- attach breaknodes to outnode
	      if(!breaknodes.IsEmpty()){
	        outnode->initPredsCount(breaknodes.Length()
					+ (hasdefault?0:1)); //- subtle issue: casenodes part will have
							     //  added outnode as pred_node's successor
	        suco_iterator<PgmStmt *> bni(breaknodes);
	        while(bni.Iterate()) bni.Current()->addSuccessor(*outnode);
	      }

	      nodelist.Attach(snodelist);
	      nodelist.Append(outnode);
	      current = outnode;
	    }

          } break;

          case mNode: {
	    PgmStmt& cfgn = PgmStmt::read(is, par, buf);
	    if(current) current->addSuccessor(cfgn);
	    nodelist.Append(&cfgn);
	    current = &cfgn;
          } break;
          default: {
	    fprintf(stderr, "PgmStmt::readentry: bad start marker on line %s", buf);
	    return false;
          } break;
	}
      } break;
      case mJump: {
	char * cp = &buf[6];
	unsigned int aid = strtoul(cp, &cp, 10);
	switch(buf[4]){
	  case mGoto: {
	    PgmStmt * n = new PgmStmt(par, AID(fsid,aid));

	    while(isspace(*cp)) ++cp;
	    int s = strlen(cp) - 1;
	    while(isspace(cp[s])) --s;
	    cp[++s] = 0;
	    char * nc = new char[s+1];
	    strcpy(nc, cp);
	    n->annot.kind = Annot::aGoto;
	    n->annot.u.string = nc;

	    if(current) current->addSuccessor(*n);
	    nodelist.Append(n);
	    current = 0; //- this won't connect with next node
	  } break;
	  case mBreak: {
	    PgmStmt * n = new PgmStmt(par, AID(fsid,aid));
	    n->annot.kind = Annot::aBreak;
	    if(current) current->addSuccessor(*n);
	    nodelist.Append(n);
	    current = 0; //- this won't connect with next node
	  } break;
	  case mContinue: {
	    PgmStmt * n = new PgmStmt(par, AID(fsid,aid));
	    n->annot.kind = Annot::aContinue;
	    if(current) current->addSuccessor(*n);
	    nodelist.Append(n);
	    current = 0; //- this won't connect with next node
	  } break;
	  case mReturn: {
	    PgmStmt * n = new PgmStmt(par, AID(fsid,aid));

	    while(isspace(*cp)) ++cp;

            suco_set<AO *>& raos = (suco_set<AO *>&) AO::stringToAOlist(true, cp, &cp, is.aidmap, is.pidmap, is.values);
            suco_llist<AO *>& restr_aos = AO::stringToAOlist(false, cp, &cp, is.aidmap, is.pidmap, is.values);
            while(*cp && isspace(*cp)) cp++;
            char * restr = ExpDescr::stringToEstr(cp, &cp);

	    n->annot.kind = Annot::aReturn;
            n->annot.u.edesc = new ExpDescr(restr_aos, restr, raos);

	    if(current) current->addSuccessor(*n);
	    nodelist.Append(n);
	    current = 0; //- this won't connect with next node
	  } break;
	  case mVReturn: {
	    PgmStmt * n = new PgmStmt(par, AID(fsid,aid));
	    n->annot.kind = Annot::aReturn;
	    if(current) current->addSuccessor(*n);
	    nodelist.Append(n);
	    current = 0; //- this won't connect with next node
	  } break;
	  case mCase: {
	    PgmStmt * n = new PgmStmt(par, AID(fsid,aid));
	    n->annot.kind = Annot::aCaseLabel;
	    n->annot.u.integer = strtol(cp, &cp, 10);
	    if(current) current->addSuccessor(*n);
	    nodelist.Append(n);
	    current = n;
	  } break;
	  case mDefault: {
	    PgmStmt * n = new PgmStmt(par, AID(fsid,aid));
	    n->annot.kind = Annot::aDefaultLabel;
	    if(current) current->addSuccessor(*n);
	    nodelist.Append(n);
	    current = n;
	  } break;
	  default: {
	    fprintf(stderr, "PgmStmt::readentry: bad jump marker on line %s", buf);
	    return false;
	  } break;
	}
      } break;
      default: {
	return false;
      }
    }
  } else {
    fprintf(stderr, "PgmStmt::readentry: bad prefix on line %s", buf);
    return false;
  }
  return true;
}

CFGfunction& CFGfunction::read(InputState& is, char * buf, int filestem_id)
{
  if(!buf[0]) fgets(buf, TCA_BUF_SIZE, is.inf);

  int aidno = 0;
  AOId * ao = 0;

  //-- process function start header: read pid/aid
  if(buf[0] == mPfx && buf[2] == mStart && buf[4] == mFunction){
    char * cp = &buf[6];
    int pidno = strtoul(cp, &cp, 10);
    ID * pid = is.pidmap.lookup(pidno);
    if(pid) ao = &pid->get_AOId();
    else fprintf(stderr, "Invalid Pid (%d) read for CFG function\n", pidno);
    aidno = strtoul(cp, &cp, 10);
  } else fprintf(stderr, "CFGfunction::read: bad start marker on line %s", buf);

  if(!ao) exit(fprintf(stderr, "Bad function id AO, aborting\n"));

  CFGfunction * cfn = new CFGfunction(*ao, AID(filestem_id,aidno));
  PgmStmt * current = 0;

  //-- process formals
  {
    buf[0] = 0;
    PgmStmt& cfgn = PgmStmt::read(is, *cfn, buf);
    cfn->cfglist.Insert(&cfgn);
    current = &cfgn;
  }

  //-- process function next (assert)
  {
    fgets(buf, TCA_BUF_SIZE, is.inf);
    if(buf[0] != mPfx || buf[2] != mNext || buf[4] != mFunction)
      fprintf(stderr, "CFGfunction::read: next assertion failed on line %s", buf);
  }

  //-- process body, until function end
  fgets(buf, TCA_BUF_SIZE, is.inf);
  while(!feof(is.inf) && (buf[0] != mPfx || buf[2] != mEnd || buf[4] != mFunction)){
    PgmStmt::readentry(is, *cfn, buf, current, cfn->cfglist);
    fgets(buf, TCA_BUF_SIZE, is.inf);
  }

  //-- find goto and return nodes
  suco_llist<PgmStmt *> gotonodes;
  suco_iterator<PgmStmt *> cni(cfn->cfglist);
  while(cni.Iterate()){
    PgmStmt * n = cni.Current();
    if(n->isReturn()) cfn->exitnodes.Append(n);
    if(n->isGoto()) gotonodes.Append(n);
  }

  //-- connect goto nodes
  if(!gotonodes.IsEmpty()){
    suco_llist<PgmStmt *> labelcache;
    suco_iterator<PgmStmt *> gni(gotonodes);
    while(gni.Iterate()){
      PgmStmt * gn = gni.Current();
      const char * glabel = gn->getGotoLabel();
      if(labelcache.IsEmpty()){ //- collect labeled nodes
        suco_iterator<PgmStmt *> ani(cfn->cfglist);
        while(ani.Iterate())
          if(ani.Current()->hasLabel())
            labelcache.Append(ani.Current());
      }
      suco_iterator<PgmStmt *> lni(labelcache);
      while(lni.Iterate())
        if(lni.Current()->hasLabel(glabel))
          gn->addSuccessor(*lni.Current()); //- in goto case, we don't initPredsCount
    }
  }

  //- if current is non-null and not already marked as a return node
  //  create dummy return node, add to exitnodes
  if(current && !current->isReturn()){
    PgmStmt * retn = new PgmStmt(*cfn);
    retn->annot.kind = PgmStmt::Annot::aReturn;

    current->addSuccessor(*retn);

    cfn->exitnodes.Insert(retn);
    cfn->cfglist.Append(retn);
  }

  //- assign entrystmt
  cfn->entrystmt = cfn->cfglist.Head();

  return *cfn;
}

void CFG::read(InputState& is, char * buf, const char * filestem)
{
  if(!buf[0]) fgets(buf, TCA_BUF_SIZE, is.inf);

  //-- add entry to filestemlist
  AID::filestemlist.Append(filestem);
  int filestem_id = AID::filestemlist.Length();

  while(!feof(is.inf)){
    if(buf[2] == mStart && buf[4] == mFunction) {
      CFGfunction& cfn = CFGfunction::read(is, buf, filestem_id);
      this->fnlist.Append(&cfn);

      //-- identify "main"
      if(!strcmp(cfn.idao.getPid().getname(), ".main")){
        //-- set mainfn pointer
        this->mainfn = &cfn;
      }
    } else {
      PgmExpr * df = PgmExpr::read(is, buf, 0);
      if(df) this->globnodes.Append(df);
      else fprintf(stderr, "CFG::read: error reading global decl: %s", buf);
    }
    fgets(buf, TCA_BUF_SIZE, is.inf);
  }
}

//----------------------------------
// END READ FUNCTIONS
//----------------------------------

//----------------------------------
// DEBUG DUMP FUNCTIONS
//----------------------------------

static const char * getIndent(int indent)
{
  static const char space_buffer[] = "                                                  ";
  static const char * spaces = &space_buffer[sizeof(space_buffer)-1];

  if(indent > (int) sizeof(space_buffer) - 1) indent = sizeof(space_buffer) - 1;

  return spaces-indent;
}

//- if indent == 0, then fit on one line
void ExpDescr::debug_dump(FILE * outf, int indent)
{
  const char * ispaces = getIndent(indent);
  const char * delim = indent?"\n":"  ";
  fprintf(outf, "%sAOs: ", ispaces);
  AO::write_list_string_rep(outf, this->aos, true);
  fprintf(outf, delim);
  fprintf(outf, "%saffAOs: ", ispaces);
  AO::write_list_string_rep(outf, this->estr_aos, true);
  fprintf(outf, delim);
  fprintf(outf, "%sestr: %s", ispaces, this->estr?this->estr:"@@");
  fprintf(outf, delim);
}

void PExprCall::debug_dump(FILE * outf, int indent, bool brief)
{
  const char * ispaces = getIndent(indent);

  fprintf(outf, "%s--{ Expr %s", ispaces, getKindString());
  if(this->isDirectCall()) fprintf(outf, " (direct)");
  if(this->isRecursiveCall()) fprintf(outf, " (recursive)");
  if(widen_locs){
    fprintf(outf, " widen");
    if(widen_locs != CFGnode::ALL_AOS){
      fprintf(outf, "(%d/%d)", widen_locs->numAOs(), widen_locs->Size());
    }
  }
  fprintf(outf, " (aid=<%d,%d>, nargs=%d)\n", aid.filestem_id, aid.aid, nargs);

  fprintf(outf, "%s    FnAOs: ", ispaces);
  AO::write_list_string_rep(outf, faos, true);
  fprintf(outf, "\n");
  
  fprintf(outf, "%s    TargetFns:", ispaces);
  suco_iterator<CFGfunction *> tfi(targetfns);
  while(tfi.Iterate()){
    fprintf(outf, " ");
    tfi.Current()->getId().write_string_rep(outf, true);
  }
  fprintf(outf, "\n");

  fprintf(outf, "%s    Undef TargetFns:", ispaces);
  suco_iterator<AOId *> utfi(undef_tgtfns);
  while(utfi.Iterate()){
    fprintf(outf, " ");
    utfi.Current()->write_string_rep(outf, true);
  }
  fprintf(outf, "\n");

  for(int i = 0; i < nargs; ++i){
    fprintf(outf, "%s    Arg %d", ispaces, i+1);
    if(args[i]){
      fprintf(outf, " (aid=<%d,%d>):\n", args[i]->getAid().filestem_id, args[i]->getAid().aid);
      args[i]->getDesc().debug_dump(outf, indent+8);
    }
  }

  if(!brief){
    fprintf(outf, "%s    RDAfact: ", ispaces);
    rda_fact.debug_dump(outf, false);

    fprintf(outf, "%s    RDAlocal: ", ispaces);
    rda_local.debug_dump(outf, false);

    fprintf(outf, "%s    MBUfact: ", ispaces);
    mbu_fact.debug_dump(outf, false);

    fprintf(outf, "%s    REDfact: ", ispaces);
    red_fact.debug_dump(outf, false);

    fprintf(outf, "%s    RANfact: ", ispaces);
    ran_fact.debug_dump(outf, false);
  }

  fprintf(outf, "%s--}\n", ispaces);
}

void PExprAssign::debug_dump(FILE * outf, int indent, bool brief)
{
  const char * ispaces = getIndent(indent);

  fprintf(outf, "%s--{ Expr %s (aid=<%d,%d>)\n",
		ispaces, getKindString(), aid.filestem_id, aid.aid);
  fprintf(outf, "%s    e1:\n", ispaces);
  e1desc.debug_dump(outf, indent+8);
  fprintf(outf, "%s    e2:\n", ispaces);
  e2desc.debug_dump(outf, indent+8);
  fprintf(outf, "%s--}\n", ispaces);
}

void PExprPredicate::debug_dump(FILE * outf, int indent, bool brief)
{
  const char * ispaces = getIndent(indent);

  fprintf(outf, "%s--{ Expr %s / %s (aid=<%d,%d>)\n",
		ispaces, getKindString(), getPrKindString(), aid.filestem_id, aid.aid);
  edesc.debug_dump(outf, indent+8);
  fprintf(outf, "%s--}\n", ispaces);
}

void PExprDecl::debug_dump(FILE * outf, int indent, bool brief)
{
  const char * ispaces = getIndent(indent);

  fprintf(outf, "%s--{ Expr %s / %s (", ispaces, getKindString(), getDkindString());
  if(dkind == dFormal)
    fprintf(outf, "argno=%d,", argno);
  fprintf(outf, " ao = ");
  ao.write_string_rep(outf, true);
  fprintf(outf, ") ");
  if(iszeroed)
    fprintf(outf, "iszeroed ");
  if(dkind == dMalloc && mallocsize){
    fprintf(outf, "size =\n", argno);
    mallocsize->debug_dump(outf, indent+8);
  fprintf(outf, "%s  ", ispaces);
  }
  fprintf(outf, "}--\n");
}

void PExprVerify::debug_dump(FILE * outf, int indent, bool brief)
{
  const char * ispaces = getIndent(indent);

  fprintf(outf, "%s--{ Expr %s%s%s (aid=<%d,%d>)\n",
		ispaces, getKindString(), getVtKindString(), getVpKindString(),
		aid.filestem_id, aid.aid);
  desc.debug_dump(outf, indent+4);
  fprintf(outf, "%s--}\n", ispaces);
}

void PExprParallel::debug_dump(FILE * outf, int indent, bool brief)
{
  const char * ispaces = getIndent(indent);
  fprintf(outf, "%s--{ Parallel:\n", ispaces);

  suco_iterator<suco_llist<PgmExpr *> *> flsi(nodelists);
  while(flsi.Iterate()){
    fprintf(outf, "%s--: NEXT :\n", ispaces);
    suco_iterator<PgmExpr *> fli(*flsi.Current());
    while(fli.Iterate()) fli.Current()->debug_dump(outf, indent+2);
  }

  fprintf(outf, "%s--} end Parallel\n", ispaces);
}

void PExprBranch::debug_dump(FILE * outf, int indent, bool brief)
{
  const char * ispaces = getIndent(indent);
  fprintf(outf, "%s--{ Branch:\n", ispaces);

  fprintf(outf, "%s--: PREDICATE :\n", ispaces);
  if(prednode) prednode->debug_dump(outf, indent+2);

  fprintf(outf, "%s--: TRUE :\n", ispaces);
  suco_iterator<PgmExpr *> tfi(tnodelist);
  while(tfi.Iterate()) tfi.Current()->debug_dump(outf, indent+2);

  fprintf(outf, "%s--: FALSE :\n", ispaces);
  suco_iterator<PgmExpr *> ffi(fnodelist);
  while(ffi.Iterate()) ffi.Current()->debug_dump(outf, indent+2);

  fprintf(outf, "%s--} end Branch\n", ispaces);
}

void PgmStmt::debug_dump(FILE * outf, int indent, bool brief)
{
  const char * ispaces = getIndent(indent);
  fprintf(outf, "%s--{ Stmt %d/%d (aid=<%d,%d>)%s",
		ispaces, parent.getCallGraphId(), traverse_id,
		aid.filestem_id, aid.aid, hascall?" hascall ":"");
  if(getNsuccs()){
    fprintf(outf, "(succ =");
    for(int i = 0; getSuccStmt(i); ++i){
      fprintf(outf, " %d", getSuccStmt(i)->traverse_id);
      int bndx = (i < 2)?i:0;
      if(backedge_locs[bndx]){
        fprintf(outf, "bk");
        if(backedge_locs[bndx] != CFGnode::ALL_AOS){
          fprintf(outf, "(%d/%d)", backedge_locs[bndx]->numAOs(), backedge_locs[bndx]->Size());
        }
      }
    }
    fprintf(outf, " )");
  }
  if(getNpreds()){
    fprintf(outf, "(pred =");
    for(int i = 0; getPred(i); ++i)
      fprintf(outf, " %d", getPredStmt(i)->traverse_id);
    fprintf(outf, " )");
  }
  if(nlabels){
    fprintf(outf, "(labels =");
    for(int i = 0; i < nlabels; ++i)
      fprintf(outf, " %s", labels[i]);
    fprintf(outf, " )");
  }
  switch(annot.kind){
    case Annot::aGoto: {
      fprintf(outf, "(GOTO %s)", (annot.u.string)?(annot.u.string):"null!");
    } break;
    case Annot::aBreak: {
      fprintf(outf, "(BREAK)");
    } break;
    case Annot::aContinue: {
      fprintf(outf, "(CONTINUE)");
    } break;
    case Annot::aReturn: {
      if(annot.u.edesc){
        fprintf(outf, "(RETURN ");
        annot.u.edesc->debug_dump(outf, 0);
        fprintf(outf, ")");
      } else {
        fprintf(outf, "(RETURN)");
      }
    } break;
    case Annot::aWhile: {
      fprintf(outf, "(WHILE)");
    } break;
    case Annot::aDoWhile: {
      fprintf(outf, "(DOWHILE)");
    } break;
    case Annot::aFor: {
      fprintf(outf, "(FOR)");
    } break;
    case Annot::aIf: {
      fprintf(outf, "(IF)");
    } break;
    case Annot::aSwitch: {
      fprintf(outf, "(SWITCH)");
    } break;
    case Annot::aCaseLabel: {
      fprintf(outf, "(CASE %d)", annot.u.integer);
    } break;
    case Annot::aDefaultLabel: {
      fprintf(outf, "(DEFAULT)");
    } break;
    case Annot::aOutNode: {
      fprintf(outf, "(OUTNODE)");
    } break;

    default: {
    } break;
  }

  if(brief){

    fprintf(outf, " }--\n");

  } else {

    fprintf(outf, ":\n");

    suco_iterator<PgmExpr *> fli(this->exprlist);
    while(fli.Iterate()){
      fli.Current()->debug_dump(outf, indent+2);
    }

    fprintf(outf, "%s -- RDAfact: ", ispaces);
    rda_fact.debug_dump(outf, false);

    fprintf(outf, "%s -- MBUfact: ", ispaces);
    mbu_fact.debug_dump(outf, false);

    fprintf(outf, "%s -- REDfact: ", ispaces);
    red_fact.debug_dump(outf, false);

    fprintf(outf, "%s -- RANfact1: ", ispaces);
    ran_fact_pair.getFact1().debug_dump(outf, false);
    if(ran_fact_pair.getFact2()){
      fprintf(outf, "%s -- RANfact2: ", ispaces);
      ran_fact_pair.getFact2()->debug_dump(outf, false);
    }

    fprintf(outf, "%s--} end Stmt %d/%d (aid=<%d,%d>)\n",
		  ispaces, parent.getCallGraphId(), traverse_id, aid.filestem_id, aid.aid);
  }
}

void CFGbblock::debug_dump(FILE * outf, int indent, bool brief)
{
  const char * ispaces = getIndent(indent);
  fprintf(outf, "%s--{ BBlock %d/%d%s", ispaces, parent.getCallGraphId(), traverse_id,
					hascall?" hascall":"");
  if(getNsuccs()){
    fprintf(outf, " (succ =");
    for(int i = 0; getSucc(i); ++i){
      fprintf(outf, " %d", ((CFGbblock*)getSucc(i))->traverse_id);
      int bndx = (i < 2)?i:0;
      if(backedge_locs[bndx]){
        fprintf(outf, "bk");
        if(backedge_locs[bndx] != CFGnode::ALL_AOS)
          fprintf(outf, "(%d/%d)", backedge_locs[bndx]->numAOs(), backedge_locs[bndx]->Size());
      }
    }
    fprintf(outf, " )");
  }
  if(getNpreds()){
    fprintf(outf, " (pred =");
    for(int i = 0; getPred(i); ++i)
      fprintf(outf, " %d", ((CFGbblock*)getPred(i))->traverse_id);
    fprintf(outf, " )");
  }
  fprintf(outf, " #stmts = %d", stmtlist.Length());
  if(brief || stmtlist.IsEmpty()){
    fprintf(outf, " }--\n");
  } else {
    fprintf(outf, ":\n");

    suco_iterator<PgmStmt *> psi(stmtlist);
    while(psi.Iterate()){
      psi.Current()->debug_dump(outf, indent+2);
    }

    fprintf(outf, "%s -- RDAfact: ", ispaces);
    rda_fact.debug_dump(outf, false);

    fprintf(outf, "%s -- MBUfact: ", ispaces);
    mbu_fact.debug_dump(outf, false);

    fprintf(outf, "%s -- REDfact: ", ispaces);
    red_fact.debug_dump(outf, false);

    fprintf(outf, "%s -- RANfact1: ", ispaces);
    ran_fact_pair.getFact1().debug_dump(outf, false);
    if(ran_fact_pair.getFact2()){
      fprintf(outf, "%s -- RANfact2: ", ispaces);
      ran_fact_pair.getFact2()->debug_dump(outf, false);
    }

    fprintf(outf, "%s--} end BBlock %d/%d\n", ispaces, parent.getCallGraphId(), traverse_id);
  }
}

void CFGfunction::debug_dump(FILE * outf, bool brief)
{
  fprintf(outf, " --{ Function (ao = ");
  idao.write_string_rep(outf, true);
  fprintf(outf, ", aid=<%d,%d>, entry=%d, exit=%d, callgraph_id=%d, recursion_id=%d):\n",
			aid.filestem_id, aid.aid, entrystmt->getAid().aid, exitnodes.Length(),
			getCallGraphId(), getRecursionId());
  if(!brief){
    fprintf(outf, "     LocalVars: ");
    AO::write_list_string_rep(outf, (suco_set<AO *>&)localvars, true);
    fprintf(outf, "\n");

    fprintf(outf, "     GMOD: ");
    this->gmod.debug_dump(outf);

    fprintf(outf, "     GREF: ");
    this->gref.debug_dump(outf);

    if(flag_compute_iref){
      fprintf(outf, "     IREF: ");
      this->iref.debug_dump(outf);
    }

    fprintf(outf, "     GFREE-heap: ");
    suco_iterator<ECR *> gfhi(this->gfreeheap_ecrs);
    while(gfhi.Iterate())
      AO::write_list_string_rep(outf, gfhi.Current()->getAOset(), true);
    fprintf(outf, "\n");

    fprintf(outf, "     GFREE-stack: ");
    AO::write_list_string_rep(outf, gfreestack, true);
    fprintf(outf, "\n");

    fprintf(outf, "   { Callees:\n");
    suco_iterator<CFGfunction *> cgi(callgraph);
    while(cgi.Iterate()){
      fprintf(outf, "      %s\n", cgi.Current()->getId().getPid().getname());
    }
    fprintf(outf, "   } end callees\n");

    fprintf(outf, "   { Callsites:\n");
    suco_iterator<PExprCall *> csi(callsites);
    while(csi.Iterate()){
      csi.Current()->debug_dump(outf, 4, true);
    }
    fprintf(outf, "   } end callsites\n");

    if(flag_use_bblocks){
      suco_iterator<CFGbblock *> bbi(bblocks);
      while(bbi.Iterate())
        bbi.Current()->debug_dump(outf, 2);
    } else {
      suco_iterator<PgmStmt *> nli(cfglist);
      while(nli.Iterate())
        nli.Current()->debug_dump(outf, 2);
    }
  }

  fprintf(outf, " --} end Function (aid=<%d,%d>)\n", aid.filestem_id, aid.aid);
}

void CFG::debug_dump(FILE * outf)
{
  fprintf(outf, "--{ CFG (%d functions):\n", fnlist.Length());
  if(entry){
    fprintf(outf, "    Entry Node:\n");
    entry->debug_dump(outf, 4);
  }
  suco_iterator<CFGfunction *> fli(fnlist);
  while(fli.Iterate())
    fli.Current()->debug_dump(outf);
  fprintf(outf, "--} end CFG (%d functions)\n", fnlist.Length());
}

//----------------------------------
// END DEBUG DUMP FUNCTIONS
//----------------------------------

//----------------------------------
// WRITE DFA RESULTS
//----------------------------------

//----------------------------------
// END WRITE MBU RESULTS
//----------------------------------

void CFG::remapRecursionId()
{
  suco_llist<CFGfunction *> highest_id_recurse_list;

  //- 1. find for each recursion_id the node with the highest callgraph_id
  suco_iterator<CFGfunction *> fni(this->fnlist);
  while(fni.Iterate()){
    CFGfunction& cfn = *fni.Current();
    if(cfn.recursion_id){
      bool found = false;
      suco_iterator<CFGfunction *> hirli(highest_id_recurse_list);
      while(hirli.Iterate()){
        if(hirli.Current()->getRecursionId() == cfn.getRecursionId()){
          found = true;
          if(hirli.Current()->getCallGraphId() < cfn.getCallGraphId()){
            hirli.DeleteCurrent();
            highest_id_recurse_list.Insert(&cfn);
          }
          break;
        }
      }
      if(!found) highest_id_recurse_list.Insert(&cfn);
    }
  }
  if(!highest_id_recurse_list.IsEmpty()){
    //- 2. Renumber each recursion_id with the highest callgraph_id
    //- 2a. first skip the "representative nodes"
    fni.Rewind();
    while(fni.Iterate()){
      CFGfunction& cfn = *fni.Current();
      if(cfn.recursion_id){
        suco_iterator<CFGfunction *> hirli(highest_id_recurse_list);
        while(hirli.Iterate()){
          if(&cfn != hirli.Current() &&
		cfn.recursion_id == hirli.Current()->recursion_id){
            cfn.recursion_id = hirli.Current()->getCallGraphId();
            break;
          }
        }
      }
    }
    //- 2b. final pass: renumber the "representative nodes"
    {
      suco_iterator<CFGfunction *> hirli(highest_id_recurse_list);
      while(hirli.Iterate()){
        hirli.Current()->recursion_id = hirli.Current()->getCallGraphId();
      }
    }
  }
}

void CFG::prepareSuperGraph()
{
  connectSuperGraph();

  if(flag_verbose) TCstats::timer("traversing callgraph");
  this->mainfn->traverseCallGraph(0);
  if(flag_verbose) TCstats::timer(0);

  if(flag_verbose) TCstats::timer("remapping recursion id");
  remapRecursionId();
  if(flag_verbose) TCstats::timer(0);
}

void CFG::prepareCFG(bool prepare_widen)
{
  if(this->prepared){
    return; //- already prepared
  }
  this->prepared = true;

  if(!this->mainfn){
    fprintf(stderr, "FATAL ERROR: CFG has no main function\n");
    return;
  }

  collectLocalsAndIMODREF();
  prepareSuperGraph();
  collectGMODREF();

  constructBBlocks();
  assignIds(); //- note: also marks backedges

  //- compute (intraprocedural) loop backedge filters
  if(prepare_widen && flag_range_filter_loop_backedge)
    computeBackedgeFilters();

  //- compute widen_locs for (recursive) call nodes
  if(prepare_widen){
    TCstats::timer("finding recursive widen-ecrs");
    suco_iterator<CFGfunction *> fni(this->fnlist);
    while(fni.Iterate()){
      if(fni.Current()->getRecursionId()){
        suco_iterator<PgmStmt *> cni(fni.Current()->cfglist);
        while(cni.Iterate()){
          cni.Current()->traverseRootNodes(CFGnode::computeWidenAOs);
        }
      }
    }
    TCstats::timer(0);
  }

  //-- create new empty CFG node, representing the entry
  //   point to entire CFG
  // - instantiate them with globnodes!
  {
    PgmStmt * entrystmt = new PgmStmt(*mainfn);
    entrystmt->exprlist.Copy(globnodes);	//- (ab)use friendship to initialize exprlist

    if(flag_use_bblocks){
      suco_set<PgmStmt *> dummy;
      this->entry = new CFGbblock(*entrystmt, dummy);
      if(!dummy.IsEmpty()) //- assert
        fprintf(stderr, "ERROR(CFG::prepareCFG): new entry bblock - pendingnodes not empty\n");
    } else {
      this->entry = entrystmt;
    }
  }

  if(mainfn->getEntryNode()){

    this->entry->addSuccessor(*mainfn->getEntryNode());

    if(prepare_widen){
      //- identify remaining backedges in supergraph (due to false loops from context-insensitivity)
      TCstats::timer("finding remaining backedges");
      mainfn->getEntryNode()->findRemainingBackedges();
      TCstats::timer(0);
    }

  } else fprintf(stderr, "Main function has no entry node!\n");
}

//----------------------------------
// TRAVERSE ROOT PGMEXPR NODES
//----------------------------------

bool PgmExpr::traverseRootNodes(bool (*fp)(PgmExpr& dn))
{
  bool alive = true;
  switch(kind){
    case fParallel: { //- recurse
        suco_iterator<suco_llist<PgmExpr *> *> fli(((PExprParallel *)this)->nodelists);
        while(alive && fli.Iterate()){
          suco_iterator<PgmExpr *> dfi(*fli.Current());
          while(alive && dfi.Iterate()){
            alive &= dfi.Current()->traverseRootNodes(fp);
          }
        }
      } break;
    case fBranch: { //- recurse
        suco_iterator<PgmExpr *> tfi(((PExprBranch *)this)->tnodelist);
        while(alive && tfi.Iterate())
          alive &= tfi.Current()->traverseRootNodes(fp);
        suco_iterator<PgmExpr *> ffi(((PExprBranch *)this)->fnodelist);
        while(alive && ffi.Iterate())
          alive &= ffi.Current()->traverseRootNodes(fp);
      } break;
    case fCall:
    case fAssign:
    case fPredicate:
    case fDecl:
    case fVerify:
    default : {
        alive &= fp(*this);
      } break;
  }
  return alive;
}

bool PgmStmt::traverseRootNodes(bool (*fp)(PgmExpr& dn))
{
  bool alive = true;
  suco_iterator<PgmExpr *> nli(this->exprlist);
  while(alive && nli.Iterate())
    alive &= nli.Current()->traverseRootNodes(fp);
  return alive;
}

bool CFGbblock::traverseRootNodes(bool (*fp)(PgmExpr& dn))
{
  bool alive = true;
  suco_iterator<PgmStmt *> nli(this->stmtlist);
  while(alive && nli.Iterate())
    alive &= nli.Current()->traverseRootNodes(fp);
  return alive;
}

bool CFG::traverseRootNodes(bool (*fp)(PgmExpr& dn))
{
  bool alive = true;
  //- FIRST: traverse entry node
  if(this->getEntryNode()){
    alive &= this->entry->traverseRootNodes(fp);
  }
  //- now, traverse each function's statement list
  suco_iterator<CFGfunction *> fni(this->getFunctionList());
  while(alive && fni.Iterate()){
    suco_iterator<PgmStmt *> psi(fni.Current()->getStmtList());
    while(alive && psi.Iterate()){
      alive &= psi.Current()->traverseRootNodes(fp);
    }
  }
  return alive;
}

//----------------------------------
// CFG CONNECT CALL/FN NODES (SUPERGRAPH)
//----------------------------------

PExprCall * CFG::act_caller_node = 0;
suco_llist<CFGfunction *> * CFG::act_fnlist = 0;

bool CFG::addAOtoCallTarget(AO& ao)
{
  if(ao.getKind() == AO::aoFunction){
    if(CFG::act_fnlist && CFG::act_caller_node){ // assertion
      AO& idao = ((AOFunction&)ao).getTarget();
      if(idao.getKind() == AO::aoId){ // more assert
        suco_iterator<CFGfunction *> fli(*CFG::act_fnlist);
        while(fli.Iterate()){
          if(&fli.Current()->idao == (AOId *)&idao){
            //-- CFG: connect caller node to callsite
            CFG::act_caller_node->targetfns.Insert(fli.Current());
            fli.Current()->callsites.Insert(CFG::act_caller_node);

            //-- callgraph: add callee to caller's enclosing function
            //   Note: caller->getParentNode already validated to be non-null during input
            CFG::act_caller_node->getParentNode()->getParentFunction().callgraph.Insert(fli.Current());

            return true; //- true ensures full traversal of ECRs
          }
        }
        //- call to undefined function (library)
        CFG::act_caller_node->undef_tgtfns.Insert((AOId *) &idao);
      }
    }
  }
  return true; //- true ensures full traversal of ECRs
}

bool CFG::assignCallTargets(PgmExpr& dn)
{
  if(dn.kind == PgmExpr::fCall){
    CFG::act_caller_node = (PExprCall *)&dn;
    suco_iterator<AO *> faoi(CFG::act_caller_node->faos);
    while(faoi.Iterate()){
      faoi.Current()->getECR().getPointsTo().traverseAliases(addAOtoCallTarget);
    }
  }
  return true; //- true ensures full traversal
}

void CFG::connectSuperGraph()
{
  if(flag_verbose) TCstats::timer("connecting supergraph (call/return assignments)");

  CFG::act_fnlist = &this->fnlist;
  suco_iterator<CFGfunction *> fni(this->fnlist);
  while(fni.Iterate()){
    CFGfunction * fn = fni.Current();
    suco_iterator<PgmStmt *> cni(fn->cfglist);
    while(cni.Iterate()){
      cni.Current()->traverseRootNodes(CFG::assignCallTargets);
    }
  }
  CFG::act_fnlist = 0;
  if(flag_verbose) TCstats::timer(0);
}

//----------------------------------
// REPORT IF CALLNODE CALLS FREE()
//----------------------------------

bool PExprCall::callsFree()
{
  //-- check direct call
  AO * fao = this->faos.Head();
  if(fao && fao->getKind() == AO::aoId &&
	!strcmp(((AOId *)fao)->getPid().getname(), ".free")){
    return true;
  }

  //-- check indirect call
  suco_iterator<AOId *> uti(this->undef_tgtfns);
  while(uti.Iterate()){
    if(!strcmp(uti.Current()->getPid().getname(), ".free"))
      return true;
  }
  return false;
}

ID * PExprCall::isDirectCall()
{
  if(this->getFaos().Length() == 1){
    if((this->getTargetFns().Length() == 1)
	     && (&this->getTargetFns().Head()->getId() == this->getFaos().Head())){
      return &this->getTargetFns().Head()->getId().getPid();
    }
    if((this->getUndefTargetFns().Length() == 1)
	     && (this->getUndefTargetFns().Head() == this->getFaos().Head())){
      return &this->getUndefTargetFns().Head()->getPid();
    }
  }
  return 0;
}

bool PExprCall::isRecursiveCall()
{
  int parent_recurs_id = (this->getParentNode())
			 ? (this->getParentNode()->getParentFunction().getRecursionId())
			 : 0;
  if(parent_recurs_id){
    suco_iterator<CFGfunction *> tfi(this->getTargetFns());
    while(tfi.Iterate()){
      if(tfi.Current()->getRecursionId() == parent_recurs_id){
        return true;
      }
    }
  }
  return false;
}

//--------------------------------------
//- GREF/GMOD accessor functions

//- returns true if ao points to something in this->gfreeheap
//  (i.e. ao points to ecr that intersects with this->gfreeheap_ecrs)
bool CFGfunction::GFreeHeapAffects(AO& ao)
{
  return ao.getECR().getPointsTo().getAliasECRs().Intersects(this->getGFreeHeap_ecrs());
}

//----------------------------------
// TRAVERSE CALL GRAPH
//----------------------------------

//- traversal occurs in 2 modes:
//  1. recursing=false:
//     a. reach an inactive node
//        -> process childen recursing=false
//     b. reach a visited node
//        -> cross-edge, stop
//     c. reach an active node
//        i. node is marked recursive
//           -> return that recursion_id
//              *propagate it backwards until reaching
//               a node already marked recursive
//        ii. node is not marked recursive
//            -> switch to recursing=true, process that node
//  2. recursing=true:
//     a. reach an inactive node
//        -> stop
//     b. reach a visited node
//        -> stop
//     c. reach an active node
//        i. node is marked recursive
//            -> stop
//        ii. node is not marked recursive
//            -> mark it recursive, continue processing
//               children with recursing=true
//
int CFGfunction::traverseCallGraph(int recursing)
{
  static int callgraph_counter = 0;
  static int recursing_counter = 0;
  
  if(this->callgraph_id == 0){ //-- 0 = inactive
    if(recursing){ //- (2.a.) if recursing, stop traversal
      return 0;
    } else { //- (1.a.)
      this->callgraph_id = -1; //: -1 = active
      suco_iterator<CFGfunction *> cgi(this->callgraph);
      int rid = 0;
      while(cgi.Iterate()){
        int lrid = cgi.Current()->traverseCallGraph(0);
        if(lrid) rid = lrid;
      }
      callgraph_counter++; //- depth-first numbering
      this->callgraph_id = callgraph_counter;
      if(rid && !this->recursion_id){ //- (1.c.i.*)
        this->recursion_id = rid;
        return rid; //- propagate backwards
      } else {
        return 0;
      }
    }
  } else if(this->callgraph_id == -1){ //-- -1 = active
    if(this->recursion_id){ //- (1.c.i., 2.c.i.) if already recursive, stop traversal
      return (recursing)?(0):(this->recursion_id);
    } else { //- (1.c.ii., 2.c.ii.) traverse actives, set recursion_id
      if(!recursing){ //- (1.c.ii.)
        recursing_counter++;
        recursing = recursing_counter;
      }
      this->recursion_id = recursing;
      suco_iterator<CFGfunction *> cgi(this->callgraph);
      while(cgi.Iterate()){
        cgi.Current()->traverseCallGraph(this->recursion_id);
      }
      return 0;
    }
  } else { //--(1.b., 2.b.) positive=visited
    return 0;
  }
}

//----------------------------------
// CONSTRUCT BASIC BLOCKS
//----------------------------------

bool PgmExpr::notFunctionCall(PgmExpr& dn)
{
  return (dn.getKind() != PgmExpr::fCall);
}

bool PgmStmt::hasFunctionCalls()
{
  this->hascall = !this->traverseRootNodes(PgmExpr::notFunctionCall);
  return this->hascall;
}

CFGbblock::CFGbblock(PgmStmt& headnode, suco_set<PgmStmt *>& pendingnodes)
: CFGnode(headnode.getParentFunction()),
  stmtlist()
{
  this->stmtlist.Append(&headnode);
  headnode.bblock = this;
  this->hascall = headnode.hasFunctionCalls();

  PgmStmt * cnode = &headnode;

  if(!this->hascall){
    while(cnode->countSuccs() == 1		  //- only one successor
	  && cnode->getSuccStmt(0)->countPreds() == 1  //- successor has only one predecessor
	  && !cnode->getSuccStmt(0)->hasFunctionCalls()) //- successor has no function calls
    {
      //- add successor to this basic block
      cnode = cnode->getSuccStmt(0);
      this->stmtlist.Append(cnode);
      cnode->bblock = this;
    }
  }
  //- add unassigned successors to pendingnodes
  for(int i = 0; cnode->getSuccStmt(i); ++i)
    if(cnode->getSuccStmt(i) && !cnode->getSuccStmt(i)->bblock)
      pendingnodes.Insert(cnode->getSuccStmt(i));
}

void CFGfunction::constructBBlocks()
{
  suco_set<PgmStmt *> pendingnodes;

  if(!this->entrystmt){
    fprintf(stderr, "Entry node not assigned!\n");
    return;
  }

  //- consume entrystmt
  pendingnodes.Insert(this->entrystmt);

  //- construct and collect basic block nodes
  while(!pendingnodes.IsEmpty()){
    PgmStmt& cnode = *pendingnodes.RemoveHead();
    CFGbblock& newblk = *new CFGbblock(cnode, pendingnodes);
    this->bblocks.Append(&newblk);
    if(&cnode == this->entrystmt) //-- assign entryblock
      this->entryblock = &newblk;
  }

  int stat_numblocks = 0;
  int stat_numnodes = 0;
  int stat_maxnodes = 0;

  //-- connect basic blocks
  suco_iterator<CFGbblock *> bbi(this->bblocks);
  while(bbi.Iterate()){
    CFGbblock& bb = *bbi.Current();

    if(flag_verbose){
      stat_numblocks++;
      int nnodes = bb.stmtlist.Length();
      stat_numnodes += nnodes;
      if(stat_maxnodes < nnodes) stat_maxnodes = nnodes;
    }

    //-- preds
    {
      PgmStmt& hnode = *bb.stmtlist.Head();

      // - allocate preds array
      bb.npreds = hnode.countPreds();
      bb.preds = new CFGnode * [bb.npreds+1];

      // - lookup and assign
//-NOTE: lookup failure may be due to unreachable nodes (artifact
//       of my translation of program structure?), or from
//       _prog_main's "global entry" node.
//TODO: make that global entry node a basic block?
      int i = 0;
      for(int j = 0; hnode.getPred(j); ++j){
        if((bb.preds[i] = hnode.getPredStmt(j)->bblock) != 0)
          i++;
      }
      bb.preds[i] = 0;
    }

    //-- succs
    // - allocate succs array
    {
      PgmStmt& tnode = *bb.stmtlist.Last();

      // - allocate succs array
      bb.nsuccs = tnode.countSuccs();
      bb.succs = new CFGnode * [bb.nsuccs+1];

      // - lookup and assign
      int i = 0;
      for(int j = 0; tnode.getSuccStmt(j); ++j){
        if((bb.succs[i] = tnode.getSuccStmt(j)->bblock) != 0)
          i++;
      }
      bb.succs[i] = 0;
    }
  }
  if(flag_verbose > 2)
    fprintf(stderr, "\t%d\t%d\t%d\t%.2f\t%s\n",
		stat_numblocks, stat_numnodes, stat_maxnodes,
		(float)stat_numnodes/(float)stat_numblocks,
		this->getId().getPid().getname());
}

void CFG::constructBBlocks()
{
  if(flag_verbose){
    TCstats::timer("constructing basic blocks");
    if(flag_verbose > 2)
      fprintf(stderr, "(BLOCKS/NODES/MAX/AVG)\n");
  }

  suco_iterator<CFGfunction *> fni(this->fnlist);
  while(fni.Iterate())
    fni.Current()->constructBBlocks();

  if(flag_verbose) TCstats::timer(0);
}

//----------------------------------
// ASSIGN CFGNODE IDS
//----------------------------------

////////////////////////////////////
// Post-Order Depth-First numbering, with special loop handling
//-EXTRA: I've hi-jacked this traversal function to
//	  also mark backedges for widening/narrowing

void CFG::assignId(CFGnode& cnode)
{
  if(cnode.traverse_id > 0){

    return;

  } else if(cnode.traverse_id == -1){ //- backedge

    for(int i = 0; cnode.getSucc(i); ++i)
      if(!cnode.getSucc(i)->traverse_id)
        assignId(*cnode.getSucc(i));

  } else { //- new node

    cnode.traverse_id = -1; //- mark "visiting"

      /////////////////////////////////////////////
    { //- mark backedges to do widening/narrowing
      if(cnode.getNsuccs() == 2){ //- two-way branches
        if(cnode.getSucc(0) && cnode.getSucc(0)->traverse_id == -1)
          cnode.backedge_locs[0] = CFGnode::ALL_AOS;
        if(cnode.getSucc(1) && cnode.getSucc(1)->traverse_id == -1)
          cnode.backedge_locs[1] = CFGnode::ALL_AOS;
      } else { //- all other cases
        for(int i = 0; cnode.getSucc(i); ++i)
          if(cnode.getSucc(i)->traverse_id == -1){ //- if *ANY* successor is back-edge,	then mark backedge_locs[0]=true
            cnode.backedge_locs[0] = CFGnode::ALL_AOS;
            break;
          }
      }
    } /////////////////////////////////////////////

    for(int i = 0; cnode.getSucc(i); ++i)
      assignId(*cnode.getSucc(i));

    cnode.traverse_id = ++assignIds_counter;
  }
}

//- also marks backedges for widen/narrow (see comment above assignId()).
//- and also computes backedge filter sets
void CFG::assignIds()
{
  if(flag_verbose) TCstats::timer("assigning CFG ids (post-order depth-first)");

  suco_iterator<CFGfunction *> fni(this->getFunctionList());
  while(fni.Iterate()){
    //-- number both stmts and bblocks
    // - for now, use same counter (i.e., non-clashing ids)
    assignIds_counter = 0;
    if(fni.Current()->entrystmt)
      assignId(*fni.Current()->entrystmt);
    if(fni.Current()->entryblock)
      assignId(*fni.Current()->entryblock);
  }

  if(flag_verbose) TCstats::timer(0);
}

//----------------------------------
// COLLECT BACKEDGE FILTERS
//----------------------------------

//- SY NOTE: this function does not collect GFreeHeap info.
//  Since the result of this function is used only for a
//  backedge-widening filter, we don't need to worry about
//  MayFree effects, because that should only affect dataflow
//  facts finitely (right?).
bool CFG::collectMODecrs(PgmExpr& pe)
{
  switch(pe.getKind()){
    case PgmExpr::fCall:{
      suco_iterator<CFGfunction *> tfi(((PExprCall&)pe).getTargetFns());
      while(tfi.Iterate()){
        tfi.Current()->getGMOD().addToEcrSet(CFGfunction::clie_imod_ecrs);
      }
    } break;
    case PgmExpr::fAssign:{
      CFGfunction::collectIMODREF(((PExprAssign&)pe).getLHS().getAOs(), true);	// writes directly into CFGfunction::clie_imod_ecrs
    } break;
  }
  return true; //- true ensures full traversal
}

//- return true if OK, false if problem (i.e., if has goto or label)
bool CFG::collectModSetUntil(PgmStmt * exitnode, suco_iterator<PgmStmt *>& si, LocSet& modlocs)
{
  CFGfunction::clie_imod_ecrs.Clear();
  while(si.Iterate() && si.Current() != exitnode){
    PgmStmt& stmt = *si.Current();
    if(stmt.nlabels || (stmt.annot.kind == PgmStmt::Annot::aGoto)){
      return false;  //- has goto or label
    }
    //- collect mod set into clie_imod_ecrs
    stmt.traverseRootNodes(CFG::collectMODecrs);
  }
  modlocs.AbsorbConsume(CFGfunction::clie_imod_ecrs);
  CFGfunction::clie_imod_ecrs.Clear();
  return true;
}

void CFG::computeBackedgeFilters()
{
  TCstats::timer("computing backedge filters");
  suco_iterator<CFGfunction *> fni(this->getFunctionList());
  while(fni.Iterate()){

    //- iterate through sequential stmt list searching for structured loops

    suco_iterator<PgmStmt *> si(fni.Current()->getStmtList());
    while(si.Iterate()){
      PgmStmt& stmt = *si.Current();

      CFGnode * cnode = stmt.getCFGactiveNode();
      if(cnode){
        //- find loop-head signatures: 1. While
	//  [(p)while]--T->[loop head].../-->[loop exit]
	//            \-F---------------/
	if(stmt.annot.kind == PgmStmt::Annot::aWhile){
	  if(cnode->getNsuccs() == 2 && cnode->getSucc(1)){
	    LocSet modlocs;
	    suco_iterator<PgmStmt *> tsi(si);
	    tsi.Rewind(); //- must include current
	    if(collectModSetUntil(cnode->getSucc(1)->getStmtList().Head(), tsi, modlocs)){
	      //- find backedge(s)
	      for(int i = 0; cnode->getPred(i); ++i)
		cnode->getPred(i)->updateBackEdgeIfSet(*cnode, modlocs);
	    }
	  } else fprintf(stderr, "ERROR(CFG::computeBackedgeFilters): malformed while loop has %d successors\n", cnode->getNsuccs());
	}

	//- find loop-head signatures: 2. For
	//  [for]-->[pred]<--[incr] /-->[loop head].../-->[loop exit]
	//               \-T-------/                 /
	//                \-F-----------------------/
	if(stmt.annot.kind == PgmStmt::Annot::aFor){
	  if(si.Iterate()){
	    PgmStmt& predstmt = *si.Current();
	    //- TODO?: assert (pred in stmt.succ) and (succ in pred.pred)
	  
	    CFGnode * pnode = predstmt.getCFGactiveNode();
	    if(pnode){
	      if(pnode->getNsuccs() == 2 && pnode->getSucc(1)){
		LocSet modlocs;
		suco_iterator<PgmStmt *> tsi(si);
		tsi.Rewind(); //- must include current (pred)
		if(collectModSetUntil(pnode->getSucc(1)->getStmtList().Head(), tsi, modlocs)){
		  //- find backedge(s) (should be only one, from [incr] to [pred])
		  for(int i = 0; pnode->getPred(i); ++i)
		    pnode->getPred(i)->updateBackEdgeIfSet(*pnode, modlocs);
		}
	      } else fprintf(stderr, "ERROR(CFG::computeBackedgeFilters): malformed FOR predicate has %d successors\n", pnode->getNsuccs());
	    } //- !cnode: stmt has no bblock, must be unreachable
	  } else fprintf(stderr, "ERROR(CFG::computeBackedgeFilters): malformed FOR loop - misplaced predicate statement\n");
	}

	//- find loop-head signatures: 3. DoWhile
	//  [loop head]<--(bk)T--[(p)dowhile]--F-->[loop exit]
	for(int i = 0; cnode->getPred(i); ++i){
	  CFGnode& prednode = *cnode->getPred(i);
	  PgmStmt * predstmt = prednode.getStmtList().Last();
	  if(predstmt && predstmt->annot.kind == PgmStmt::Annot::aDoWhile && prednode.getSucc(0) == cnode){
	    PgmStmt * tailstmt = predstmt;
	    if(prednode.getNsuccs() == 2 && prednode.getSucc(1)){
	      tailstmt = prednode.getSucc(1)->getStmtList().Head();
	    } else fprintf(stderr, "ERROR(CFG::computeBackedgeFilters): malformed DOWHILE loop has %d successors\n", prednode.getNsuccs());
	    LocSet modlocs;
	    suco_iterator<PgmStmt *> tsi(si);
	    tsi.Rewind(); //- must include current (pred)
	    if(collectModSetUntil(tailstmt, tsi, modlocs)){
	      //- find backedge(s) (should be only one, from [dowhile] to [loop head]
	      prednode.updateBackEdgeIfSet(*cnode, modlocs);
	    }
	  }
	}
      } //- !cnode: stmt has no bblock, must be unreachable
    }
  }
  TCstats::timer(0);
}

//- - -

//------------------------------------------------------
// "Find Remaining Backedges"
//------------------------------------------------------
//- Called in CFG initialization cycle, to detect cycles
//  after per-procedure DFS search and recursion-check.
//  These would be faux-cycles due to context-insensitivity.
//- The traversal proceeds as follows:
//  - find_remaining_backedges_touched is the marker, initially all 0
//  - when traversing, set marker to -1; when done, set marker to 1
//  - three different kinds of nodes to handle:
//	- call node: traverse callee entry nodes, with entryfn=callee
//	- return node: traverse caller nodes' successors, with entryfn=return node's parent
//	- otherwise: traverse successors, with entryfn=0
//  - when loop encountered, i.e. if marker is already -1
//	- if entryfn is set, then must enable the backedges of
//	  all of entryfn's return nodes 
//	- if entryfn is not set, do nothing (because loop
//	  is an intra-procedural loop, already previously detected)
void CFGnode::findRemainingBackedges(CFGfunction * entryfn)
{
  //- 0=new, -1=active, 1=visited
  if(this->find_remaining_backedges_touched == 1){ //- visited: cross-edge, do nothing
    return;
  } else if(this->find_remaining_backedges_touched == -1){ //- active: back-edge
    if(entryfn){
      // enable backedges for all of entryfn's retnodes
/**/  bool debug_written = false;
      suco_iterator<PgmStmt *> eni(entryfn->getExitNodes());
      while(eni.Iterate()){
        CFGnode * exnode = eni.Current()->getCFGactiveNode();
        if(exnode){
/**/      if(flag_verbose && !debug_written && !exnode->backedge_locs[0]){
/**/        fprintf(stderr, "NOTE: Found Remaining Backedge For Function %s\n", entryfn->getId().getPid().getname());
/**/        debug_written = true;
/**/      }
          if(flag_range_filter_call_backedge){
            if(!exnode->backedge_locs[0]){
              exnode->backedge_locs[0] = new LocSet;
            }
            if(exnode->backedge_locs[0] != ALL_AOS){
              exnode->backedge_locs[0]->Union(entryfn->getGREF());	//- gref, because modification may not be within entryfn
            }
          } else {
            exnode->backedge_locs[0] = ALL_AOS;
          }
        } else fprintf(stderr, "ERROR(findRemainingBackedges): null cnode encountered!\n");
      }
    } //- else do nothing
    return;
  } else { //- new: check calls successors; traverse return successors; traverse regular successors

    this->find_remaining_backedges_touched = -1; //- mark active

    if(this->hascall){	// this node has calls: traverse call successors
			// NOTE: imprecision: this node may have non-call path -- assuming they don't exist.  Safe??
      //- assert: never any calls in exit nodes?
      if(this->isExitNode())
        fprintf(stderr, "ERROR(findRemainingBackedges): call node is an exit node!\n");

      //- process calls in this node
      suco_iterator<PgmStmt *> psi(this->getStmtList());
      while(psi.Iterate()){
        psi.Current()->traverseRootNodes(CFGnode::findRemainingCallBackedges);
      }

    } else if(this->isExitNode()){ //- return node: traverse return successors
      //- assert: return node has no regular successors
      if(this->getNsuccs())
        fprintf(stderr, "ERROR(findRemainingBackedges): return node has %d regular successors!\n", this->getNsuccs());

      //- find callsite successors
      //- NOTE: because our callsite nodes aren't split into two
      //  (which would've made life a lot easier), we'll check
      //  starting from the _successor_ of the callsite node.
      suco_iterator<PExprCall *> csi(this->getParentFunction().getCallSites());
      while(csi.Iterate()){
        CFGnode * cnode = (csi.Current()->getParentNode())
			  ? (csi.Current()->getParentNode()->getCFGactiveNode())
			  : 0;
        if(cnode){
          for(int i = 0; cnode->getSucc(i); ++i){
            cnode->getSucc(i)->findRemainingBackedges(&this->getParentFunction());
          }
        } else fprintf(stderr, "ERROR(findRemainingBackedges): callsite has no CFGnode!\n");
      }
    } else { //- non-call non-return node: traverse regular successors

      for(int i = 0; this->getSucc(i); ++i){
        this->getSucc(i)->findRemainingBackedges();
      }

    }

    this->find_remaining_backedges_touched = 1; //- mark done
  }
}

bool CFGnode::findRemainingCallBackedges(PgmExpr& pe)
{
  if(pe.getKind() == PgmExpr::fCall){
    PExprCall& pec = (PExprCall&)pe;
    if(pec.getTargetFns().IsEmpty()){ //- no target function: must resume from callnode's successor

      CFGnode * cnode = (pec.getParentNode())
			? (pec.getParentNode()->getCFGactiveNode())
			: 0;
      if(cnode){
        for(int i = 0; cnode->getSucc(i); ++i){
          cnode->getSucc(i)->findRemainingBackedges();
        }
      } else fprintf(stderr, "ERROR(findRemainingCallBackedges): callsite has no CFGnode!\n");

    } else {

      suco_iterator<CFGfunction *> tfi(pec.getTargetFns());
      while(tfi.Iterate()){
        CFGnode * fentry = tfi.Current()->getEntryNode();
        if(fentry){
          fentry->findRemainingBackedges(tfi.Current());
        } else fprintf(stderr, "ERROR(findRemainingCallBackedges): callee has no entry node!\n");
      }

    }
  }
  return true; //- true ensures full traversal
}

//----------------------------------
// COLLECT LOCAL DECLS
//----------------------------------

suco_set<AOId *> * CFGfunction::clie_curlvars = 0;
suco_set<AO *> * CFGfunction::clie_ifree_stack = 0;
suco_set<ECR *> CFGfunction::clie_ifree_heap_ecrs;
suco_set<ECR *> CFGfunction::clie_iref_ecrs;
suco_set<ECR *> CFGfunction::clie_imod_ecrs;
suco_set<AO *> CFGfunction::clie_callsite_retaos;

void CFGfunction::collectIMODREF(suco_set<AO *>& aoset, bool imod)
{
  suco_iterator<AO *> aoi(aoset);
  while(aoi.Iterate()){
    if(!aoi.Current()->isVal()){ //- filter out values
      if(flag_gmodref_skip_locals && CFGfunction::clie_curlvars){
        ////////////////////////////////////////////////////////////
        //- if -gmodref-skip-locals flag is on, then exclude
        //  direct accesses to local variables from GMOD/REF set.
        //~ Uses clie_curlvars to do the filtering.
        //  (clie_curlvars == 0 means this is being called from
        //   collectMODecrs, for backedge filtering, in which case
        //   we want to keep the locals.)
        AO * tgt_ao = aoi.Current();
        //- de-(op/ext)
        while(1){
          if(tgt_ao->getKind() == AO::aoOp){
            tgt_ao = &((AOOp *)tgt_ao)->getTarget();
          } else if(tgt_ao->getKind() == AO::aoExt){
            tgt_ao = &((AOExt *)tgt_ao)->getTarget();
          } else {
            break; //- break out of loop
          }
        }
        if(tgt_ao->isLoc() && CFGfunction::clie_curlvars->Contains((AOId *)&tgt_ao->getEnclosingStruct())){
          //- discard
        } else {
          if(imod) CFGfunction::clie_imod_ecrs.Union(tgt_ao->getECR().getAliasECRs());
          else     CFGfunction::clie_iref_ecrs.Union(tgt_ao->getECR().getAliasECRs());
        }
      } else {
        if(imod) CFGfunction::clie_imod_ecrs.Union(aoi.Current()->getECR().getAliasECRs());
        else     CFGfunction::clie_iref_ecrs.Union(aoi.Current()->getECR().getAliasECRs());
      }
    }
  }
}

bool CFGfunction::collectLocalsAndIMODREFexpr(PgmExpr& df)
{
  switch(df.getKind()){
    case PgmExpr::fDecl: {
        if(CFGfunction::clie_curlvars){ //- assertion
          PExprDecl& dd = (PExprDecl &)df;
          if(dd.isLocal() || dd.isFormal() || dd.isAlloca()){
            CFGfunction::clie_curlvars->Insert((AOId *)&dd.getAO());
            CFGfunction::clie_ifree_stack->Insert((AOId *)&dd.getAO());
          } //-- else isMalloc or isStatic
        } else fprintf(stderr, "CFGfunction::collectLocalsAndIREFexpr (decl) error -- clie_curlvars not set\n");
      } break;
    case PgmExpr::fCall: {
        PExprCall& dc = (PExprCall &)df;
        //- add I <fao>s (to iref)
        CFGfunction::collectIMODREF(dc.getFaos(), false);

        //- collect R D I <fao>s, which will be added to both imod and iref
        suco_iterator<AO *> faoi(dc.getFaos());
        while(faoi.Iterate())
          CFGfunction::clie_callsite_retaos.Insert(&faoi.Current()->get_AOStar().get_AOReturn());

        //- add actual args (to iref)
        for(int i = 1; dc.getArg(i); ++i){
          CFGfunction::collectIMODREF(dc.getArg(i)->getDesc().getAOs(), false);
        }
        if(dc.callsFree()){
          PExprArg * freearg = dc.getArg(1);
          if(freearg){ //- collect freed heap ecrs
            suco_iterator<AO *> aoi(freearg->getDesc().getAOs());
            while(aoi.Iterate()){
              if(!aoi.Current()->isVal()){ //- skip values
                CFGfunction::clie_ifree_heap_ecrs.Union(aoi.Current()->getECR().getPointsTo().getAliasECRs());
              }
            }
          }
        }
      } break;
    case PgmExpr::fAssign: {
        PExprAssign& da = (PExprAssign &)df;
        CFGfunction::collectIMODREF(da.getLHS().getAOs(), true);  // > separate imod from iref for now
        CFGfunction::collectIMODREF(da.getLHS().getAOs(), false); // > TODO: may want to consider imod part of iref?
        CFGfunction::collectIMODREF(da.getRHS().getAOs(), false); //-- note: redundant with vtRhs collection below
      } break;
    case PgmExpr::fPredicate: {
        //- ignore
      } break;
    case PgmExpr::fVerify: { //-- note: vtRhs verifies are redundant with fAssign rhs collection above
        PExprVerify& dv = (PExprVerify &)df;
        CFGfunction::collectIMODREF(dv.getAOs(), false);
      } break;
    case PgmExpr::fParallel:
    case PgmExpr::fBranch:
    default: {
	fprintf(stderr, "WARNING: collectLocalsAndIMODREFexpr with invalid node kind\n");
      } break;
  }
  return true; //- true ensures full traversal
}

//- HAS BEEN AUGMENTED to compute also:
//  - MayFreeHeap and MayFreeStack sets
void CFGfunction::collectLocalsAndIMODREF()
{
  CFGfunction::clie_curlvars = &this->localvars;
  CFGfunction::clie_ifree_stack = &this->gfreestack;
  CFGfunction::clie_ifree_heap_ecrs.Clear();
  CFGfunction::clie_iref_ecrs.Clear();
  CFGfunction::clie_imod_ecrs.Clear();
  CFGfunction::clie_callsite_retaos.Clear();
  suco_iterator<PgmStmt *> cni(this->cfglist);
  while(cni.Iterate()){
    cni.Current()->traverseRootNodes(CFGfunction::collectLocalsAndIMODREFexpr);
  }

  //- collect AOs from ECR sets; filter out non-location AOs
  if(flag_compute_iref){
    this->iref.AbsorbConsume(CFGfunction::clie_iref_ecrs);
  }
  this->gref.AbsorbConsume(CFGfunction::clie_iref_ecrs);
  this->gmod.AbsorbConsume(CFGfunction::clie_imod_ecrs);

  //- absorb callsite retaos (R D <ao>) into both iref and imod
  suco_iterator<AO *> raoi(CFGfunction::clie_callsite_retaos);
  while(raoi.Iterate()){
    if(flag_compute_iref) this->iref.Insert(*raoi.Current());		//-?
    this->gref.Insert(*raoi.Current());
    this->gmod.Insert(*raoi.Current());
  }

  //- special: add return node "R X I <thisfn>" to gmod/gref
  AOFunction& fnao = (AOFunction&) this->getId().get_AOFunction();
  this->gmod.Insert(fnao.get_AOReturn());
  this->gref.Insert(fnao.get_AOReturn());

  //- special: add argument nodes "F X I <thisfn>" to gref
  //  NOTE: also added to gmod -- this is at least needed for identifying
  //        recursive-call widening filter.
  //        TODO: think about whether this makes sense as a general policy.
  for(int i = 1; i <= fnao.getLargNo(); ++i){
    AO * argao = fnao.get_AOArg(i);
    if(argao){
      this->gmod.Insert(*argao);
      this->gref.Insert(*argao);
    } else {
      fprintf(stderr, "ERROR(CFGfunction::collectLocalsAndIMODREF): arg(%d) ao not found for ", i);
      fnao.dump_descr(stderr);
      fprintf(stderr, "\n");
    }
  }

  //- free-heap ecrs
  this->gfreeheap_ecrs.UnionConsume(CFGfunction::clie_ifree_heap_ecrs);
  //- filter out ecrs with no malloc aos
  suco_iterator<ECR *> ei(this->gfreeheap_ecrs);
  while(ei.Iterate()){
    bool has_malloc = false;
    suco_iterator<AO *> ai(ei.Current()->getAOset());
    while(ai.Iterate()){
      if(ai.Current()->getKind() == AO::aoMalloc){
        has_malloc = true;
        break;
      }
    }
    if(!has_malloc){
      ei.DeleteCurrent();
    }
  }

  if(flag_verbose){
    fprintf(stderr, "(IMOD %d aos in %d entries)(IREF %d aos in %d entries)\n"
		    "(IFREE:heap %d ecrs, stack %d aos)\n"
		  , this->gmod.numAOs(), this->gmod.Size()
		  , this->gref.numAOs(), this->gref.Size()
		  , this->gfreeheap_ecrs.Length()
		  , this->gfreestack.Length());
  }
  CFGfunction::clie_callsite_retaos.Clear();
  CFGfunction::clie_iref_ecrs.Clear();
  CFGfunction::clie_imod_ecrs.Clear();
  CFGfunction::clie_ifree_heap_ecrs.Clear();
  CFGfunction::clie_curlvars = 0;
  CFGfunction::clie_ifree_stack = 0;
}

void CFG::collectLocalsAndIMODREF()
{
  TCstats::timer("collecting function local variables and IMOD/IREF");

  int numlocals = 0;
  int numimods = 0;
  int numirefs = 0;
  int numifreeheap = 0;
  int numifreestack = 0;
  suco_iterator<CFGfunction *> fni(this->fnlist);
  while(fni.Iterate()){
    if(flag_verbose) TCstats::timer(fni.Current()->getId().getPid().getname());
    fni.Current()->collectLocalsAndIMODREF();
    numlocals += fni.Current()->getLocalVars().Length();
    numimods += fni.Current()->getGMOD().numAOs();
    numirefs += fni.Current()->getGREF().numAOs();
    numifreeheap += fni.Current()->getGFreeHeap_ecrs().Length();
    numifreestack += fni.Current()->getGFreeStack().Length();
    if(flag_verbose) TCstats::timer(0);
  }

  TCstats::timer(0);
  fprintf(stderr, "(locals %d, imod %d, iref %d, free-heap %d, free-stack %d)\n",
		numlocals, numimods, numirefs, numifreeheap, numifreestack);
}

int CFGfunction::compareByCallgraphId(CFGfunction * fn1, CFGfunction * fn2)
{
  int rid1 = fn1->getRecursionId();
  int rid2 = fn2->getRecursionId();
  int cid1 = fn1->getCallGraphId();
  int cid2 = fn2->getCallGraphId();

  if(rid1 != rid2){
    cid1 = rid1?rid1:cid1;
    cid2 = rid2?rid2:cid2;
  }

  return cid1-cid2;
}

void CFG::collectGMODREF()
{
  if(flag_verbose) TCstats::timer("collecting GMOD/GREF");

  suco_set<CFGfunction *> ofnset(CFGfunction::compareByCallgraphId);

  {
    suco_iterator<CFGfunction *> fni(fnlist);
    while(fni.Iterate())
      ofnset.Insert(fni.Current());
  }

  //-- ofnset is now fnlist ordered by callgraph_id

  if(flag_verbose >= 3){
    fprintf(stderr, "---CALLGRAPH---\n");

    suco_iterator<CFGfunction *> ofni(ofnset);
    while(ofni.Iterate()){
      CFGfunction& fn = *ofni.Current();

      fprintf(stderr, "%s-%d(r%d):", fn.getId().getPid().getname(),
					fn.getCallGraphId(), fn.getRecursionId());

      suco_iterator<CFGfunction *> cgi(fn.callgraph);
      while(cgi.Iterate()){
        fprintf(stderr, " %s-%d(r%d)", cgi.Current()->getId().getPid().getname(),
					cgi.Current()->getCallGraphId(), cgi.Current()->getRecursionId());
      }
      fprintf(stderr, "\n");
    }
    fprintf(stderr, "---END CALLGRAPH---\n");
  }

  while(!ofnset.IsEmpty()){
    CFGfunction& fn = *ofnset.RemoveHead();

    //- union imods/irefs from children
    suco_iterator<CFGfunction *> cgi(fn.callgraph);
    while(cgi.Iterate()){
      fn.gmod.Union(cgi.Current()->gmod);
      fn.gref.Union(cgi.Current()->gref);
      fn.gfreeheap_ecrs.Union(cgi.Current()->gfreeheap_ecrs);
      fn.gfreestack.Union(cgi.Current()->gfreestack);
    }

    //- if recursive...
    if(fn.getRecursionId()){
      //- union imods/irefs for all nodes with same recursion_id
      suco_iterator<CFGfunction *> rfi(ofnset);
      while(rfi.Iterate() && rfi.Current()->getRecursionId() == fn.getRecursionId()){
        fn.gmod.Union(rfi.Current()->gmod);
        fn.gref.Union(rfi.Current()->gref);
        fn.gfreeheap_ecrs.Union(rfi.Current()->gfreeheap_ecrs);
        fn.gfreestack.Union(rfi.Current()->gfreestack);
        //- do their children as well!
        suco_iterator<CFGfunction *> rci(rfi.Current()->callgraph);
        while(rci.Iterate()){
          fn.gmod.Union(rci.Current()->gmod);
          fn.gref.Union(rci.Current()->gref);
          fn.gfreeheap_ecrs.Union(rci.Current()->gfreeheap_ecrs);
          fn.gfreestack.Union(rci.Current()->gfreestack);
        }
      }
      //- replicate this union-set onto these members, and remove them
      while(ofnset.Head() && ofnset.Head()->getRecursionId() == fn.getRecursionId()){
        ofnset.Head()->gmod.Union(fn.gmod);
        ofnset.Head()->gref.Union(fn.gref);
        ofnset.Head()->gfreeheap_ecrs.Union(fn.gfreeheap_ecrs);
        ofnset.Head()->gfreestack.Union(fn.gfreestack);
        ofnset.RemoveHead();
      }
    }
  }

  if(flag_verbose) TCstats::timer(0);
}

//----------------------------------
// OTHER MEMBER FUNCTIONS
//----------------------------------

CFGnode * CFGfunction::getEntryNode() const
{
  if(flag_use_bblocks)
    return entryblock;
  else
    return entrystmt;
}

//- used by RDMBc
void CFGfunction::collectCallers(CFGfunction& fn, suco_set<CFGfunction *>& fns)
{
  if(fns.Insert(&fn)){
    suco_iterator<PExprCall *> csi(fn.getCallSites());
    while(csi.Iterate()){
      PgmStmt * par = csi.Current()->getParentNode();
      if(par) CFGfunction::collectCallers(par->getParentFunction(), fns);
    }
  } //- else already added
}

void CFGfunction::writeCallgraphDotEntry(FILE * outf)
{
#define BUFSZ 16
  static char buf[BUFSZ] = {0};

  fprintf(outf, "  n%d_%d[label=\"(%s)\\n%s\"];\n",
		this->aid.filestem_id, this->aid.aid,
		this->aid.lookupFileStem(),
		strncpy(buf, strrchr(this->idao.getPid().getname(), '.')+1, BUFSZ-1));

  suco_iterator<CFGfunction *> cgi(this->callgraph);
  while(cgi.Iterate()){
    CFGfunction& tgtfn = *cgi.Current();
    fprintf(outf, "  n%d_%d -> n%d_%d%s;\n",
		this->aid.filestem_id, this->aid.aid,
		tgtfn.aid.filestem_id, tgtfn.aid.aid,
		(this->getRecursionId() && (this->getRecursionId() == tgtfn.getRecursionId()))
			?"[label=\"(r)\"]":"");
  }
#undef BUFSZ
}

void CFGfunction::write_descr(FILE * outf, const char * prefix, int indent)
{
  const char * ispaces = getIndent(indent);
  fprintf(outf, "%s%s%d:%s(%s)", ispaces, prefix,
		this->getCallGraphId(),
		this->idao.getPid().getname(),
		this->aid.lookupFileStem());

  if(this->getRecursionId()){
    fprintf(outf, " [SCC %d]\n", this->getRecursionId());
  } else {
    fprintf(outf, "\n");
  }
}

void CFGfunction::bottomUpWriteCalltrace(FILE * outf, int indent)
{
#define INDENT_LIMIT 10
  this->write_descr(outf, "*", indent);
  suco_set<CFGfunction *> callers;
  suco_iterator<PExprCall *> csi(this->callsites);
  while(csi.Iterate()){
    CFGnode * parnode = csi.Current()->getParentNode();
    if(parnode &&
	callers.Insert(&parnode->getParentFunction()))
      parnode->getParentFunction().write_descr(outf, "<-", indent+2);
  }

  if(indent <= INDENT_LIMIT){
    suco_iterator<CFGfunction *> cfi(callers);
    while(cfi.Iterate()){
      if(cfi.Current()->getCallGraphId() > this->getCallGraphId())
        cfi.Current()->bottomUpWriteCalltrace(outf, indent+2);
    }
  }
#undef INDENT_LIMIT
}

void CFGfunction::topDownWriteCalltree(FILE * outf, int indent)
{
  this->write_descr(outf, "", indent);
  if(!this->getRecursionId()){
    suco_iterator<CFGfunction *> cgi(this->callgraph);
    while(cgi.Iterate()){
      cgi.Current()->topDownWriteCalltree(outf, indent+2);
    }
  }
}

void CFG::writeCallgraph(FILE * outf, bool dot, char * trace_fn)
{
  this->prepareSuperGraph();
  if(dot){
    fprintf(outf, "digraph callgraph {\n");
    suco_iterator<CFGfunction *> fni(this->getFunctionList());
    while(fni.Iterate()){
      fni.Current()->writeCallgraphDotEntry(outf);
    }
    fprintf(outf, "}\n");
  } else if(trace_fn){
    suco_iterator<CFGfunction *> fni(this->getFunctionList());
    while(fni.Iterate()){
      if(strstr(fni.Current()->getId().getPid().getname(), trace_fn)){
        fprintf(outf, "CALL TRACE FOR %s:\n", fni.Current()->getId().getPid().getname());
        fni.Current()->bottomUpWriteCalltrace(outf, 0);
      }
    }
  } else {
    //-- main tree
    fprintf(outf, "MAIN:\n");
    if(this->mainfn){
      this->mainfn->topDownWriteCalltree(outf, 0);
    }
    //-- recursive subtrees
    suco_set<int> recursids;
    suco_iterator<CFGfunction *> fni(this->getFunctionList());
    while(fni.Iterate())
      recursids.Insert(fni.Current()->getRecursionId());

    suco_iterator<int> ri(recursids);
    while(ri.Iterate()){
      fprintf(outf, "[SCC %d]:\n", ri.Current());
      fni.Rewind();
      while(fni.Iterate()){
        if(fni.Current()->getRecursionId() == ri.Current()){
          fni.Current()->write_descr(outf, "", 0);
          suco_iterator<CFGfunction *> fcgi(fni.Current()->callgraph);
          while(fcgi.Iterate()){
            fcgi.Current()->topDownWriteCalltree(outf, 2);
          }
        }
      }
    }
  }
}

const char * PgmExpr::getKindString() const
{
  switch(kind){
    case fCall:     return "Call";
    case fAssign:   return "Assign";
    case fPredicate:return "Predicate";
    case fDecl:     return "Decl";
    case fVerify:   return "Verify";
    case fParallel: return "Parallel";
    case fBranch:   return "Branch";
  }
  return "<Kind:ERROR>";
}

bool PgmExpr::isLib()
{
  return this->parent && this->parent->getParentFunction().getId().isLib();
}

suco_set<AO *> PExprPredicate::empty_aos; //- static placeholder: empty list

const char * PExprPredicate::getPrKindString() const
{
  switch(pkind){
    case prAnd:	   return "And";
    case prOr:	   return "Or";
    case prQC:	   return "QC";
    case prStmt:   return "Stmt";
    case prSwitch: return "Switch";
  }
  return "<PrKind:ERROR>";
}

const char * PExprDecl::getDkindString() const
{
  switch(dkind){
    case dFormal: return "Formal";
    case dLocal:  return "Local";
    case dStatic: return "Static";
    case dMalloc: return "Malloc";
  }
  return "<DKind:ERROR>";
}

const char * PExprVerify::getVtKindString() const
{
  switch(vtkind){
    case vtTag:  return " vtTag";
    case vtRhs:  return " vtRhs";
    case vtNone: return "";
  }
  return "<VtKind:ERROR>";
}

const char * PExprVerify::getVpKindString() const
{
  switch(vpkind){
    case vpPtr:  return " vtPtr";
    case vpPtrW: return " vtPtrW";
    case vpNone: return "";
  }
  return "<VpKind:ERROR>";
}

//- - - - - - - - - - - - - - - - - -

LocSet * CFGnode::getBackEdge() const
{
  if(backedge_locs[0] && backedge_locs[1] &&
	backedge_locs[0] != backedge_locs[1]){ //- assertion
    fprintf(stderr, "WARNING(CFGnode::getBackEdge): requested one backedge when two are present\n");
    return ALL_AOS;
  }
  return backedge_locs[0]?backedge_locs[0]:backedge_locs[1];
}

LocSet * CFGnode::getBackEdge(bool tf) const
{
  return backedge_locs[tf?0:1];
}

void CFGnode::updateBackEdgeIfSet(CFGnode& tgtnode, LocSet& lset)
{
  int index = (this->getSucc(1) == &tgtnode)?1:0;	//- if tgtnode is first (false) successor,
							//  then backedge indicator is at [1], else it's at [0]
  if(backedge_locs[index] == ALL_AOS){
    backedge_locs[index] = new LocSet;
    backedge_locs[index]->Union(lset);
  } else if(backedge_locs[index]){
    backedge_locs[index]->Union(lset);
  } //- else not set, so don't update
}

//- If pe is a recursive call, must set both widen_locs
//  and retnode->backedge_locs (to ALL_AOS or GMOD,
//  depending on flag_range_filter_call_backedge)
//  - note that each recursive call results in two
//    loops that must be broken:
//    - caller-to-callee_entry (captured by widen_locs)
//    - callee_return-to-caller (captured by retnode->backedge_locs)
bool CFGnode::computeWidenAOs(PgmExpr& pe)
{
  if(pe.getKind() == PgmExpr::fCall){
    PExprCall& pec = (PExprCall&)pe;
    int pec_recurs_id = (pec.getParentNode())
			? (pec.getParentNode()->getParentFunction().getRecursionId())
			: 0;
    if(pec_recurs_id){

      suco_iterator<CFGfunction *> tfi(pec.getTargetFns());
      while(tfi.Iterate()){
        if(tfi.Current()->getRecursionId() == pec_recurs_id){

          //-- call is recursive: DO STUFF HERE

          if(flag_range_filter_call_backedge){
            if(pec.widen_locs != CFGnode::ALL_AOS){	//- paranoid check
              if(!pec.widen_locs){
                pec.widen_locs = new LocSet;
              }
              pec.widen_locs->Union(tfi.Current()->getGMOD());
            } else {
/**/          fprintf(stderr, "ERROR(computeWidenAOs): ALL_AOS widen_aos encountered!\n");
            }

            suco_iterator<PgmStmt *> eni(tfi.Current()->getExitNodes());
            while(eni.Iterate()){
              CFGnode * cnode = eni.Current()->getCFGactiveNode();
              if(cnode && cnode->backedge_locs[0] != CFGnode::ALL_AOS){
                if(!cnode->backedge_locs[0]){
                  cnode->backedge_locs[0] = new LocSet;
                }
                cnode->backedge_locs[0]->Union(tfi.Current()->getGMOD());
              } else {
/**/            fprintf(stderr, "ERROR(computeWidenAOs): null cnode or ALL_AOS backedge_locs encountered!\n");
              }
            }

          } else { //- don't filter: just mark and break out (no need to check individual targets further)
            pec.widen_locs = CFGnode::ALL_AOS;
            suco_iterator<PgmStmt *> eni(tfi.Current()->getExitNodes());
            while(eni.Iterate()){
              CFGnode * cnode = eni.Current()->getCFGactiveNode();
              if(cnode) cnode->backedge_locs[0] = CFGnode::ALL_AOS;
            }
          }
        }
      }
    }
  }
  return true; //- true ensures full traversal
}

void CFGnode::addSuccessor(CFGnode& n)
{
  //-- add &n to successor list
  if(!succs){
    succs = new CFGnode * [2];
    nsuccs = 1;
    succs[0] = &n;
    succs[nsuccs] = 0;
  }
  else {
    int i;
    for(i = 0; i < nsuccs; ++i){
      if(!succs[i]){
        succs[i] = &n;
        break;
      }
    }
    if(i == nsuccs){
      fprintf(stderr, "CFGnode::addSuccessor: infrequent case encountered! (nsuccs=%d)\n", nsuccs);
      CFGnode ** temp = succs;
      succs = new CFGnode * [nsuccs+2];
      for(i = 0; i < nsuccs; ++i)
        succs[i] = temp[i];
      succs[i] = &n;
      nsuccs++;
      succs[nsuccs] = 0;
      delete [] temp;
    }
  }
  //-- add this to n.predecessor list
  if(!n.preds){
    n.preds = new CFGnode * [2];
    n.npreds = 1;
    n.preds[0] = this;
    n.preds[n.npreds] = 0;
  }
  else {
    int i;
    for(i = 0; i < n.npreds; ++i){
      if(!n.preds[i]){
        n.preds[i] = this;
        break;
      }
    }
    if(i == n.npreds){
//      fprintf(stderr, "CFGnode::addPredecessor: infrequent case encountered! (npreds=%d)\n", n.npreds);
      CFGnode ** temp = n.preds;
      n.preds = new CFGnode * [n.npreds+2];
      for(i = 0; i < n.npreds; ++i)
        n.preds[i] = temp[i];
      n.preds[i] = this;
      n.npreds++;
      n.preds[n.npreds] = 0;
      delete [] temp;
    }
  }
}

void CFGnode::initSuccsCount(int n)
{
  if(n){
    if(!succs){
      succs = new CFGnode * [n+1];
      nsuccs = n;
      for(int i = 0; i <= nsuccs; ++i) succs[i] = 0;
    } else if(nsuccs < n){
      CFGnode ** temp = succs;
      succs = new CFGnode * [n+1];
      int i;
      for(i = 0; i < nsuccs; ++i) succs[i] = temp[i];
      delete [] temp;
      nsuccs = n;
      for(; i <= nsuccs; ++i) succs[i] = 0;
    }
  }
}

void CFGnode::initPredsCount(int n)
{
  if(n){
    if(!preds){
      preds = new CFGnode * [n+1];
      npreds = n;
      for(int i = 0; i <= npreds; ++i) preds[i] = 0;
    } else if(npreds < n){
      CFGnode ** temp = preds;
      preds = new CFGnode * [n+1];
      int i;
      for(i = 0; i < npreds; ++i) preds[i] = temp[i];
      delete [] temp;
      npreds = n;
      for(; i <= npreds; ++i) preds[i] = 0;
    }
  }
}

int CFGnode::countPreds() const
{
  int i;
  for(i = 0; i < npreds && preds[i]; ++i)
    ;
  return i;
}

int CFGnode::countSuccs() const
{
  int i;
  for(i = 0; i < nsuccs && succs[i]; ++i)
    ;
  return i;
}

bool CFGnode::isEntryNode() const
{
  return (this == parent.getEntryNode());
}

bool CFGbblock::isExitNode()
{
  PgmStmt * tail = stmtlist.Last();
  return (tail && tail->isReturn());
}

bool PgmStmt::isExitNode()
{
  return this->isReturn();
}

bool PgmStmt::hasLabel(const char * s) const
{
  if(s){ //-- if non-null, find matching label
    for(int i = 0; i < nlabels; ++i)
      if(!strcmp(labels[i], s))
        return true;
    return false;
  } else { //-- if s is null, return if we have *any* label
    return (nlabels != 0);
  }
}

CFGnode * PgmStmt::getCFGactiveNode()
{
  if(flag_use_bblocks) return this->getBBlock();
  else return this;
}

bool PgmStmt::hasSwitchPred() const
{
  for(int i = 0; getPred(i); ++i)
    if(getPredStmt(i)->annot.kind == Annot::aSwitch)
      return true;
  return false;
}

//----------------------------------
// END OTHER MEMBER FUNCTIONS
//----------------------------------

@


1.138
log
@Fixed bug in getSingletonLoc().
@
text
@d441 14
d1805 5
d2864 3
d2873 1
@


1.137
log
@ADDED: is_zeroed field to AO!  (But only outermost (declared)
	objects will be marked)
Changed mbu4 so that
 - function calls don't gen new mbu facts;
 - at function entry, isZeroed objects are excluded
   from initial facts (intra mode)
@
text
@d190 2
d194 1
a194 1
  AO * ao = ret;
d196 1
a196 1
    TCtype * sty = ao->getStaticType();
d199 1
a199 1
    } else if(ao->getKind() == AO::aoUDot || (sty && sty->getKind() == TCtype::tcUnion)){
d201 2
a202 2
//    } else if(ao->getKind() == AO::aoSDot){
//      ao = &((AOSDot *)ao)->getParent();
@


1.136
log
@CHANGES:
1. Moved PExprAssign::getSingletonLHSloc() to
   ExpDescr::getSingletonLoc(), so it can be used
   elsewhere to determine strong update.
1a. FIXED BUG (??) in getSingletonLoc(): previously
    for sdot object, was returning enclosing struct!?!
2. Added -vtfix flag, which enables/disables RED and
   MBU treatment of verifyTag as fixing the type on
   mismatch.
3. Added MBU handling of verifyTag vtfix.
4. Changed so that MBU uses the RED parallel hackery
   (PM_RED_UNSAFE) when vtfix is on.
@
text
@d531 1
a531 1
        if(pid) df = new PExprDecl(pid->get_AOId(), fsid, PExprDecl::dFormal, parent, false, argno);
d566 1
a566 1
        if(pid) df = new PExprDecl(pid->get_AOId(), fsid, PExprDecl::dLocal, parent, iszeroed);
d573 1
a573 1
        if(pid) df = new PExprDecl(pid->get_AOId(), fsid, PExprDecl::dStatic, parent, true);
d593 1
a593 1
        if(aid) df = new PExprDecl(aid->get_AOMalloc(isalloca), fsid, PExprDecl::dMalloc, parent, iszeroed, 0,
@


1.135
log
@ADDED evaluation of each library function call to determine
if its target (where relevant) is exposed -- this will mainly
be used in -vulnw mode to remove instrumentation when a
function's target is exposed (needed to avoid false positive).
Eventually, it may also be used in -ptr/ptrw mode to remove
instrumentation when a library function's target is not
exposed -- though currently this never happens because of
context-insensitive analysis and overly-conservative models.
SUPPLEMENTAL CHANGES to achieve the above:
 1. Created ExposedStatus class in ao.cpp/ao.h (was previously
    an enum in AO class)
 2. Changed PExprcall::isDirectCall() to return the ID of the
    direct call, rather than just a bool.
 3. Exported "flag_readwrite" to become a global -- it's about
    time (I'd been misguidedly trying to avoid this for far
    too long, creating a bigger mess instead)
@
text
@d167 40
a3185 40
}

//--------------------------------------
// This is the filter function to decide
// whether this is a strong or weak assignment.
// - Assignment is strong if LHS is a singleton
//   location that doesn't include a union or
//   array component. (e.g. a[0], a[0].i.j)
//   The latter is because of the way we map
//   a[0] to I <a> directly, but I<a> represents
//   all elements of the array.
//--------------------------------------
AO * PExprAssign::getSingletonLHSloc()
{
  AO * ret = 0;
  suco_iterator<AO *> aoi(e1desc.getAOs());
  while(aoi.Iterate()){
    AO& ao = *aoi.Current();
    if(ao.isLoc()){
      if(ret) return 0; //-- more than one locs
      ret = &ao;
    } else if(!ao.isVal()){
      return 0; //-- non-val and non-loc
    }
  }
  //- at this point, ret is a singleton
  //- now check for array or union component in access path
  AO * ao = ret;
  while(1){
    TCtype * sty = ao->getStaticType();
    if(sty && sty->getKind() == TCtype::tcArray){
      return 0;
    } else if(ao->getKind() == AO::aoUDot || (sty && sty->getKind() == TCtype::tcUnion)){
      return 0;
    } else if(ao->getKind() == AO::aoSDot){
      ao = &((AOSDot *)ao)->getParent();
    } else { //- end of the line: return
      return ret;
    }
  }
@


1.134
log
@Augmented to handle ALLOCA:
(solution is hackish at best)
- added is_alloca flag to AOMalloc object.
  HOWEVER, this is set only by flow_sensitive
  PgmExpr/MallocDecl case!
- a second channel of information comes from
  the (long-forgotten) "stclass" field of ID.
  (This is the bit used in -ptr-heapstack mode)
@
text
@d2104 1
a2104 1
bool PExprCall::isDirectCall()
d2106 11
a2116 5
  return (this->getFaos().Length() == 1)
	&& (((this->getTargetFns().Length() == 1)
	     && (&this->getTargetFns().Head()->getId() == this->getFaos().Head()))
	   ||((this->getUndefTargetFns().Length() == 1)
	     && (this->getUndefTargetFns().Head() == this->getFaos().Head())));
@


1.133
log
@BUG FIX: isDirectCall() was only checking getTargetFns(),
which failed when the direct call target is undefined!
(Also, added flag "prepared" to CFG).
@
text
@d539 1
d543 3
d553 1
a553 1
        if(aid) df = new PExprDecl(aid->get_AOMalloc(), fsid, PExprDecl::dMalloc, parent, iszeroed, 0,
d2727 1
a2727 1
          if(dd.isLocal() || dd.isFormal()){
@


1.132
log
@Added argument to prepareCFG indicating whether or not
to prepare the CFG for widening (along backedges).
Those steps are (currently) needed only for range analysis.
@
text
@d1874 5
d2102 5
a2106 3
  return ((this->getTargetFns().Length() == 1)
	  && (this->getFaos().Length() == 1)
	  && (&this->getTargetFns().Head()->getId() == this->getFaos().Head()));
@


1.131
log
@Added CFG::traverseRootNodes, used by pmbu and tca.
The thing to remember is that this function traverses
first the enter node (if any) before going through
each function's root nodes.
@
text
@d1872 1
a1872 1
void CFG::prepareCFG()
d1887 1
a1887 1
  if(flag_range_filter_loop_backedge)
d1891 1
a1891 1
  {
d1926 6
a1931 4
    //- identify remaining backedges in supergraph (due to false loops from context-insensitivity)
    TCstats::timer("finding remaining backedges");
    mainfn->getEntryNode()->findRemainingBackedges();
    TCstats::timer(0);
@


1.130
log
@Moved derefOneLevel() from ExpDescr to AO class.
@
text
@d1989 18
@


1.129
log
@Changed GMOD/GREF to _exclude_ local variables taht
are only directly accessed.  (Added flag_gmodref_skip_locals
to control this.)
THIS IS A SIGNIFICANT CHANGE, and has been minimally verified
for RAN; need to validate for RED,MBU,other analyses.
@
text
@a119 21
AO * ExpDescr::derefOneLevel(AO& ao)
{
  switch(ao.getKind()){
    case AO::aoSDot: return derefOneLevel(((AOSDot&)ao).getParent());
    case AO::aoUDot: return derefOneLevel(((AOUDot&)ao).getParent());
    case AO::aoStar: return &((AOStar&)ao).getTarget();
    case AO::aoOp:   return derefOneLevel(((AOOp&)ao).getTarget());
    case AO::aoExt:  return derefOneLevel(((AOExt&)ao).getTarget());
    default:
    // case AO::aoId:
    // case AO::aoMalloc:
    // case AO::aoReturn:
    // case AO::aoArg:
    // case AO::aoValue:
    // case AO::aoStringLit:
    // case AO::aoAddrOf:
    // case AO::aoFunction:
      return 0;
  }
}

d174 1
a174 1
      AO * deref_ao = derefOneLevel(*aoi.Current());
@


1.128
log
@Minor changes to use getter rather than directly
access member fields.
@
text
@d2677 30
a2706 4
   //- filter out values
    if(!aoi.Current()->isVal()){
      if(imod) CFGfunction::clie_imod_ecrs.Union(aoi.Current()->getECR().getAliasECRs());
      else     CFGfunction::clie_iref_ecrs.Union(aoi.Current()->getECR().getAliasECRs());
@


1.127
log
@Fixed efficiency bug: in ECR::collectAliasECRs, the
"has_locs" filter mechanism was removing non-loc ECRs
from the list too early, so the same sub-graph would've
been traversed multple times.
Now, loc-filtering is done separately, by a new function
ECR::filterLocArgRet().
@
text
@d193 1
a193 1
    suco_iterator<AO *> aoi(this->aos);
d206 1
a206 1
  if(aoset.Intersects(this->estr_aos)){
d233 1
a233 1
  suco_iterator<AO *> aoi(this->estr_aos);
@


1.126
log
@RELEVANT AOS DONE (but some parts not efficient):
 - Added Dependency and DependencyMap classes, to record
   dependencies not captured by flow-insensitive assign
   edges.
 - Revamped tca relevant-aos collecting mechanism.
Note: certain recent changes rendered certain operations
less efficient, like getAliasECRs.
@
text
@d253 1
a253 1
    aoi.Current()->getECR().collectAliasECRs(eset, true, true); //- true=follow de-starred aos' aliases
d257 1
a257 1
    eaoi.Current()->getECR().collectAliasECRs(eset, true, true); //- true=follow de-starred aos' aliases
d259 1
@


1.125
log
@MAJOR UPDATE: towards relevant aos.
THIS VERSION RELIES ON ExpDescr's aoset TO CAPTURE
ALL DEPENDENCE INFORMATION, WHICH IS NOT THE CASE.
@
text
@d41 73
d205 1
a205 1
  //- a. check aff_aos: Ids which directly occur in the expression
d248 1
d254 43
@


1.124
log
@1. Renamed ExpDescr's affaos to estr_aos, to avoid confusion
   with "affecting aos" (affecrs).
2. tca: more refinement of relevant-aos computation:
   - specially handle op/ext/star AOs -- not quite
     there yet (this is hopefully the last bit that
     needs to be fixed)
   - in RAN mode, starting points must include malloc
     sizes.
@
text
@a40 2
suco_set<AO *> ExpDescr::empty_aos; //- static placeholder: empty list

d175 1
a175 2
//- helper for TCAstate::markStartingPoints()
void ExpDescr::affLocsMarkRelevant()
d177 1
a177 2
  //- a. mark estr_aos
  suco_iterator<AO *> aoi(this->estr_aos);
d179 1
a179 14
    aoi.Current()->dfa_relevant = true;
  }  

  //- b. mark affecrs
  if(!this->affecrs)
    this->instantiateAffEcrs();

  suco_iterator<ECR *> ei(*this->affecrs);
  while(ei.Iterate()){
    suco_iterator<AO *> ai(ei.Current()->getAOset());
    while(ai.Iterate()){
      if(ai.Current()->isLocArgRet())
        ai.Current()->dfa_relevant = true;
    }
d448 1
d452 2
a453 1
        if(aid) df = new PExprDecl(aid->get_AOMalloc(), fsid, PExprDecl::dMalloc, parent, iszeroed, 0, new ExpDescr(estr_aos, estr));
a1107 2
//            suco_set<AO *>& raos = (suco_set<AO *>&) AO::stringToAOlist(true, cp, &cp, is.aidmap, is.pidmap, is.values);

d3027 2
@


1.123
log
@FIXED VARARG HANDLING:
- to be compliant with new "finalizeECR" phase change
  model, I had to change AO::get_AOArg to possibly
  return null, and create new AO::get_or_create_AOArg
  for early use to construct AOArg objects as needed.
- the above change required more careful handling
  (in ran.cpp) of function call argument passing:
  specifically, at callsite fp(i,j,n) where fp
  points to foo(i), there will be only two AOArg
  objects created for foo (F X I foo i and l where
  l is "last argno/largno"), so we will do:
  - strong assign for actuals up to largno:
    F X I foo i <=strong= actual(i)
    F X I foo l <=strong= actual(j)
  - weak assign for actuals beyond that point:
    F X I foo l <=weak= actual(n)
  Note that this nicely handles varargs, where
  the ellipsis maps to largno.
@
text
@d104 2
a105 2
    suco_iterator<AO *> li(lex->affaos);
    suco_iterator<AO *> ri(rex->affaos);
d135 1
a135 1
  if(aoset.Intersects(this->affaos)){
d161 2
a162 2
  //- a. check affaos
  suco_iterator<AO *> aoi(this->affaos);
d177 23
d368 1
a368 1
            suco_llist<AO *>& argaffaos = AO::stringToAOlist(false, cp, &cp, is.aidmap, is.pidmap, is.values);
d371 1
a371 1
            dfc.args[i] = new PExprArg(AID(fsid, argaid), argaos, argaffaos, argestr);
d380 2
a381 2
        suco_llist<AO *>& e1affaos = AO::stringToAOlist(false, cp, &cp, is.aidmap, is.pidmap, is.values);
        suco_llist<AO *>& e2affaos = AO::stringToAOlist(false, cp, &cp, is.aidmap, is.pidmap, is.values);
d385 1
a385 1
        df = new PExprAssign(AID(fsid,aidno), e1aos, e1affaos, e1str, e2aos, e2affaos, e2str, parent);
d401 1
a401 1
        suco_llist<AO *>& affaos = AO::stringToAOlist(false, cp, &cp, is.aidmap, is.pidmap, is.values);
d404 1
a404 1
        df = new PExprPredicate(AID(fsid,aidno), affaos, estr, prk, parent);
d432 1
a432 1
        suco_llist<AO *>& affaos = AO::stringToAOlist(false, cp, &cp, is.aidmap, is.pidmap, is.values);
d435 1
a435 1
        df = new PExprVerify(vtk, vpk, AID(fsid,aidno), aos, affaos, estr, parent);
d465 1
a465 1
        suco_llist<AO *>& affaos = AO::stringToAOlist(false, cp, &cp, is.aidmap, is.pidmap, is.values);
d468 1
a468 1
        if(aid) df = new PExprDecl(aid->get_AOMalloc(), fsid, PExprDecl::dMalloc, parent, iszeroed, 0, new ExpDescr(affaos, estr));
d1126 1
a1126 1
            suco_llist<AO *>& raffaos = AO::stringToAOlist(false, cp, &cp, is.aidmap, is.pidmap, is.values);
d1131 1
a1131 1
            n->annot.u.edesc = new ExpDescr(raffaos, restr, raos);
d1321 1
a1321 1
  AO::write_list_string_rep(outf, this->affaos, true);
@


1.122
log
@Changed AO/ECR relationship: added AO::getECR() function
that is to be called after pt-analysis finalization of
ECRs -- so, PRIOR to finalization, must use ECR::getECR()
(as is now done in pta.cpp), but AFTER, must only use
AO::getECR() which outputs a fatal error message if ECR
not found.
@
text
@d2657 9
a2665 2
    this->gmod.Insert(fnao.get_AOArg(i));
    this->gref.Insert(fnao.get_AOArg(i));
@


1.121
log
@Fixed LocSet to filter in using isLocArgRet rather than isLoc!
@
text
@d126 1
a126 1
        this->affecrs->Union(ECR::getECR(*deref_ao).getAliasECRs());
d150 2
a151 2
      if(!ao.isVal() && ao.hasECR())
        ecrset.Insert(&ECR::getECR(ao)); //- omit aliases!?
d165 1
a165 2
    if(!ao.isVal() && ao.hasECR() &&
	ecrset.Contains(&ECR::getECR(ao))){
d187 2
a188 2
      if(!ao.isVal() && ao.hasECR()){
        if(ao.isLoc()) this->aliasecrs->Insert(&ECR::getECR(ao)); //- slight optimization: improves precision
d190 1
a190 1
        else this->aliasecrs->Union(ECR::getECR(ao).getAliasECRs());
d224 1
a224 1
  return ao.isLocArgRet() && this->ecrset.Insert(&ECR::getECR(ao));
d229 1
a229 1
  return this->ecrset.Contains(&ECR::getECR(ao));
d278 1
a278 1
    if(this->ecrset.Contains(&ECR::getECR(*aoi.Current()))){
d289 1
a289 1
    if(ecrset.Contains(&ECR::getECR(*aoi.Current()))){
d315 1
a315 1
    ecrset.Insert(&ECR::getECR(*aoi.Current()));
d1927 1
a1927 1
      ECR::getECR(*faoi.Current()).getPointsTo().traverseAliases(addAOtoCallTarget);
d2002 1
a2002 1
  return ECR::getECR(ao).getPointsTo().getAliasECRs().Intersects(this->getGFreeHeap_ecrs());
d2555 2
a2556 2
      if(imod) CFGfunction::clie_imod_ecrs.Union(ECR::getECR(*aoi.Current()).getAliasECRs());
      else     CFGfunction::clie_iref_ecrs.Union(ECR::getECR(*aoi.Current()).getAliasECRs());
d2593 1
a2593 1
                CFGfunction::clie_ifree_heap_ecrs.Union(ECR::getECR(*aoi.Current()).getPointsTo().getAliasECRs());
@


1.120
log
@Changed LocSet::Insert() to return bool;
added numAOs for better stats.
@
text
@d205 3
d215 1
a215 1
      if(aoi.Current()->isLoc()){
d225 1
a225 1
  return ao.isLoc() && this->ecrset.Insert(&ECR::getECR(ao));
d241 1
a241 1
      if(ai.Current()->isLoc()){
@


1.119
log
@Modified format of calltrace output.
@
text
@d205 1
a205 1
void ECRlocSet::Insert(AO& ao)
d207 16
a222 1
  this->ecrset.Insert(&ECR::getECR(ao));
d1312 1
a1312 1
      fprintf(outf, "(%d)", widen_locs->Size());
d1467 1
a1467 1
          fprintf(outf, "(%d)", backedge_locs[bndx]->Size());
d1580 1
a1580 1
          fprintf(outf, "(%d)", backedge_locs[bndx]->Size());
d2678 1
a2678 1
    fprintf(stderr, "(IMOD %d ecrs)(IREF %d ecrs)\n"
d2680 2
a2681 2
		  , this->gmod.Size()
		  , this->gref.Size()
d2707 2
a2708 2
    numimods += fni.Current()->getGMOD().Size();
    numirefs += fni.Current()->getGREF().Size();
@


1.118
log
@Added -calltrace= option.
@
text
@d2843 1
a2843 1
void CFGfunction::write_descr(FILE * outf, int indent)
d2846 1
a2846 1
  fprintf(outf, "%s%d:%s(%s)", ispaces,
d2860 2
a2861 2
  this->write_descr(outf, indent);

d2865 4
a2868 2
    if(csi.Current()->getParentNode())
      callers.Insert(&csi.Current()->getParentNode()->getParentFunction());
d2871 6
a2876 4
  suco_iterator<CFGfunction *> cfi(callers);
  while(cfi.Iterate()){
    if(cfi.Current()->getCallGraphId() > this->getCallGraphId())
      cfi.Current()->bottomUpWriteCalltrace(outf, indent+2);
d2878 1
d2883 1
a2883 1
  this->write_descr(outf, indent);
d2906 1
a2906 1
        fprintf(outf, "TRACES FOR %s:\n", fni.Current()->getId().getPid().getname());
d2928 1
a2928 1
          fni.Current()->write_descr(outf, 0);
@


1.117
log
@Added -callgraph/-callgraph-dot support to output
callgraph in tree form or in dot format.
Unfortunately, both formats are likely to be too
long to be useful for all but small programs.
@
text
@d2843 1
a2843 1
void CFGfunction::topDownWriteCalltree(FILE * outf, int indent)
d2855 25
d2887 1
a2887 1
void CFG::writeCallgraph(FILE * outf, bool dot)
d2897 8
d2923 1
a2923 1
          fni.Current()->topDownWriteCalltree(outf, 0);
@


1.116
log
@Eliminated ECR::ecrsToLocAOs() -- functionality migrated
to ECRlocSet::addToAOset().
@
text
@d31 6
d1739 1
a1739 1
void CFG::prepareCFG()
a1740 6
  if(!this->mainfn){
    fprintf(stderr, "FATAL ERROR: CFG has no main function\n");
    return;
  }

  collectLocalsAndIMODREF();
d1750 8
d1759 2
d2819 80
@


1.115
log
@MAJOR UPDATE:
- Created new class LocSet to encapsulate a set of
  locations, used to store GMOD, GREF, and backedge
  filters.
  (Previously, was suco_set<AO *>, later changed to
  suco_set<ECR *>.)
- Created two versions, one storing AOs, another
  storing ECRs.  Verified that results are the
  same, though performance is not (but only when
  computing backedge filters).
@
text
@d231 10
a240 2
//--TODO: move ecr function here?
  ECR::ecrsToLocAOs(this->ecrset, aoset);
@


1.114
log
@Renamed ECR::setToNonLocAOset() to ECR::ecrsToLocAOs().
(Old name was a misnomer!)
@
text
@a12 2
suco_set<AO *> * const CFGnode::ALL_AOS = (suco_set <AO *> *)1;

d194 95
d1278 3
a1280 3
/**/if(this->isDirectCall()) fprintf(outf, " (direct)");
/**/if(this->isRecursiveCall()) fprintf(outf, " (recursive)");
  if(widen_aos){
d1282 2
a1283 2
    if(widen_aos != CFGnode::ALL_AOS){
      fprintf(outf, "(%d)", widen_aos->Length());
d1435 1
a1435 1
      if(backedge_aos[bndx]){
d1437 2
a1438 2
        if(backedge_aos[bndx] != CFGnode::ALL_AOS){
          fprintf(outf, "(%d)", backedge_aos[bndx]->Length());
d1548 1
a1548 1
      if(backedge_aos[bndx]){
d1550 2
a1551 2
        if(backedge_aos[bndx] != CFGnode::ALL_AOS)
          fprintf(outf, "(%d)", backedge_aos[bndx]->Length());
d1606 1
a1606 2
    AO::write_list_string_rep(outf, gmod, true);
    fprintf(outf, "\n");
d1609 1
a1609 2
    AO::write_list_string_rep(outf, gref, true);
    fprintf(outf, "\n");
d1612 3
a1614 1
    AO::write_list_string_rep(outf, gfreeheap, true);
d1752 1
a1752 1
  //- compute widen_aos for (recursive) call nodes
d1754 1
a1754 1
    TCstats::timer("finding recursive widen-aos");
d1960 8
a1967 9
//- returns true if
//  - ao is in this->gref, or
//  - ao points to something in this->gfreeheap
bool CFGfunction::GrefOrFreeHeapAffects(AO& ao)
{
//-possible future change: use condensed GREF (no individual struct members),
// then here must iterate GREF and do getEnclosingStruct() comparison
  return (this->getGREF().Contains(&ao)
	  || ECR::getECR(ao).getPointsTo().getAliasECRs().Intersects(this->getGFreeHeapEcrs()));
d2213 1
a2213 1
          cnode.backedge_aos[0] = CFGnode::ALL_AOS;
d2215 1
a2215 1
          cnode.backedge_aos[1] = CFGnode::ALL_AOS;
d2218 2
a2219 2
          if(cnode.getSucc(i)->traverse_id == -1){ //- if *ANY* successor is back-edge,	then mark backedge_aos[0]=true
            cnode.backedge_aos[0] = CFGnode::ALL_AOS;
d2267 1
a2267 1
	CFGfunction::collectIMODREF(tfi.Current()->getGMOD(), true);	// writes directly into CFGfunction::clie_imod_ecrs
d2278 1
a2278 1
bool CFG::collectModSetUntil(PgmStmt * exitnode, suco_iterator<PgmStmt *>& si, suco_set<ECR *>& modecrs)
a2280 1
  CFGfunction::clie_imod_ecrs.Attach(modecrs);
d2289 2
a2290 1
  modecrs.Attach(CFGfunction::clie_imod_ecrs);
d2313 1
a2313 1
	    suco_set<ECR *> modecrs;
d2316 1
a2316 3
	    if(collectModSetUntil(cnode->getSucc(1)->getStmtList().Head(), tsi, modecrs)){
	      suco_set<AO *> modaos;
	      ECR::ecrsToLocAOs(modecrs, modaos);
d2319 1
a2319 1
		cnode->getPred(i)->updateBackEdgeIfSet(*cnode, modaos);
d2336 1
a2336 1
		suco_set<ECR *> modecrs;
d2339 1
a2339 3
		if(collectModSetUntil(pnode->getSucc(1)->getStmtList().Head(), tsi, modecrs)){
		  suco_set<AO *> modaos;
		  ECR::ecrsToLocAOs(modecrs, modaos);
d2342 1
a2342 1
		    pnode->getPred(i)->updateBackEdgeIfSet(*pnode, modaos);
d2359 1
a2359 1
	    suco_set<ECR *> modecrs;
d2362 1
a2362 3
	    if(collectModSetUntil(tailstmt, tsi, modecrs)){
	      suco_set<AO *> modaos;
	      ECR::ecrsToLocAOs(modecrs, modaos);
d2364 1
a2364 1
	      prednode.updateBackEdgeIfSet(*cnode, modaos);
d2407 1
a2407 1
/**/      if(flag_verbose && !debug_written && !exnode->backedge_aos[0]){
d2412 2
a2413 2
            if(!exnode->backedge_aos[0]){
              exnode->backedge_aos[0] = new suco_set<AO *>;
d2415 2
a2416 2
            if(exnode->backedge_aos[0] != ALL_AOS){
              exnode->backedge_aos[0]->Union(entryfn->getGREF());	//- gref, because modification may not be within entryfn
d2419 1
a2419 1
            exnode->backedge_aos[0] = ALL_AOS;
a2600 4
  int numimod_ecrs = CFGfunction::clie_imod_ecrs.Length();
  int numiref_ecrs = CFGfunction::clie_iref_ecrs.Length();
  int numifree_heap_ecrs = CFGfunction::clie_ifree_heap_ecrs.Length();

d2602 2
a2603 2
  ECR::ecrsToLocAOs(CFGfunction::clie_iref_ecrs, this->gref);
  ECR::ecrsToLocAOs(CFGfunction::clie_imod_ecrs, this->gmod);
d2606 5
a2610 2
  this->gref.Union(CFGfunction::clie_callsite_retaos);
  this->gmod.UnionConsume(CFGfunction::clie_callsite_retaos);
d2614 2
a2615 2
  this->gmod.Insert(&fnao.get_AOReturn());
  this->gref.Insert(&fnao.get_AOReturn());
d2622 2
a2623 2
    this->gmod.Insert(&fnao.get_AOArg(i));
    this->gref.Insert(&fnao.get_AOArg(i));
d2626 4
a2629 2
  //-for free-heap, just collect heap AOs
  suco_iterator<ECR *> ei(CFGfunction::clie_ifree_heap_ecrs);
d2631 1
d2635 2
a2636 1
        this->gfreeheap.Insert(ai.Current());
d2639 3
d2645 6
a2650 6
    fprintf(stderr, "(IMOD %d ecrs -> %d aos)(IREF %d ecrs -> %d aos)\n"
		    "(IFREE:heap %d ecrs -> %d aos, stack %d aos)\n"
		  , numimod_ecrs, this->gmod.Length()
		  , numiref_ecrs, this->gref.Length()
		  , numifree_heap_ecrs, this->gfreeheap.Length()
				 , this->gfreestack.Length());
d2674 3
a2676 3
    numimods += fni.Current()->getGMOD().Length();
    numirefs += fni.Current()->getGREF().Length();
    numifreeheap += fni.Current()->getGFreeHeap().Length();
a2685 14
//- Warning: this function caches its result, so it should
//  only be called after the CFG has stabilized -- which is
//  to say, after computation of GMODREF/FreeHeap/FreeStack...
suco_set<ECR *>& CFGfunction::getGFreeHeapEcrs()
{
  if(!this->gfreeheap_ecrs){
    this->gfreeheap_ecrs = new suco_set<ECR *>;
    suco_iterator<AO *> aoi(this->gfreeheap);
    while(aoi.Iterate())
      this->gfreeheap_ecrs->Insert(&ECR::getECR(*aoi.Current()));
  }
  return *this->gfreeheap_ecrs;
}

d2743 1
a2743 1
      fn.gfreeheap.Union(cgi.Current()->gfreeheap);
d2754 1
a2754 1
        fn.gfreeheap.Union(rfi.Current()->gfreeheap);
d2761 1
a2761 1
          fn.gfreeheap.Union(rci.Current()->gfreeheap);
d2769 1
a2769 1
        ofnset.Head()->gfreeheap.Union(fn.gfreeheap);
d2907 1
a2907 1
suco_set<AO *> * CFGnode::getBackEdge() const
d2909 2
a2910 2
  if(backedge_aos[0] && backedge_aos[1] &&
	backedge_aos[0] != backedge_aos[1]){ //- assertion
d2914 1
a2914 1
  return backedge_aos[0]?backedge_aos[0]:backedge_aos[1];
d2917 1
a2917 1
suco_set<AO *> * CFGnode::getBackEdge(bool tf) const
d2919 1
a2919 1
  return backedge_aos[tf?0:1];
d2922 1
a2922 1
void CFGnode::updateBackEdgeIfSet(CFGnode& tgtnode, suco_set<AO *>& aoset)
d2926 5
a2930 5
  if(backedge_aos[index] == ALL_AOS){
    backedge_aos[index] = new suco_set<AO *>;
    backedge_aos[index]->Copy(aoset);
  } else if(backedge_aos[index]){
    backedge_aos[index]->Union(aoset);
d2934 2
a2935 2
//- If pe is a recursive call, must set both widen_aos
//  and retnode->backedge_aos (to ALL_AOS or GMOD,
d2939 2
a2940 2
//    - caller-to-callee_entry (captured by widen_aos)
//    - callee_return-to-caller (captured by retnode->backedge_aos)
d2957 3
a2959 3
            if(pec.widen_aos != CFGnode::ALL_AOS){	//- paranoid check
              if(!pec.widen_aos){
                pec.widen_aos = new suco_set<AO *>;
d2961 1
a2961 1
              pec.widen_aos->Union(tfi.Current()->getGMOD());
d2969 3
a2971 3
              if(cnode && cnode->backedge_aos[0] != CFGnode::ALL_AOS){
                if(!cnode->backedge_aos[0]){
                  cnode->backedge_aos[0] = new suco_set<AO *>;
d2973 1
a2973 1
                cnode->backedge_aos[0]->Union(tfi.Current()->getGMOD());
d2975 1
a2975 1
/**/            fprintf(stderr, "ERROR(computeWidenAOs): null cnode or ALL_AOS backedge_aos encountered!\n");
d2980 1
a2980 1
            pec.widen_aos = CFGnode::ALL_AOS;
d2984 1
a2984 1
              if(cnode) cnode->backedge_aos[0] = CFGnode::ALL_AOS;
@


1.113
log
@1. Removed STRONGER_CPP compile-time flag.
   This was surrounding two things affected by g++
   version change:
   A. inline initialization of static member CFGnode::ALL_AOS.
      ~~> no big deal.
   B. ability to define friend function suco_write_recycle_stats
      as friend of (templated) suco class.
      ~~> solution: wrap suco_write_recycle_stats in its
          own class (suco_diag_wrapper).
2. Added purify target to makefile.
@
text
@d2226 1
a2226 1
	      ECR::setToNonLocAOset(modecrs, modaos);
d2251 1
a2251 1
		  ECR::setToNonLocAOset(modecrs, modaos);
d2276 1
a2276 1
	      ECR::setToNonLocAOset(modecrs, modaos);
d2520 2
a2521 2
  ECR::setToNonLocAOset(CFGfunction::clie_iref_ecrs, this->gref);
  ECR::setToNonLocAOset(CFGfunction::clie_imod_ecrs, this->gmod);
@


1.112
log
@Changed filter-backedge default behavior:
1. split flag_range_filter_backedge into two flags:
   flag_range_filter_[loop|call]_backedge.
   The former controls intra-procedural ("loop")
   backedges, while the latter controls callgraph
   backedges (from recursion and and "findRemainingBackedges").
2. default behavior now is: loop=yes but call=no.
@
text
@a12 1
#ifdef STRONGER_CPP
a13 1
#endif // ifdef STRONGER_CPP
@


1.111
log
@Small correction to comment.
@
text
@d10 1
a10 1
#include "flags.h" // for flag_verbose, flag_use_bblocks, flag_range_filter_backedge
d1657 2
a1658 2
  //- compute backedge filters
  if(flag_range_filter_backedge)
d2327 1
a2327 1
          if(flag_range_filter_backedge){
d2860 1
a2860 1
//  depending on flag_range_filter_backedge)
d2880 1
a2880 1
          if(flag_range_filter_backedge){
@


1.110
log
@RAN: combined formerly-two functions filterInto and
filterGrefMayFree into one function filterGrefMayFreeInto.
Code sharing, but more confusing?  May not have been a
good idea...
@
text
@d2859 1
a2859 1
//  and retnode->backedge_aos (to ALL_AOS or GREF+arg/rets,
@


1.109
log
@Major overhaul, to handle function call filtering.
See dfa.cpp for documentation.
 - filterRetnodeFact() eliminated; replaced by
 - interProcHandleRetvalAssign -- responsible for
   assigning from R X I <fn> to R D I <fp>.
 - interProcPrepareReturnCollector() -- special
    pre-processor for indirect calls to set "intersection"
   AOs to "top".
 - meetFiltered() -- does meet, but constrained by a
   window (defined by a function's GREF/MayFree set).
Supporting changes:
 - eliminated removeArgIntervalsExceptFor(); rendered obsolete
   by
 - filterGrefMayFree() -- called at function entry
 - RANfact::isTop()
 - collectAOset, createTopMappings, in support of
   interProcPrepareReturnCollector()
 - PExprCall::isDirectCall() and isRecursiveCall()
 - CFGfunction::GrefOrFreeHeapAffects()
@
text
@d1666 1
a1666 1
      if(fni.Current()->recursion_id){
d1874 2
a1878 12
#if 0
bool PExprCall::GrefOrFreeHeapAffects(AO& ao)
{
  suco_iterator<CFGfunction *> tfi(this->getTargetFns());
  while(tfi.Iterate()){
    if(tfi.Current()->GrefOrFreeHeapAffects(&ao)){
      return true;
    }
  }
  return false;
}
#endif
a2872 2

      bool first_time = true;
@


1.108
log
@Added findRemainingBackedges() function to search for
any backedges that remain after the
 1. intra-procedural depth-first search, and
 2. recursion widen-aos search.
The remaining backedges should all be "false" backedges
that arise due to context-insensitivity.
@
text
@d1187 2
d1845 44
@


1.107
log
@Fixed computeWidenAOs() to handle the other half of
recursive loops (previously only fixed half).
(Note: entails moving the function from PExprCall to CFGnode)
@
text
@d1334 3
a1336 2
  fprintf(outf, "%s--{ Stmt %d/%d (aid=<%d,%d>)",
		ispaces, parent.getCallGraphId(), traverse_id, aid.filestem_id, aid.aid);
d1661 1
d1671 1
d1691 2
a1692 1
  if(mainfn->getEntryNode())
d1694 7
a1700 2
  else
    fprintf(stderr, "Main function has no entry node!\n");
d1929 2
a1930 1
  return !this->traverseRootNodes(PgmExpr::notFunctionCall);
d1935 1
a1935 1
  stmtlist(), hascall(false)
d2170 1
a2170 1
  if(flag_verbose) TCstats::timer("computing backedge filters");
d2251 130
a2380 1
  if(flag_verbose) TCstats::timer(0);
@


1.106
log
@MAJOR FIX: previously, was not widening on
recursive-call edges (only on backedges),
so analysis may not terminate.

FIX: PExprCall: added widen_aos filter set;
added PExprCall::computeWidenAOs() to compute
this, called from CFG::prepareCFG().

Also changed: Argument nodes (F X I <fn>) are
now included in both GMOD and GREF (previously,
only GREF) -- this is a shortcut to simplify
computeWidenAOs() above... not sure if this is
the cleanest solution.

(Also changed: hoisted CFG::remapRecursionId()
into its own function, for readability; formerly
was just inlined in CFG::prepareCFG()).
@
text
@d1665 1
a1665 1
          cni.Current()->traverseRootNodes(PExprCall::computeWidenAOs);
a1834 32
//- If this is a recursive call,
//  set widen_aos to ALL_AOS or GREF+arg/rets,
//  depending on flag_range_filter_backedge
bool PExprCall::computeWidenAOs(PgmExpr& pe)
{
  if(pe.getKind() == fCall){
    PExprCall& pec = (PExprCall&)pe;
    int pec_recurs_id = (pec.getParentNode())
			? (pec.getParentNode()->getParentFunction().getRecursionId())
			: 0;
    if(pec_recurs_id){
      suco_iterator<CFGfunction *> tfi(pec.getTargetFns());
      while(tfi.Iterate()){
        if(tfi.Current()->getRecursionId() == pec_recurs_id){

          //-- call is recursive: DO STUFF HERE
          if(flag_range_filter_backedge){
            if(!pec.widen_aos){
              pec.widen_aos = new suco_set<AO *>;
            }
            pec.widen_aos->Union(tfi.Current()->getGMOD());
          } else { //- don't filter: just mark and break out (no need to check individual targets further)
            pec.widen_aos = CFGnode::ALL_AOS;
            break;
          }
        }
      }
    }
  }
  return true; //- true ensures full traversal
}

d2681 62
@


1.105
log
@Major Update: RAN handling of function argument passing,
now uses F X I <fn> (Arg(Func(Id(<fn>)))) as go-between:
assigned prior to callsite, retrieved by formal.
Also changed CFG gmod/gref collection to include
F X I <fn> in each function's gref set.
@
text
@d1186 9
a1194 2
  fprintf(outf, "%s--{ Expr %s (aid=<%d,%d>, nargs=%d)\n",
		ispaces, getKindString(), aid.filestem_id, aid.aid, nargs);
d1580 51
d1646 1
a1646 49
  {
    suco_llist<CFGfunction *> highest_id_recurse_list;

    //- 1. find for each recursion_id the node with the highest callgraph_id
    suco_iterator<CFGfunction *> fni(this->fnlist);
    while(fni.Iterate()){
      CFGfunction& cfn = *fni.Current();
      if(cfn.recursion_id){
        bool found = false;
        suco_iterator<CFGfunction *> hirli(highest_id_recurse_list);
        while(hirli.Iterate()){
          if(hirli.Current()->getRecursionId() == cfn.getRecursionId()){
            found = true;
            if(hirli.Current()->getCallGraphId() < cfn.getCallGraphId()){
              hirli.DeleteCurrent();
              highest_id_recurse_list.Insert(&cfn);
            }
            break;
          }
        }
        if(!found) highest_id_recurse_list.Insert(&cfn);
      }
    }
    if(!highest_id_recurse_list.IsEmpty()){
      //- 2. Renumber each recursion_id with the highest callgraph_id
      //- 2a. first skip the "representative nodes"
      fni.Rewind();
      while(fni.Iterate()){
        CFGfunction& cfn = *fni.Current();
        if(cfn.recursion_id){
          suco_iterator<CFGfunction *> hirli(highest_id_recurse_list);
          while(hirli.Iterate()){
            if(&cfn != hirli.Current() &&
		cfn.recursion_id == hirli.Current()->recursion_id){
              cfn.recursion_id = hirli.Current()->getCallGraphId();
              break;
            }
          }
        }
      }
      //- 2b. final pass: renumber the "representative nodes"
      {
        suco_iterator<CFGfunction *> hirli(highest_id_recurse_list);
        while(hirli.Iterate()){
          hirli.Current()->recursion_id = hirli.Current()->getCallGraphId();
        }
      }
    }
  }
d1658 13
d1835 32
d2391 6
a2396 2
  //- special: add argument nodes "F X I <thisfn>" to gref (TODO: what about gmod?)
  for(int i = 1; i <= fnao.getLargNo(); ++i)
d2398 1
@


1.104
log
@Semi-bug fix: remember that function return node is
represented by R F I <fn> not R I <fn>, which was
not the case, so I've fixed it throughout (occurs
mainly in handleReturnStmt() in the various analyses).

Also, added AOReturn::getStaticType() as a separate
function to look up the underlying function's return
type if staticType is not set;
added TCfunctionType::getReturnType() accessor to
assist.
@
text
@d2331 8
a2338 3
  //- special: add return node "R F I <thisfn>" to gmod/gref
  this->gmod.Insert(&this->getId().get_AOFunction().get_AOReturn());
  this->gref.Insert(&this->getId().get_AOFunction().get_AOReturn());
@


1.103
log
@Added stronger union check.
@
text
@d2331 3
a2333 3
  //- special: add return node "R I <thisfn>" to gmod/gref
  this->gmod.Insert(&this->getId().get_AOReturn());
  this->gref.Insert(&this->getId().get_AOReturn());
@


1.102
log
@For getSingletonLHSloc(): also, if it contains a
union (UDot) component, it is a weak assignment!
@
text
@d2566 1
a2566 1
    if(sty->getKind() == TCtype::tcArray){
d2568 1
a2568 1
    } else if(ao->getKind() == AO::aoUDot){
@


1.101
log
@Changed filtering function to decide strong/weak assignments
(getSingletonLHSloc()): now also recognizes array objects
and array objects withing access strings:
         Previously  Now
   a[0]    weak     weak
 a[0].i   strong    weak
@
text
@d2542 3
a2544 3
//   location that doesn't include an array
//   component. (e.g. a[0], a[0].i.j)
//   This is because of the way we map
d2562 1
a2562 1
  //- now check for array component in access path
d2566 1
a2566 1
    if(sty->getKind() == TCtype::tcArray)
d2568 3
a2570 1
    if(ao->getKind() == AO::aoSDot){
a2571 2
    } else if(ao->getKind() == AO::aoUDot){
      ao = &((AOUDot *)ao)->getParent();
@


1.100
log
@Added iszeroed flag to PExprDecl, which is passed from
sml front end to indicate that a declared variable is
zero-initialized -- i.e., statics, and autos with an
initializer.  (So maybe "iszeroed" is a bit of a misnomer;
"is_initialized" would probably be better.)
Also, calloc's are iszeroed, while malloc's are not.
And currently, formals are not marked as iszeroed.
@
text
@d2538 10
d2561 15
a2575 1
  return ret;
@


1.99
log
@Added filter for RAN stat collection to filter out
derefs in libraries.
Entailed adding PgmExpr::isLib() helper.
@
text
@d266 1
a266 1
        if(pid) df = new PExprDecl(pid->get_AOId(), fsid, PExprDecl::dFormal, parent, argno);
d294 5
d301 1
a301 1
        if(pid) df = new PExprDecl(pid->get_AOId(), fsid, PExprDecl::dLocal, parent);
d308 1
a308 1
        if(pid) df = new PExprDecl(pid->get_AOId(), fsid, PExprDecl::dStatic, parent);
d313 5
d323 1
a323 1
        if(aid) df = new PExprDecl(aid->get_AOMalloc(), fsid, PExprDecl::dMalloc, parent, 0, new ExpDescr(affaos, estr));
d1269 2
@


1.98
log
@Added code to read in, for Malloc declaration, the
ExpDescr for the size.
Streamlined ExpDescr constructor a little, and cleaned
up some leftover garbage.
@
text
@d2521 5
@


1.97
log
@Changed AO::write_string_rep and write_list_string_rep
to take a "readable" flag.
So now, flag_readable_output only affects the parts intended
for machine-reading by sml; the other auxiliary output
(e.g. via debug_dump, or for longjmp targets) will be
always readable.
@
text
@d39 1
a39 1
suco_llist<AO *> ExpDescr::empty_affaos; //- static placeholder: empty list
d310 4
a313 1
        if(aid) df = new PExprDecl(aid->get_AOMalloc(), fsid, PExprDecl::dMalloc, parent);
d976 1
a976 1
            n->annot.u.edesc = new ExpDescr(raos, raffaos, restr);
d1258 7
a1264 1
  fprintf(outf, ") }--\n");
a2535 2

suco_set<AO *> PExprPredicate::empty_aos;
@


1.96
log
@Another fix for callsite-filter, to prevent "reconstitute
clash" error caused by Return nodes (R I <fn>, R D I <fp>):
three changes:
 1. For each fn, add R I <fn> to gref (and gmod)
 2. For each callsite to fp, add R D I <fp> to gref (and gmod)
    Note: this entailed non-trivial changes to collectIMODREF
    mechanism, which is really ugly to begin with.
 3. In RAN::filterCallsiteFacts, for callsite to fp, still need
    to separately include R D I <fp>.
@
text
@d1160 1
a1160 1
  AO::write_list_string_rep(outf, this->aos);
d1163 1
a1163 1
  AO::write_list_string_rep(outf, this->affaos);
d1176 1
a1176 1
  AO::write_list_string_rep(outf, faos);
d1183 1
a1183 1
    tfi.Current()->getId().write_string_rep(outf);
d1191 1
a1191 1
    utfi.Current()->write_string_rep(outf);
d1254 1
a1254 1
  ao.write_string_rep(outf);
d1474 1
a1474 1
  idao.write_string_rep(outf);
d1480 1
a1480 1
    AO::write_list_string_rep(outf, (suco_set<AO *>&)localvars);
d1484 1
a1484 1
    AO::write_list_string_rep(outf, gmod);
d1488 1
a1488 1
    AO::write_list_string_rep(outf, gref);
d1492 1
a1492 1
    AO::write_list_string_rep(outf, gfreeheap);
d1496 1
a1496 1
    AO::write_list_string_rep(outf, gfreestack);
@


1.95
log
@Suppressed "addPredecessor: infrequent case encountered"
warning.
@
text
@d2209 1
d2237 1
d2239 7
d2292 1
d2306 8
d2333 1
@


1.94
log
@REMOVED:
 - eltype/numelts components of aoMalloc -- new implementation
        now uses setStaticType mechanism to convey this information,
        which is a  better solution that this previous unclean
        approach
   - note that as a result, Interval::setTgt() is now greatly
        simplified, since all objects (from array aoIds to
        aoMallocs to aoStringLits can now be treated uniformly
        by just getting info from the staticType).
FIXED:
 - in CFG::read, I previously had a filter to make sure the
        globnodes (initializer nodes) are either mStaticDecl
        or mAssign; but with change to initializer behavior
        that PARALLEL-izes aggregate initializations, this
        constraint no longer makes sense; in fact I just
        removed the filter altogether, so that globnodes can
        now contain _any_ kind of PgmExpr.
@
text
@d2628 1
a2628 1
      fprintf(stderr, "CFGnode::addPredecessor: infrequent case encountered! (npreds=%d)\n", n.npreds);
@


1.93
log
@CHANGE 1: wrote ECR::getAliasECRs(), which collects and
  caches an ecrset of alias ECRs.
  This function replaces the functionality of
  collectAliasECRs(), but should only be called after
  the points-to graph is finalized.
CHANGE 2: changed RAN and REDp to account for MayFree
  set (CFGfunction::getGFreeHeap()).
  For RAN, this affected: filterCallsiteFact,
  intraProcHandleCall, and handleFreeCall (previously
  empty).
  For RED, this affected only REDp::intraProcHandleCall.
  For CFGfunction: added gfreeheap_ecrs/getGFreeHeapEcrs()
  to cache the freeheap ecrset for use in the above
  phases.
@
text
@a308 6
        int nelts = strtoul(cp, &cp, 10);
	TCtype * elty = TCtype::stringToTy(cp, &cp);
        if(elty && elty->getKind() == TCtype::tcVoid){
          elty = 0;
          nelts = 0;
        }
d310 1
a310 1
        if(aid) df = new PExprDecl(aid->get_AOMalloc(elty, nelts), fsid, PExprDecl::dMalloc, parent);
d1127 1
a1127 2

    } else if(buf[2] == mStaticDecl || buf[2] == mAssign) {
a1130 2
    } else {
      fprintf(stderr, "CFG::read error on line %s", buf);
@


1.92
log
@Added computation of GFreeHeap and GFreeStack.
Next: use this in analyses (in particular, redundant analysis).
@
text
@d124 1
a124 1
        ECR::getECR(*deref_ao).collectAliasECRs(*this->affecrs);
d189 1
a189 1
        else ECR::getECR(ao).collectAliasECRs(*this->aliasecrs);
d2085 5
d2225 2
a2226 2
      ECR::getECR(*aoi.Current()).collectAliasECRs(imod ? (CFGfunction::clie_imod_ecrs)
							: (CFGfunction::clie_iref_ecrs));
d2255 1
a2255 1
                ECR::getECR(*aoi.Current()).getPointsTo().collectAliasECRs(CFGfunction::clie_ifree_heap_ecrs);
d2338 2
d2347 2
d2353 16
a2368 1
  fprintf(stderr, "(locals %d, imod %d, iref %d)\n", numlocals, numimods, numirefs);
@


1.91
log
@Added "STRONGER_CPP" flag to shift some definitions
so they compile on solaris.
@
text
@d1500 8
d2209 2
d2232 1
a2232 1
          if(dd.isLocal())
d2234 2
a2235 1
          //-- else should be malloc
d2241 1
a2241 1
        for(int i = 1; dc.getArg(i); ++i)
d2243 12
d2258 2
a2259 2
        CFGfunction::collectIMODREF(da.getLHS().getAOs(), true);  // } separate imod from iref for now
        CFGfunction::collectIMODREF(da.getLHS().getAOs(), false); // } TODO: may want to consider imod part of iref?
d2278 2
d2283 2
d2294 1
d2300 11
d2312 2
a2313 1
    fprintf(stderr, "(IMOD %d ecrs -> %d aos -> %d aos, IREF %d ecrs -> %d aos -> %d aos)\n"
d2315 3
a2317 1
		  , numiref_ecrs, this->gref.Length());
d2321 3
d2404 2
d2415 2
d2422 2
d2430 2
@


1.90
log
@Update to handling of global initializers (for inter-procedural analysis):
BEFORE: the (global) entry node was an empty dummy, and the
 global decl/init expressions were stored separately (in
 CFG::globnodes) and hackishly accounted for prior to the
 "proper" run of the analysis with the worklist mechanism.
 For RAN, this resulted in a "warnNotLE" warning at each
 entry node, where the initial "top" fact was being meet-ed
 into the global-init-computed fact.
NOW: built "proper" entry node, and stick globnodes into it.
 Take out the hackish initialization code, so now "regular"
 worklist handling will correctly and cleanly compute the
 appropriate facts.
NOTES: removed deprecated "getGlobalNodes()" and one
 CFGbblock constructor.
@
text
@d13 4
@


1.89
log
@1. Changed AOMalloc representation to include <eltype, numelts>
   (previously had single <size> field)
2. Changed Interval to store <eltype, numelts> rather than AO
   as "target" field: potentially allows for "smarter" range
   analysis per Susan's suggestion.
(Added runtime flag -ran-[no-]malloc to turn on/off handling
 of malloc objects, now on by default)
TODO: account for elty in Interval::plus/minus (added signature,
      but not yet implemented)
@
text
@a1526 5
  fprintf(outf, "  --{ Global decls:\n");
  suco_iterator<PgmExpr *> gfi(globnodes);
  while(gfi.Iterate())
    gfi.Current()->debug_dump(outf, 2);
  fprintf(outf, "  --} end Global decls\n");
d1552 1
a1552 1
    fprintf(stderr, "Fatal error: CFG has no main function\n");
d1626 14
a1639 4
  if(flag_use_bblocks)
    this->entry = new CFGbblock(*mainfn);
  else
    this->entry = new PgmStmt(*mainfn);
@


1.88
log
@Another change: RETURN argument is now an ExpDescr
instead of an aoset (as was before); with a corresponding
change to the argument of handleReturnStmt.

Independently: updated RAN's handleFormal (wrote but
not tested).
@
text
@d305 6
a310 1
        int size = strtoul(cp, &cp, 10);
d312 1
a312 1
        if(aid) df = new PExprDecl(aid->get_AOMalloc(size), fsid, PExprDecl::dMalloc, parent);
@


1.87
log
@DONE implementing backedge filter stuff:
 - introduced new helper ECR::setToNonLocAOset
   (also used by earlier code for IMOD/IREF collection)
 - "borrowed" use of CFGfunction stuff that's used for
   IMOD/IREF collection.
 - Appears to work.
@
text
@d219 4
a222 1
            dfc.args[i] = new PExprArg(AID(fsid, argaid), argaos);
d961 3
d965 3
d970 1
a970 1
            n->annot.u.aoset = &raos;
d1154 1
d1158 1
d1161 1
a1161 1
  fprintf(outf, "\n");
d1164 3
a1166 2
  fprintf(outf, "\n");
  fprintf(outf, "%sestr: %s\n", ispaces, this->estr?this->estr:"@@");
d1198 2
a1199 2
      fprintf(outf, " (aid=<%d,%d>): ", args[i]->getAid().filestem_id, args[i]->getAid().aid);
      AO::write_list_string_rep(outf, args[i]->getAOs());
a1200 1
    fprintf(outf, "\n");
d1345 1
a1345 1
      if(annot.u.aoset){
d1347 1
a1347 1
        AO::write_list_string_rep(outf, *annot.u.aoset);
d2217 1
a2217 1
          CFGfunction::collectIMODREF(dc.getArg(i)->getAOs(), false);
@


1.86
log
@BUG FIX: CFGnode::getBackEdge() needs to return true if
*either* of backedge_aos is non-null.
Old buggy version defaulted to returning only backedge_aos[0].
@
text
@a303 1
/**/if(size) fprintf(stderr, "\nMALLOC-SIZE(%s) = %d\n", aid?aid->getname():"AID-ERROR", size);
d1300 8
a1307 2
      fprintf(outf, " %d%s", getSuccStmt(i)->traverse_id,
			     (i < 2 && backedge_aos[i])?"bk":"");
d1412 9
a1420 3
    for(int i = 0; getSucc(i); ++i)
      fprintf(outf, " %d%s", ((CFGbblock*)getSucc(i))->traverse_id,
			     (i < 2 && backedge_aos[i])?"bk":"");
d2052 16
d2071 3
a2073 1
  while(si.Iterate()){
d2075 1
a2075 1
    if(stmt.nlabels || (stmt.annot.kind == PgmStmt::Annot::aGoto))
d2077 3
a2079 4

    //- collect mod set into modecrs
//TODO

d2081 1
d2091 1
a2091 1
    //- traverse stmtlist linearly searching for structured loops
d2093 1
a2093 2
    suco_llist<PgmStmt *>& stmtlist = fni.Current()->getStmtList();
    suco_iterator<PgmStmt *> si(stmtlist);
d2096 2
a2097 2
      CFGnode * cnode = (flag_use_bblocks) ? ((CFGnode *)stmt.getBBlock())
					   :((CFGnode *)&stmt);
a2098 2
      } //- else: stmt has no bblock, must be unreachable

d2100 3
a2102 4
        if(stmt.annot.kind == PgmStmt::Annot::aWhile){
	  //- [(p)while]--T->[loop head].../-->[loop exit]
	  //            --F---------------/
fprintf(stderr, "-while-\n");
d2108 6
a2113 3
//TODO
            }
/**/ else fprintf(stderr, "-HAS-GOTO-OR-LABEL-\n");
d2115 28
a2142 35
        }
#if 0
        //- find loop-head signatures: 2. For
        if(stmt->annot.kind == PgmStmt::Annot::aFor){
	  //- [for]--->[(p)]--T->[loop head]... (--->[(p)])
	  //                --F->[loop exit]
	  if(this->getNsuccs() == 1){
            CFGnode * pnode = this->getSucc(0);
	    if(pnode && pnode->getNsuccs() == 2 && pnode->getSucc(0) && pnode->getSucc(1)){
fprintf(stderr, "-for-\n");
              suco_set<ECR *> modecrs;
              pnode->collectModSet(modecrs);
              if(pnode->getSucc(0)->collectModSetUntil(*pnode, *pnode->getSucc(1), modecrs)){
//TODO
              }
/**/ else fprintf(stderr, "-HAS-GOTO-OR-LABEL-\n");
	    } else fprintf(stderr, "ERROR(CFG::computeBackedgeFilters): malformed for loop predicate has %d successors\n",
				 pnode?pnode->getNsuccs():-1);
	  } else fprintf(stderr, "ERROR(CFG::computeBackedgeFilters): malformed for loop has %d successors\n", this->getNsuccs());
        } break;
      }
        //- find loop-head signatures: 3. DoWhile
        switch(stmt->annot.kind)
          case PgmStmt::Annot::aDoWhile:{
	  //- [loop head]<--(bk)T--[(p)dowhile]
	  if(this->getNsuccs() == 2 && this->getSucc(0) && this->getSucc(1)){
fprintf(stderr, "-do-while-\n");
            suco_set<ECR *> modecrs;
            if(this->getSucc(0)->collectModSetUntil(*this, *this->getSucc(1), modecrs)){
              this->collectModSet(modecrs);
//TODO
            }
/**/ else fprintf(stderr, "-HAS-GOTO-OR-LABEL-\n");
	  } else fprintf(stderr, "ERROR(CFG::computeBackedgeFilters): malformed do-while loop has %d successors\n", this->getNsuccs());
        } break;
d2144 22
a2165 1
#endif
d2243 3
a2245 24
  //- collect AOs from ECR sets
  suco_iterator<ECR *> eri(CFGfunction::clie_iref_ecrs);
  while(eri.Iterate()){
    this->gref.Union(eri.Current()->getAOset());
  }
  suco_iterator<ECR *> emi(CFGfunction::clie_imod_ecrs);
  while(emi.Iterate()){
    this->gmod.Union(emi.Current()->getAOset());
  }

  int numimod = this->gmod.Length();
  int numiref = this->gref.Length();

  //- filter out non-location AOs
  suco_iterator<AO *> rai(this->gref);
  while(rai.Iterate()){
    if(!rai.Current()->isLoc())
      rai.DeleteCurrent();
  }
  suco_iterator<AO *> mai(this->gmod);
  while(mai.Iterate()){
    if(!mai.Current()->isLoc())
      mai.DeleteCurrent();
  }
d2249 2
a2250 2
		  , numimod_ecrs, numimod, this->gmod.Length()
		  , numiref_ecrs, numiref, this->gref.Length());
d2478 12
d2628 6
@


1.85
log
@1. SUCO UPDATE: added copy constructor to suco_iterator,
   that sets the "list" pointer to the current pointer
   (this feature will be used in collecting backedge
   filter).
2. compute backedge filters: reshuffled interface, and
   wrote some preliminary untested code!
   The old version tried to recursively walk the cfg;
   the new one just walks the sequential list of nodes.
   Also added command line flag (-ran-[no-]filter-backedge).
TODO: fix high level bug that only handles true-false
edges differently when the predicate node gives a pair
of facts.
@
text
@d2449 1
a2449 1
  return backedge_aos[0];
@


1.84
log
@trivial adjustment to debug output format.
@
text
@d10 1
a10 1
#include "flags.h" // for flag_verbose
d470 1
a470 1
      cfgn->nodelist.Append(PgmExpr::read(is, buf, cfgn));
d1374 1
a1374 1
    suco_iterator<PgmExpr *> fli(nodelist);
d1418 2
a1419 2
  fprintf(outf, " #stmts = %d", nodelist.Length());
  if(brief || nodelist.IsEmpty()){
d1424 1
a1424 1
    suco_iterator<PgmStmt *> psi(nodelist);
d1596 5
a1600 1
  assignIds(); //- note: also marks backedges, and computes backedge filters
d1655 1
a1655 1
  suco_iterator<PgmExpr *> nli(this->nodelist);
d1664 1
a1664 1
  suco_iterator<PgmStmt *> nli(this->nodelist);
d1846 1
a1846 1
  nodelist(), hascall(false)
d1848 1
a1848 1
  this->nodelist.Append(&headnode);
d1861 1
a1861 1
      this->nodelist.Append(cnode);
d1903 1
a1903 1
      int nnodes = bb.nodelist.Length();
d1910 1
a1910 1
      PgmStmt& hnode = *bb.nodelist.Head();
d1932 1
a1932 1
      PgmStmt& tnode = *bb.nodelist.Last();
a2016 25
void CFG::computeBackedgeFilters(CFGnode& cnode, PgmStmt * stmt)
{
  if(stmt){
    //- find well-structured loop heads: compute the loop's modset
    switch(stmt->annot.kind){
      case PgmStmt::Annot::aWhile:{
	//- [(p)while]--T->[loop head] ... (--->[(p)])
	//            --F->[loop exit]
      } break;
      case PgmStmt::Annot::aDoWhile:{
	//- [(p)dowhile]--T(bk)->[loop head] ... (--->[(p)])
	//              --F->[loop exit]
      } break;
      case PgmStmt::Annot::aFor:{
	//- [for]--->[(p)]--T->[loop head]... (--->[(p)])
	//                --F->[loop exit]
      } break;
    }

    //- traverse, but skip backedges
//    if(stmt->nlabels) return false; //- has labels, give up!
//   if(stmt->annot.kind == PgmStmt::Annot::aGoto) return false;
  }
}

d2018 1
d2028 1
a2028 1
    if(fni.Current()->entrystmt){
d2030 1
a2030 4
      computeBackedgeFilters(*fni.Current()->entrystmt,
			     fni.Current()->entrystmt);
    }
    if(fni.Current()->entryblock){
d2032 92
a2123 2
      computeBackedgeFilters(*fni.Current()->entryblock,
			     fni.Current()->entryblock->getTailStmt());
a2125 1

d2576 1
a2576 1
  PgmStmt * tail = nodelist.Last();
@


1.83
log
@Augmented malloc declaration to include size component, which is a result
of trying to compute a constant size from the expression.
NOTE: there's some trouble with determining the value of sizeof, so for now
**sizeof expressions are evaluated to the value -1** as an indicator for
diagnostic purposes.  IOW, the malloc-size value currently generated SHOULD
NOT BE USED DIRECTLY (should be safe anyways, as long as we're conscious
that a negative size means something is amiss).

The size is currently stored in AOMalloc objects, but not yet used.
@
text
@a302 1
/**/if(size) fprintf(stderr, "MALLOC-SIZE=%d\n", size);
d304 1
@


1.82
log
@Infrastructure update: CFGnode backedge indicator has
been upgraded from a boolean to an AO set pointer, for
which a value of:
  0 indicates non-backedge
  1 (constant CFGnode::ALL_AOS) indicates a backedge
    with no AO-filter information (i.e. widen all intervals)
  otherwise, contains the set of AOs that may be modified
    in the loop body, and constitutes a safe superset of
    AOs whose interval needs to be widened.
So far, added the necessary interface and skeletal function
bodies; NOT YET DONE: write the engine to compute the may-mod
sets.
@
text
@d302 2
d305 1
a305 1
        if(aid) df = new PExprDecl(aid->get_AOMalloc(), fsid, PExprDecl::dMalloc, parent);
@


1.81
log
@Small change to debug output for collecting IMOD/REF:
 1. no need -v flag to output timings for this phase
 2. with -v flag, also outputs number of ECRs/AOs
    collected for each function.
@
text
@d1300 1
a1300 1
			     (i < 2 && is_backedge[i])?"bk":"");
d1407 1
a1407 1
			     (i < 2 && is_backedge[i])?"bk":"");
d1594 1
a1594 1
  assignIds(); //- note: also marks backedges
d1991 4
a1994 2
        if(cnode.getSucc(0) && cnode.getSucc(0)->traverse_id == -1) cnode.is_backedge[0] = true;
        if(cnode.getSucc(1) && cnode.getSucc(1)->traverse_id == -1) cnode.is_backedge[1] = true;
d1997 2
a1998 2
          if(cnode.getSucc(i)->traverse_id == -1){ //- if *ANY* successor is back-edge,
            cnode.is_backedge[0] = true;	   //  then mark is_backedge[0]=true
d2011 25
d2046 1
a2046 1
    if(fni.Current()->entrystmt)
d2048 4
a2051 1
    if(fni.Current()->entryblock)
d2053 3
d2373 15
@


1.80
log
@Added accessors getPred/getSucc/getNpreds/getNsuccs
to CFGnode class.
Previously-defined getPred/getSucc in PgmStmt have been
renamed to getPredStmt/getSuccStmt.
This allows un-friending fo a few classes.
@
text
@d2097 3
d2110 3
d2125 5
d2136 1
a2136 1
  if(flag_verbose) TCstats::timer("collecting function local variables and IMOD/IREF");
d2139 2
d2146 2
d2151 2
a2152 4
  if(flag_verbose){
    TCstats::timer(0);
    fprintf(stderr, "(%d locals)\n", numlocals);
  }
@


1.79
log
@Modified debug_dump to also output RANfacts.
@
text
@d1296 1
a1296 1
  if(succs){
d1298 2
a1299 2
    for(int i = 0; getSucc(i); ++i){
      fprintf(outf, " %d%s", getSucc(i)->traverse_id,
d1304 1
a1304 1
  if(preds){
d1307 1
a1307 1
      fprintf(outf, " %d", getPred(i)->traverse_id);
d1403 1
a1403 1
  if(succs){
d1405 2
a1406 2
    for(int i = 0; i < nsuccs && succs[i]; ++i)
      fprintf(outf, " %d%s", ((CFGbblock*)succs[i])->traverse_id,
d1410 1
a1410 1
  if(preds){
d1412 2
a1413 2
    for(int i = 0; i < npreds && preds[i]; ++i)
      fprintf(outf, " %d", ((CFGbblock*)preds[i])->traverse_id);
d1850 2
a1851 2
	  && cnode->getSucc(0)->countPreds() == 1  //- successor has only one predecessor
	  && !cnode->getSucc(0)->hasFunctionCalls()) //- successor has no function calls
d1854 1
a1854 1
      cnode = cnode->getSucc(0);
d1860 3
a1862 3
  for(int i = 0; cnode->getSucc(i); ++i)
    if(cnode->getSucc(i) && !cnode->getSucc(i)->bblock)
      pendingnodes.Insert(cnode->getSucc(i));
d1917 1
a1917 1
        if((bb.preds[i] = hnode.getPred(j)->bblock) != 0)
d1934 2
a1935 2
      for(int j = 0; tnode.getSucc(j); ++j){
        if((bb.succs[i] = tnode.getSucc(j)->bblock) != 0)
d1980 3
a1982 3
    for(int i = 0; i < cnode.nsuccs && cnode.succs[i]; ++i)
      if(!cnode.succs[i]->traverse_id)
        assignId(*cnode.succs[i]);
d1990 3
a1992 3
      if(cnode.nsuccs == 2){ //- two-way branches
        if(cnode.succs[0] && cnode.succs[0]->traverse_id == -1) cnode.is_backedge[0] = true;
        if(cnode.succs[1] && cnode.succs[1]->traverse_id == -1) cnode.is_backedge[1] = true;
d1994 3
a1996 3
        for(int i = 0; i < cnode.nsuccs && cnode.succs[i]; ++i)
          if(cnode.succs[i]->traverse_id == -1){ //- if *ANY* successor is back-edge,
            cnode.is_backedge[0] = true;		 //  then mark is_backedge[0]=true
d2002 2
a2003 2
    for(int i = 0; i < cnode.nsuccs && cnode.succs[i]; ++i)
      assignId(*cnode.succs[i]);
a2455 12
PgmStmt * PgmStmt::getSucc(int i) const
{
  if(i < nsuccs) return (PgmStmt *) succs[i];
  else return 0;
}

PgmStmt * PgmStmt::getPred(int i) const
{
  if(i < npreds) return (PgmStmt *) preds[i];
  else return 0;
}

d2471 1
a2471 1
    if(getPred(i)->annot.kind == Annot::aSwitch)
@


1.78
log
@1. Added code (to CFG::assignId) to mark backedges in
   the CFG.
   May be buggy -- must test.
2. -MAJOR UPDATE-
   Added ran.cpp/ran.h for range checking.
   Thusfar, ran.cpp contains only empty skeletons to be
   filled in - do not run!
3. Renamed widen_narrow in CFG to is_backedge;
   also, now widen/narrow are specific to RAN/RANfact,
   rather than generic to DFA/DFAfact.
@
text
@d1203 3
d1386 7
d1435 7
@


1.77
log
@Added Predicate Node, which is generated at these locations
(and labeled with the respective types):
 - &&, || (prAnd, prOr)
 - ?: (prQC)
 - for,while,do-while,if-then,if-then-else  (prStmt)
 - switch (prSwitch)
@
text
@d1295 4
a1298 2
    for(int i = 0; getSucc(i); ++i)
      fprintf(outf, " %d", getSucc(i)->traverse_id);
d1396 2
a1397 1
      fprintf(outf, " %d", ((CFGbblock*)succs[i])->traverse_id);
d1577 1
a1577 1
  assignIds();
d1952 2
d1971 14
d1992 1
@


1.76
log
@Changed rhs argument of Assign node from an aolist to an exp-descr
triplet: <aolist, aff-aolist, estr>.
Added ExpDescr::stringToEstr static function for converting
input.
Changed ExpDescr constructor to be able to take just one
aoset argument -- used by MBU analysis which just needs
a "placeholder" ExpDescr for an aoset.  Includes static
empty_affaos list which is used for all such placeholder
objects created.
@
text
@d73 1
a73 1
      char * estr = (char *) malloc(slen+1);
d80 1
a80 1
        fprintf(stderr, "ExpDescr::stringToEstr: MALLOC ERROR\n");
d235 19
d384 1
a384 1
     || strtoul(buf+6, 0, 10) != 2)
d387 15
d403 1
a403 1
  fgets(buf, TCA_BUF_SIZE, is.inf);
d1221 10
d1274 3
d1616 1
d2034 3
d2214 14
d2244 3
a2246 1
const char * PgmExpr::getKindString() const
d2248 6
a2253 7
  switch(kind){
    case fCall:     return "Call";
    case fAssign:   return "Assign";
    case fDecl:     return "Decl";
    case fVerify:   return "Verify";
    case fParallel: return "Parallel";
    case fBranch:   return "Branch";
d2255 1
a2255 1
  return "<Kind:ERROR>";
@


1.75
log
@Gave the code the -Wall treatment: adjusted things to
get rid of warnings:
 - reordered initializers to match declaration order
 - made some destructors virtual (note that for many
   classes with no explicit destructors, I did not
   add explicit virtual destructors, so -Wall warnings
   remain)
 - made some signed/unsigned casts
 - made some pointer/unsigned int casts for printfs
 - filled in unaccounted-for cases in switch statements
@
text
@d35 2
d64 29
d229 1
d231 3
a233 12
        char * estr = "@@";
        if(*cp == '{'){
          char * dp = cp + strlen(cp) - 1;
          while(dp >= cp && *dp != '}') dp--;
          if(*dp == '}'){
            *dp = 0;
            cp++;
            estr = (char *) malloc(strlen(cp)+1);
            strcpy(estr, cp);
          } else fprintf(stderr, "Missing end-delimiter for assign expr-string: %s", cp);
        } else if(*cp != '@@') fprintf(stderr, "Invalid expr-string for assign node: %s", cp);
        df = new PExprAssign(AID(fsid,aidno), e1aos, e2aos, e1affaos, estr, parent);
d263 1
a263 11
        char * estr = "@@";
        if(*cp == '{'){
          char * dp = cp + strlen(cp) - 1;
          while(dp >= cp && *dp != '}') dp--;
          if(*dp == '}'){
            *dp = 0;
            cp++;
            estr = (char *) malloc(strlen(cp)+1);
            strcpy(estr, cp);
          } else fprintf(stderr, "Missing end-delimiter for verify expr-string: %s", cp);
        } else if(*cp != '@@') fprintf(stderr, "Invalid expr-string for verify node: %s", cp);
d1182 2
a1183 3
  fprintf(outf, "%s    e2 AOs: ", ispaces);
  AO::write_list_string_rep(outf, e2aos);
  fprintf(outf, "\n");
d1984 1
a1984 1
        CFGfunction::collectIMODREF(da.getRHS(), false); //-- note: redundant with vtRhs collection below
@


1.74
log
@Small wording change in diagnostic output message.
@
text
@d80 1
a80 1
bool ExpDescr::instantiateAffEcrs()
d400 1
a400 1
           && cfgn->aid.aid == strtoul(cp, &cp, 10)){ // asserts, and advances cp!
d1092 1
a1092 1
  if(indent > sizeof(space_buffer) - 1) indent = sizeof(space_buffer) - 1;
d1977 5
@


1.73
log
@Added extra timer around each function for collectLocalsAndIMODREF
@
text
@d272 1
a272 1
        else fprintf(stderr, "Invalid Pid (%d) read for CFG malloc-decl node\n", aidno);
@


1.72
log
@Changed TCstats::timer to remember a stack of (up to 10)
timers, which allows more simultaneous timings.
@
text
@d2025 1
d2028 1
@


1.71
log
@Fixed REDt -- previous version was naive and didn't account
for aliases.
Removed REDfact::remove, which is no longer needed.
Added ExpDescr::aliasecrs cache (with accessor getAliasECRs()).
Added to suco GetSingleton function.
@
text
@d11 1
d1456 1
a1456 1
  if(flag_verbose) fprintf(stderr, "Traversing callgraph...\n");
d1458 1
a1458 1
  if(flag_verbose) fprintf(stderr, "... done traversing callgraph.\n");
d1460 1
a1460 1
  if(flag_verbose) fprintf(stderr, "Remapping recursion id...\n");
d1510 1
a1510 1
  if(flag_verbose) fprintf(stderr, "... done remapping recursion id.\n");
d1633 1
a1633 1
  if(flag_verbose) fprintf(stderr, "Connecting supergraph (call/return assignments)...\n");
d1645 1
a1645 1
  if(flag_verbose) fprintf(stderr, "... done connecting supergraph\n");
d1870 5
a1874 2
  if(flag_verbose) fprintf(stderr, "Constructing basic blocks%s...\n",
				(flag_verbose > 2)?" (BLOCKS/NODES/MAX/AVG)":"");
d1880 1
a1880 1
  if(flag_verbose) fprintf(stderr, "... done constructing basic blocks\n");
d1915 1
a1915 1
  if(flag_verbose) fprintf(stderr, "Assigning CFG ids (post-order depth-first)...\n");
d1928 1
a1928 1
  if(flag_verbose) fprintf(stderr, "... done assigning CFG ids\n");
d2020 1
a2020 1
  if(flag_verbose) fprintf(stderr, "Collecting function local variables and IMOD/IREF...\n");
d2029 4
a2032 1
  if(flag_verbose) fprintf(stderr, "... done collecting function local variables and IMOD/IREF (%d locals)\n", numlocals);
d2052 1
a2052 1
  if(flag_verbose) fprintf(stderr, "Collecting GMOD/GREF...\n");
d2117 1
a2117 1
  if(flag_verbose) fprintf(stderr, "... done collecting GMOD/GREF\n");
@


1.70
log
@Rewrote collectLocalsAndIMODREF mechanism to use
ECR::collectAliasECRs, which should be faster
(avoids multiple re-traversal of the same alias
graph).
Verified consistency with old version on go and ijpeg.
@
text
@d34 6
d94 1
a94 1
bool ExpDescr::intersectsAffLocs(suco_set<AO *>& aoset)
d121 1
a121 1
bool ExpDescr::intersectsAffLocs(suco_set<ECR *>& ecrset)
d138 21
@


1.69
log
@Changed input function to make sure estr is never null
("@@" on error).
@
text
@d1905 2
a1906 18
suco_set<AO *> * CFGfunction::clie_iref = 0;
suco_set<AO *> * CFGfunction::clie_imod = 0;

bool CFGfunction::addToIREF(AO& ao)
{
  //-- already validated clie_iref != 0
  if(ao.isLoc()) //- restrict to location???
    CFGfunction::clie_iref->Insert(&ao);
  return true;
}

bool CFGfunction::addToIMOD(AO& ao)
{
  //-- already validated clie_imod != 0
  if(ao.isLoc()) //- restrict to location???
    CFGfunction::clie_imod->Insert(&ao);
  return true;
}
d1910 6
a1915 7
  if(CFGfunction::clie_iref && CFGfunction::clie_imod){ //- assertion
    suco_iterator<AO *> aoi(aoset);
    while(aoi.Iterate()){
      //- filter out values
      if(!aoi.Current()->isVal())
        ECR::getECR(*aoi.Current()).traverseAliases(imod?(CFGfunction::addToIMOD)
							:(CFGfunction::addToIREF));
d1917 1
a1917 1
  } else fprintf(stderr, "CFGfunction::collectIMODREF error -- clie_iref or clie_imod not set\n");
d1954 2
a1955 2
  CFGfunction::clie_iref = &this->gref;
  CFGfunction::clie_imod = &this->gmod;
d1960 25
@


1.68
log
@Added handleFreeCall to dfa framework (PExprCall now has
extra set of undeclared functions to which it might point,
and a helper callsFree() to determine if it may call free()).
For mbu/rda/rdmb, handleFreeCall is a noop; for RED: wrote
handleFreeCall to remove expressions affected by *p (p is
arg 1 of free call).
@
text
@d171 1
a171 1
        char * estr = 0;
d212 1
a212 1
        char * estr = 0;
@


1.67
log
@For Redundant analysis, wrote function call case --
entailed re-adjusting intersectAffLocs to take an aoset
rather than just a single ao.
Should be complete, except for free().
(Free might work anyways -- because model GMOD captures
all malloc'ed locs?)
@
text
@d1099 8
d1580 1
a1580 1
            break;
d1583 2
d1618 22
@


1.66
log
@Added ExpDescr::compare function, which will be used
by REDfact's edescset -- to eliminate duplication.
@
text
@d88 1
a88 1
bool ExpDescr::intersectsAffLocs(AO& ao)
d91 1
a91 1
  if(this->affaos.Contains(&ao)){
d99 3
a101 2
  suco_set<ECR *> ecrset;
  ecrset.Insert(&ECR::getECR(ao)); //- omit aliases!?
d103 10
a112 1
  return this->affecrs->Intersects(ecrset);
@


1.65
log
@Updated redundant analysis: strong and weak assignments written;
to do: function calls and result collection.
Entailed following changes:
  PExprAssign::getLHS to return ExpDescr instead of AO set.
  DFA handleWeakAssign's second argument is now ExpDescr rather than AO set.
  ECR: added helper collectAliasECRs (not tested!)
@
text
@d55 18
@


1.64
log
@Wrote some code -- incomplete, compiles but probably won't
do the right thing yet.
Entailed enriching ExpDescr class with intersectsAffLocs
function and helpers (some, not all written yet).
@
text
@d64 1
a64 1
        this->affecrs->Insert(&ECR::getECR(*deref_ao));
d70 1
a70 1
bool ExpDescr::intersectsAffLocs(suco_set<AO *>& aoset)
d72 2
a73 5
  if(!this->affecrs)
    this->instantiateAffEcrs();

  //- a. check aff_aos, which are Ids which directly occur in the expression
  if(aoset.Intersects(this->affaos)){
d78 2
a79 3
  if(!this->affecrs->IsEmpty()){
    //- i. collect ecrset
    suco_set<ECR *> ecrset;
d81 2
a82 11
    suco_iterator<AO *> aoi(aoset);
    while(aoi.Iterate()){
      AO& ao = *aoi.Current();
      if(!ao.isVal() && ao.hasECR()){
        ecrset.Insert(&ECR::getECR(ao));
      }
    }
    
    //- ii. call ecrset version of intersetcsAffLocs
    this->intersectsAffLocs(ecrset);
  }
d84 1
a84 1
  return false;
d89 11
d103 1
a103 3
//TODO

  return false;
d1896 2
a1897 2
        CFGfunction::collectIMODREF(da.getLHS(), true);  // } separate imod from iref for now
        CFGfunction::collectIMODREF(da.getLHS(), false); // } TODO: may want to consider imod part of iref?
@


1.63
log
@Added REDfactPair class, which will be the "main" fact
processed by RED analysis -- that class contains two
REDfact sets, one for redundant verifyPtrs, another
for verifyTags.  Only the former will be used by -ptr/ptrw
mode, for example.
Skeletons are still hollow
@
text
@d31 80
@


1.62
log
@Changed affloc from a set to a list -- this is because
of the change in estr representation, with IDs represented
by a placeholder "V" (no more "V(#)"), and the affloc list
storing the aoIds in "V" left-to-right order!
Note -- made some hack-ish adjustments to some ao functions
to avoid repetition by multiplexing between set and list
mode -- kinda ugly, though!
@
text
@d1013 3
d1179 3
d1220 3
@


1.61
log
@Added class ExpDescr to encapsulate AOs, AffAOs, and estr.
Currently, PExprAssign and PExprVerify contain this.
Plan is for REDundant analysis to store set of these as
facts.
@
text
@d49 1
a49 1
          suco_set<AO *>& faos = AO::stringToAOset(cp, &cp, is.aidmap, is.pidmap, is.values);
d55 1
a55 1
            suco_set<AO *>& argaos = AO::stringToAOset(cp, &cp, is.aidmap, is.pidmap, is.values);
d63 3
a65 3
        suco_set<AO *>& e1aos = AO::stringToAOset(cp, &cp, is.aidmap, is.pidmap, is.values);
        suco_set<AO *>& e2aos = AO::stringToAOset(cp, &cp, is.aidmap, is.pidmap, is.values);
        suco_set<AO *>& e1affaos = AO::stringToAOset(cp, &cp, is.aidmap, is.pidmap, is.values);
d105 2
a106 2
        suco_set<AO *>& aos = AO::stringToAOset(cp, &cp, is.aidmap, is.pidmap, is.values);
        suco_set<AO *>& affaos = AO::stringToAOset(cp, &cp, is.aidmap, is.pidmap, is.values);
d778 1
a778 1
            suco_set<AO *>& raos = AO::stringToAOset(cp, &cp, is.aidmap, is.pidmap, is.values);
d969 1
a969 1
  AO::write_set_string_rep(outf, this->aos);
d972 1
a972 1
  AO::write_set_string_rep(outf, this->affaos);
d984 1
a984 1
  AO::write_set_string_rep(outf, faos);
d999 1
a999 1
      AO::write_set_string_rep(outf, args[i]->getAOs());
d1027 1
a1027 1
  AO::write_set_string_rep(outf, e2aos);
d1122 1
a1122 1
        AO::write_set_string_rep(outf, *annot.u.aoset);
d1228 1
a1228 1
    AO::write_set_string_rep(outf, (suco_set<AO *>&)localvars);
d1232 1
a1232 1
    AO::write_set_string_rep(outf, gmod);
d1236 1
a1236 1
    AO::write_set_string_rep(outf, gref);
@


1.60
log
@Updated input function to conform to latest tsls format change:
Assign and Verify nodes now include affaos and estr (expression
string) arguments.
@
text
@d965 12
d1024 2
a1025 3
  fprintf(outf, "%s    e1 AOs: ", ispaces);
  AO::write_set_string_rep(outf, e1aos);
  fprintf(outf, "\n");
a1028 4
  fprintf(outf, "%s    e1 affAOs: ", ispaces);
  AO::write_set_string_rep(outf, e1affaos);
  fprintf(outf, "\n");
  fprintf(outf, "%s    e1str: %s\n", ispaces, e1str?e1str:"@@");
d1051 1
a1051 7
  fprintf(outf, "%s    AOs: ", ispaces);
  AO::write_set_string_rep(outf, aos);
  fprintf(outf, "\n");
  fprintf(outf, "%s    affAOs: ", ispaces);
  AO::write_set_string_rep(outf, affaos);
  fprintf(outf, "\n");
  fprintf(outf, "%s    estr: %s\n", ispaces, estr?estr:"@@");
d1960 1
a1960 1
  suco_iterator<AO *> aoi(e1aos);
@


1.59
log
@Major restructuring:
 1. added DFAfactHandler class to encapsulate functions
    that process a DFAfact based on the CFG node.
    Created a handler for each fact class thusfar
    (MBU, RDA, cMBU->RDMB)
 2. renamed cMBU to RDMB, to represent the pair (RDA,MBU).
    The collection analysis class is now called RDMBc.
    Use this new convention for naming?: end in "c" for
    a "collecting" analysis class (and "a" for "analysis"?)
@
text
@d65 14
a78 1
        df = new PExprAssign(AID(fsid,aidno), e1aos, e2aos, parent);
d106 1
d119 1
a119 1
        df = new PExprVerify(vtk, vpk, AID(fsid,aidno), aos, estr, parent);
d1018 4
a1043 1
  fprintf(outf, "%s    estr: %s\n", ispaces, estr?estr:"@@");
d1047 4
@


1.58
log
@Expanded verify-kind to have two 3-valued flags:
verifyTag_kind (vtKind) = Tag, Rhs, None
verifyPtr_kind (vpKind) = Ptr, PtrW, None

Also, cmbu.cpp has some RHS collection stuff commented out:
don't think it's necessary now, with verify-ptr/verify-rhs
handling.
@
text
@d1923 1
a1923 1
//- used by cMBU
@


1.57
log
@Changed debug_dump to output things more verbosely.
@
text
@d75 16
a90 3
      case mVT:
      case mVP: {
        char * cp = &buf[4];
d103 3
a105 4
          } else fprintf(stderr, "Missing end-delimiter for verifyTag expr-string: %s", cp);
        } else if(*cp != '@@') fprintf(stderr, "Invalid expr-string for verifyTag node: %s", cp);
        df = new PExprVerify((buf[2] == mVT)?(PgmExpr::fVT):(PgmExpr::fVP),
			     AID(fsid,aidno), aos, estr, parent);
d1023 3
a1025 2
  fprintf(outf, "%s--{ Expr %s (aid=<%d,%d>)\n",
		ispaces, getKindString(), aid.filestem_id, aid.aid);
d1387 1
a1387 2
    case fVT:
    case fVP:
d1791 1
a1791 1
        CFGfunction::collectIMODREF(da.getRHS(), false);
d1793 1
a1793 2
    case PgmExpr::fVP:
    case PgmExpr::fVT: {
d1951 1
a1951 1
const char * PgmExpr::getKindString()
d1957 1
a1957 2
    case fVT:       return "VT";
    case fVP:       return "VP";
d1961 1
a1961 1
  return "<ERROR>";
d1964 1
a1964 1
const char * PExprDecl::getDkindString()
d1972 21
a1992 1
  return "<ERROR>";
@


1.56
log
@Fixed some new[] size off-by-one errors.
@
text
@d1122 1
a1122 1
  if(brief || nodelist.IsEmpty()){
d1136 1
a1136 1
    rda_fact.debug_dump(outf);
d1139 1
a1139 1
    mbu_fact.debug_dump(outf);
d1175 1
a1175 1
    rda_fact.debug_dump(outf);
d1178 1
a1178 1
    mbu_fact.debug_dump(outf);
@


1.55
log
@Wrote final piece to GMOD-filter mechanism: cMBU verifyTag
now collects facts from the cached GMOD-filtered flags of
call-parents.
@
text
@d247 1
a247 1
          cfgn->labels[i] = new char[s];
d725 1
a725 1
	    char * nc = new char[s];
d1987 1
a1987 1
      succs = new CFGnode * [nsuccs+1];
d2014 1
a2014 1
      n.preds = new CFGnode * [n.npreds+1];
@


1.54
log
@1. changed GMOD/GREF filtering mechanism -- now controlled
   by a BBA function, rather than a DFAfact function --
   this allows BBA-specific choice of filter, and also
   allows RDA to cache local facts
2. per above, added RDAlocal cache to PExprCall
3. added a parent PgmStmt pointer to PgmExpr (previously
   only defined for PExprCall, as a reference) -- this
   will allow cMBU to lookup the containing function of
   any PgmExpr (and will likely be useful later as well).
   Note that this is a pointer, and may be null for
   PgmExprs at global scope.
   Also, current assumption is that all PExprCalls have
   a non-null parent (asserted during input in one of
   the read() functions).
@
text
@d1912 12
@


1.53
log
@Added GMOD/IMOD computation.
Modified DFA to have different call-filtering modes:
by GMOD, GREF, or NONE.
Renamed DFAfact::filter to filterOut (which performs
the opposite of what filter used to).
Currently, RDA is GMOD-filtered, MBU and cMBU are
GREF-filtered.
@
text
@d51 1
a51 1
          PExprCall& dfc = *new PExprCall(AID(fsid,aidno), faos, nargs, *parent);
d65 1
a65 1
        df = new PExprAssign(AID(fsid,aidno), e1aos, e2aos);
d72 1
a72 1
        if(pid) df = new PExprDecl(pid->get_AOId(), fsid, PExprDecl::dFormal, argno);
d92 2
a93 1
        df = new PExprVerify((buf[2] == mVT)?(PgmExpr::fVT):(PgmExpr::fVP), AID(fsid,aidno), aos, estr);
d99 1
a99 1
        if(pid) df = new PExprDecl(pid->get_AOId(), fsid, PExprDecl::dLocal);
d106 1
a106 1
        if(pid) df = new PExprDecl(pid->get_AOId(), fsid, PExprDecl::dStatic);
d113 1
a113 1
        if(aid) df = new PExprDecl(aid->get_AOMalloc(), fsid, PExprDecl::dMalloc);
d154 1
a154 1
  PExprParallel * df = new PExprParallel;
d188 1
a188 1
  PExprBranch * df = new PExprBranch;
d967 6
d974 1
a974 4
    mbu_fact.debug_dump(outf);

    fprintf(outf, "%s    RDAfact: ", ispaces);
    rda_fact.debug_dump(outf);
d1135 3
a1140 3
    fprintf(outf, "%s -- RDAfact: ", ispaces);
    rda_fact.debug_dump(outf);

d1174 3
a1179 3
    fprintf(outf, "%s -- RDAfact: ", ispaces);
    rda_fact.debug_dump(outf);

d1422 2
a1423 1
            CFG::act_caller_node->getParentNode().getParentFunction().callgraph.Insert(fli.Current());
@


1.52
log
@Cleaned up a few things:
 - eliminated dmode (mode_iterating/mode_collecting);
 - added checkParallelProgress;
 - migrated absorbAndCompare from DFAfact to DFA;
 - rewrote fParallel case incorporating these changes;
 - added a cMBUfact as a member of each CFG node, call,
   and parallel, so cMBU can also define lookupNodeFact.
@
text
@d1192 4
d1265 1
a1265 1
  collectLocalsAndIREF();
d1324 1
a1324 1
  collectGREF();
d1722 1
d1732 9
a1740 1
void CFGfunction::collectIREF(suco_set<AO *>& aoset)
d1742 1
a1742 1
  if(CFGfunction::clie_iref){ //- assertion
d1747 2
a1748 1
        ECR::getECR(*aoi.Current()).traverseAliases(CFGfunction::addToIREF);
d1750 1
a1750 1
  } else fprintf(stderr, "CFGfunction::collectIREF error -- clie_iref not set\n");
d1753 1
a1753 1
bool CFGfunction::collectLocalsAndIREFexpr(PgmExpr& df)
d1766 1
a1766 1
        CFGfunction::collectIREF(dc.getFaos());
d1768 1
a1768 1
          CFGfunction::collectIREF(dc.getArg(i)->getAOs());
d1772 3
a1774 2
        CFGfunction::collectIREF(da.getLHS());
        CFGfunction::collectIREF(da.getRHS());
d1779 1
a1779 1
        CFGfunction::collectIREF(dv.getAOs());
d1785 1
a1785 1
void CFGfunction::collectLocalsAndIREF()
d1789 1
d1792 1
a1792 1
    cni.Current()->traverseRootNodes(CFGfunction::collectLocalsAndIREFexpr);
d1796 1
a1796 1
void CFG::collectLocalsAndIREF()
d1798 1
a1798 1
  if(flag_verbose) fprintf(stderr, "Collecting function local variables and IREF...\n");
d1803 1
a1803 1
    fni.Current()->collectLocalsAndIREF();
d1807 1
a1807 1
  if(flag_verbose) fprintf(stderr, "... done collecting function local variables and IREF (%d)\n", numlocals);
d1825 1
a1825 1
void CFG::collectGREF()
d1827 1
a1827 1
  if(flag_verbose) fprintf(stderr, "Collecting GREF...\n");
d1862 1
a1862 1
    //- union irefs from children
d1865 1
d1871 1
a1871 1
      //- union irefs for all nodes with same recursion_id
d1874 1
d1879 1
d1885 1
d1892 1
a1892 1
  if(flag_verbose) fprintf(stderr, "... done collecting GREF\n");
@


1.51
log
@Major update:
Added -rda (reaching-defs analysis) in new class RDA:DFA.
Basically, copied the meat from MBU, making minimal changes.
Compiles, runs, verified against small examples.
NEED TO REVIEW CODE IN DETAIL, and verify against larger
examples.
Potential problem: seems rather slow, may want to compute
GMOD?
@
text
@d1186 1
a1186 1
			callgraph_id, recursion_id);
d1280 1
a1280 1
          if(hirli.Current()->recursion_id == cfn.recursion_id){
d1282 1
a1282 1
            if(hirli.Current()->callgraph_id < cfn.callgraph_id){
d1303 1
a1303 1
              cfn.recursion_id = hirli.Current()->callgraph_id;
d1313 1
a1313 1
          hirli.Current()->recursion_id = hirli.Current()->callgraph_id;
d1796 4
a1799 4
  int rid1 = fn1->recursion_id;
  int rid2 = fn2->recursion_id;
  int cid1 = fn1->callgraph_id;
  int cid2 = fn2->callgraph_id;
d1831 1
a1831 1
					fn.callgraph_id, fn.recursion_id);
d1836 1
a1836 1
					cgi.Current()->callgraph_id, cgi.Current()->recursion_id);
d1853 1
a1853 1
    if(fn.recursion_id){
d1856 1
a1856 1
      while(rfi.Iterate() && rfi.Current()->recursion_id == fn.recursion_id){
d1865 1
a1865 1
      while(ofnset.Head() && ofnset.Head()->recursion_id == fn.recursion_id){
@


1.50
log
@Removed experimental CFG numbering schemes (in-order DFS, post-order DFS,
successor-wait), sticking with post-order DFS as the only reasonable scheme.
Also, updated certain flag defaults: -leaf and -gref are now on by default.
@
text
@d968 3
d1134 3
d1172 3
@


1.49
log
@SIGNIFICANT UPDATE:
 - added -gref flag, to enable GREF filtering
 - added code to first compute IREF for each function,
   then collect them into GREFs
 - this makes use of recursion_id/callgraph_id traversal
   order (verify that this correctly computes GREF with
   complex callgaphs?)
 - the recursion_id/callgraph_id ordering is encoded by
   the function CFGfunction::compareByCallgraphId, which
   has been absorbed into the worklist ordering function,
   so a slight behavior change there as well.
@
text
@d1314 1
a1314 12
  switch(flag_cfg_traverse_mode){
    case CT_MODE_SUCC_WAIT:
      CFGtraversal::successorWait_assignIds(*this);
      break;
    case CT_MODE_IN_DFS:
      CFGtraversal::InOrderDFS_assignIds(*this);
      break;
    case CT_MODE_POST_DFS:
    default:
      CFGtraversal::PostOrderDFS_assignIds(*this);
      break;
  }
a1659 36
// In-Order Depth-First numbering

int CFGtraversal::traverse_counter = 0;

void CFGtraversal::InOrderDFS_assignId(CFGnode& cnode)
{
  if(cnode.traverse_id)
    return;

  cnode.traverse_id = -1; //- "visiting"

  for(int i = 0; i < cnode.nsuccs && cnode.succs[i]; ++i)
    InOrderDFS_assignId(*cnode.succs[i]);

  cnode.traverse_id = ++traverse_counter;
}

void CFGtraversal::InOrderDFS_assignIds(CFG& cfg)
{
  if(flag_verbose) fprintf(stderr, "Assigning CFG ids (in-order depth-first)...\n");

  suco_iterator<CFGfunction *> fni(cfg.getFunctionList());
  while(fni.Iterate()){
    //-- number both stmts and bblocks
    // - for now, use same counter (i.e., non-clashing ids)
    traverse_counter = 0;
    if(fni.Current()->entrystmt)
      InOrderDFS_assignId(*fni.Current()->entrystmt);
    if(fni.Current()->entryblock)
      InOrderDFS_assignId(*fni.Current()->entryblock);
  }

  if(flag_verbose) fprintf(stderr, "... done assigning CFG ids\n");
}

////////////////////////////////////
d1662 1
a1662 1
void CFGtraversal::PostOrderDFS_assignId(CFGnode& cnode)
d1672 1
a1672 1
        PostOrderDFS_assignId(*cnode.succs[i]);
d1679 1
a1679 1
      PostOrderDFS_assignId(*cnode.succs[i]);
d1681 1
a1681 1
    cnode.traverse_id = ++traverse_counter;
d1685 1
a1685 1
void CFGtraversal::PostOrderDFS_assignIds(CFG& cfg)
d1689 1
a1689 1
  suco_iterator<CFGfunction *> fni(cfg.getFunctionList());
d1693 1
a1693 1
    traverse_counter = 0;
d1695 1
a1695 1
      PostOrderDFS_assignId(*fni.Current()->entrystmt);
d1697 1
a1697 66
      PostOrderDFS_assignId(*fni.Current()->entryblock);
  }

  if(flag_verbose) fprintf(stderr, "... done assigning CFG ids\n");
}

////////////////////////////////////
// Successor-Wait Algorithm
// - each node numbered only after all predecessors numbered
// - loop accounted for by adding "successor-wait" nodes onto
//   a waiting list

suco_llist<CFGnode *> CFGtraversal::successorWait_list;

void CFGtraversal::successorWait_assignId(CFGnode& cnode, bool force)
{
  if(cnode.traverse_id)
    return;

  if(!force){
    for(int i = 0; i < cnode.npreds && cnode.preds[i]; ++i){
      if(!cnode.preds[i]->traverse_id){
        if(!successorWait_list.Contains(&cnode))
          successorWait_list.Append(&cnode);
        return;
      }
    }
  }

  cnode.traverse_id = ++traverse_counter;

  for(int i = 0; i < cnode.nsuccs && cnode.succs[i]; ++i)
    successorWait_assignId(*cnode.succs[i]);
}

void CFGtraversal::successorWait_assignIds(CFG& cfg)
{
  if(flag_verbose) fprintf(stderr, "Assigning CFG ids (successor-wait)...\n");

  if(flag_verbose >= 2){
    fprintf(stderr, "Nodes numbered: stmts bblocks function\n");
  }
  suco_iterator<CFGfunction *> fni(cfg.getFunctionList());
  while(fni.Iterate()){
    //-- number both stmts and bblocks
    // - for now, use same counter (i.e., non-clashing ids)
    traverse_counter = 0;
    successorWait_list.Clear();
    if(fni.Current()->entrystmt){
      successorWait_assignId(*fni.Current()->entrystmt);
      while(!successorWait_list.IsEmpty())
        successorWait_assignId(*successorWait_list.RemoveHead(), true);
    }
    int numstmts = traverse_counter;
    if(fni.Current()->entryblock){
      successorWait_assignId(*fni.Current()->entryblock);
      while(!successorWait_list.IsEmpty())
        successorWait_assignId(*successorWait_list.RemoveHead(), true);
    }
    int numblocks = traverse_counter - numstmts;
    if(flag_verbose >= 2){
      fprintf(stderr, "\t%d/%d\t%d/%d\t%s\n",
			numstmts, fni.Current()->getStmtList().Length(),
			numblocks, fni.Current()->getBBlist().Length(),
			fni.Current()->getId().getPid().getname());
    }
@


1.48
log
@Added flag for different DFA traversal mode (numbering
of CFGnodes in different order).
Currently has:
 1. in-order --> seems the best?
                 (note: is misnomer -- should in fact be post-order)
 2. post-order --> with CFG node ordering, turns out
                   to be equivalent to in-order?
 3. succ-last --> turns out to be logically flawed
                   (suboptimal).
In short -- added much overhead for a debug experiment that failed.
May want to remove succ-last, which numbers them in opposite
priority order -- so we can simplify worklist comparison function.
@
text
@d1183 4
d1252 1
a1252 1
  collectLocalDecls();
d1259 54
d1819 2
a1820 1
suco_set<AOId *> * CFGfunction::cld_curlvars = 0;
d1822 1
a1822 1
bool CFGfunction::collectLocalVars(PgmExpr& df)
d1824 45
a1868 7
  if(df.getKind() == PgmExpr::fDecl){
    if(CFGfunction::cld_curlvars){ //- assertion
      PExprDecl& dd = (PExprDecl &)df;
      if(dd.isLocal())
        CFGfunction::cld_curlvars->Insert((AOId *)&dd.getAO());
      //-- else should be malloc
    } else fprintf(stderr, "CFGfunction::collectLocalVars error -- cld_curlvars not set\n");
d1873 1
a1873 1
void CFGfunction::collectLocalDecls()
d1875 2
a1876 1
  CFGfunction::cld_curlvars = &this->localvars;
d1879 1
a1879 1
    cni.Current()->traverseRootNodes(CFGfunction::collectLocalVars);
d1883 1
a1883 1
void CFG::collectLocalDecls()
d1885 1
a1885 1
  if(flag_verbose) fprintf(stderr, "Collecting function local variables...\n");
d1890 1
a1890 1
    fni.Current()->collectLocalDecls();
d1894 82
a1975 1
  if(flag_verbose) fprintf(stderr, "... done collecting function local variables (%d)\n", numlocals);
@


1.47
log
@Added class CFGtraversal to encapsulate ways of numbering
CFG nodes.
Currently uses InOrderDFS; wrote skeleton (body not written)
for successorWait algorithm.
@
text
@d1256 12
a1267 1
  CFGtraversal::InOrderDFS_assignIds(*this);
d1649 44
d1700 1
a1700 1
void CFGtraversal::successorWait_assignId(CFGnode& cnode)
d1702 17
d1725 3
d1736 2
d1739 1
d1742 9
@


1.46
log
@Modified verbose output slightly.
@
text
@d1256 1
a1256 1
  assignCFGids();
d1601 6
a1606 1
void CFGnode::assignId(int& counter)
d1608 1
a1608 1
  if(this->traverse_id)
d1611 1
a1611 1
  this->traverse_id = -1; //- "visiting"
d1613 2
a1614 2
  for(int i = 0; i < nsuccs && succs[i]; ++i)
    succs[i]->assignId(counter);
d1616 1
a1616 1
  this->traverse_id = ++counter;
d1619 1
a1619 1
void CFG::assignCFGids()
d1621 1
a1621 1
  if(flag_verbose) fprintf(stderr, "Assigning CFG ids...\n");
d1623 1
a1623 1
  suco_iterator<CFGfunction *> fni(this->fnlist);
d1627 1
a1627 1
    int cfgid_counter = 0;
d1629 1
a1629 1
      fni.Current()->entrystmt->assignId(cfgid_counter);
d1631 34
a1664 1
      fni.Current()->entryblock->assignId(cfgid_counter);
@


1.45
log
@1. Added mechanism to output full trace with -v4.
2. Modified trigger counter output mechanism to output
   a full histogram rather than just some stats on the
   max.  Currently implemented as static functions
   within dfa.cpp; should absorb into one of the
   classes?
@
text
@d1664 1
d1666 1
a1666 1
  while(fni.Iterate())
d1668 2
d1671 1
a1671 1
  if(flag_verbose) fprintf(stderr, "... done collecting function local variables\n");
@


1.44
log
@Added worklist traversal mode (fifo, lifo, leaf-first),
the last sorting the worklist in call-graph leaf-first
order (non-recursive first), and within each function,
sorting by a traversal_id which is a bottom-up numbering
of CFGnodes.
@
text
@d942 1
a942 1
  fprintf(outf, "%s--{ Node %s (aid=<%d,%d>, nargs=%d)\n",
d977 1
a977 1
  fprintf(outf, "%s--{ Node %s (aid=<%d,%d>)\n",
d992 1
a992 1
  fprintf(outf, "%s--{ Node %s / %s (", ispaces, getKindString(), getDkindString());
d1004 1
a1004 1
  fprintf(outf, "%s--{ Node %s (aid=<%d,%d>)\n",
d1047 2
a1048 2
  fprintf(outf, "%s--{ Node %d (aid=<%d,%d>)",
		ispaces, traverse_id, aid.filestem_id, aid.aid);
d1131 2
a1132 2
    fprintf(outf, "%s--} end Node %d (aid=<%d,%d>)\n",
		  ispaces, traverse_id, aid.filestem_id, aid.aid);
d1139 2
a1140 1
  fprintf(outf, "%s--{ BBlock %d%s", ispaces, traverse_id, hascall?" hascall":"");
d1167 1
a1167 1
    fprintf(outf, "%s--} end BBlock %d\n", ispaces, traverse_id);
@


1.43
log
@Changed flag_verbose to be an integer indicating verbose
level: 1 (default) only lists current analysis phase;
2 gives progress dots; 3 supplies other "normal" verbose
information; 4 is for debug stuff.
@
text
@d1047 2
a1048 2
  fprintf(outf, "%s--{ Node (aid=<%d,%d>)",
		ispaces, aid.filestem_id, aid.aid);
d1052 1
a1052 1
      fprintf(outf, " %d", getSucc(i)->aid.aid);
d1058 1
a1058 1
      fprintf(outf, " %d", getPred(i)->aid.aid);
d1131 2
a1132 2
    fprintf(outf, "%s--} end Node (aid=<%d,%d>)\n",
		  ispaces, aid.filestem_id, aid.aid);
d1139 1
a1139 1
  fprintf(outf, "%s--{ BBlock %d%s", ispaces, uid, hascall?" hascall":"");
d1143 1
a1143 1
      fprintf(outf, " %d", ((CFGbblock*)succs[i])->uid);
d1149 1
a1149 1
      fprintf(outf, " %d", ((CFGbblock*)preds[i])->uid);
d1166 1
a1166 1
    fprintf(outf, "%s--} end BBlock %d\n", ispaces, uid);
d1255 1
a1473 2
int CFGbblock::uidcounter = 0;

d1476 1
a1476 1
  nodelist(), hascall(false), uid(++uidcounter)
d1594 35
@


1.42
log
@Added CFGbblock::debug_dump; now -debug will dump CFG
with basic blocks.
Also, fixed bug with callsite : in bblock mode, must getBBlock()
for the callee return nodes.
@
text
@d1252 1
a1252 2
  if(flag_verbose)
    fprintf(stderr, "... done traversing callgraph.\n");
d1578 1
a1578 1
  if(flag_verbose)
d1587 2
a1588 1
  if(flag_verbose) fprintf(stderr, "Constructing basic blocks (BLOCKS/NODES/MAX/AVG)...\n");
@


1.41
log
@Added bblock field to PgmStmts -- which is now assigned
during basic block construction time, and is used for
adding function return callsite nodes to the worklist.
Bblock algo still not working -- don't know why -- but
at least it doesn't crash.
@
text
@d970 1
a970 1
  fprintf(outf, "%s}--\n", ispaces);
d985 1
a985 1
  fprintf(outf, "%s}--\n", ispaces);
d1010 1
a1010 1
  fprintf(outf, "%s}--\n", ispaces);
d1022 1
a1022 1
    while(fli.Iterate()) fli.Current()->debug_dump(outf, indent+1);
d1025 1
a1025 1
  fprintf(outf, "%s}-- end Parallel\n", ispaces);
d1035 1
a1035 1
  while(tfi.Iterate()) tfi.Current()->debug_dump(outf, indent+1);
d1039 1
a1039 1
  while(ffi.Iterate()) ffi.Current()->debug_dump(outf, indent+1);
d1041 1
a1041 1
  fprintf(outf, "%s}-- end Branch\n", ispaces);
d1125 1
a1125 1
      fli.Current()->debug_dump(outf, indent+1);
d1128 1
a1128 1
    fprintf(outf, "%sMBUfact: ", ispaces);
d1131 1
a1131 1
    fprintf(outf, "%s}-- end Node (aid=<%d,%d>)\n",
d1136 34
d1182 1
a1182 1
    fprintf(outf, "  { Callees:\n");
d1187 1
a1187 1
    fprintf(outf, "  } end callees\n");
d1189 1
a1189 1
    fprintf(outf, "  { Callsites:\n");
d1194 1
a1194 1
    fprintf(outf, "  } end callsites\n");
d1196 8
a1203 3
    suco_iterator<PgmStmt *> nli(cfglist);
    while(nli.Iterate()){
      nli.Current()->debug_dump(outf, 2);
d1207 1
a1207 1
  fprintf(outf, " }-- end Function (aid=<%d,%d>)\n", aid.filestem_id, aid.aid);
d1213 1
a1213 1
  fprintf(outf, " --{ Global decls:\n");
d1217 5
a1221 1
  fprintf(outf, " }-- end Global decls\n");
d1225 1
a1225 1
  fprintf(outf, "}-- end CFG (%d functions)\n", fnlist.Length());
d1474 2
d1478 1
a1478 1
  nodelist(), hascall(false)
@


1.40
log
@Added WorkList class;
Moved isEntryNode() from PgmStmt to CFGnode;
Added CFGnode::isExitNode() (virtual function, implemented
by CFGbblock and PgmStmt)
@
text
@a906 11

        //-- create new empty CFG node, representing the entry
        //   point to entire CFG
        if(flag_use_bblocks)
          this->entry = new CFGbblock(cfn);
        else
          this->entry = new PgmStmt(cfn);
        if(cfn.getEntryNode())
          this->entry->addSuccessor(*cfn.getEntryNode());
        else
          fprintf(stderr, "Main function has no entry node!\n");
d1199 5
d1207 4
a1210 8
  if(this->mainfn){
    if(flag_verbose) fprintf(stderr, "Traversing callgraph...\n");
    this->mainfn->traverseCallGraph(0);
    if(flag_verbose)
      fprintf(stderr, "... done traversing callgraph.\n");
  } else {
    fprintf(stderr, "CallGraph traversal bypassed: CFG has no main function\n");
  }
d1213 12
d1431 1
a1431 3
CFGbblock::CFGbblock(PgmStmt& headnode,
		     suco_llist<PgmStmt *>& unusednodes,
		     suco_llist<PgmStmt *>& pendingnodes)
d1436 1
a1447 1
      unusednodes.Remove(cnode);
d1449 1
d1452 1
a1452 1
  //- add unused successors to pendingnodes
d1454 2
a1455 24
    if(cnode->getSucc(i) && unusednodes.Remove(cnode->getSucc(i)))
      pendingnodes.Append(cnode->getSucc(i));
}

// - currently, using naive linear search
CFGbblock * CFGfunction::lookupBlockByHead(PgmStmt& cn)
{
  suco_iterator<CFGbblock *> bli(this->bblocks);
  while(bli.Iterate()){
    if(bli.Current()->nodelist.Head() == &cn)
      return bli.Current();
  }
  return 0;
}

// - currently, using naive linear search
CFGbblock * CFGfunction::lookupBlockByTail(PgmStmt& cn)
{
  suco_iterator<CFGbblock *> bli(this->bblocks);
  while(bli.Iterate()){
    if(bli.Current()->nodelist.Last() == &cn)
      return bli.Current();
  }
  return 0;
d1460 1
a1460 3
  suco_llist<PgmStmt *> unusednodes;
  unusednodes.Copy(this->cfglist);
  suco_llist<PgmStmt *> pendingnodes;
a1467 1
  unusednodes.Remove(this->entrystmt);
d1473 1
a1473 1
    CFGbblock& newblk = *new CFGbblock(cnode, unusednodes, pendingnodes);
a1478 4
//-NOTE: at this point, unusednodes may be non-empty:
//       the nodes it contains should be unreachable nodes,
//       usually artifacts of my handling of switch statements?

d1504 3
a1506 3
//-NOTE: lookup failure may be due to either the unreachable
//       nodes (see unusednodes note above), or from _prog_main's
//       "global entry" node.
d1510 1
a1510 1
        if((bb.preds[i] = this->lookupBlockByTail(*hnode.getPred(j))) != 0)
d1528 1
a1528 1
        if((bb.succs[i] = this->lookupBlockByHead(*tnode.getSucc(j))) != 0)
@


1.39
log
@Added -bblocks flag; partially separated bblock and non-bblock
mode of DFA; many bblock components not yet written.
@
text
@d1786 16
a1811 5
}

bool PgmStmt::isEntryNode() const
{
  return (this == parent.getEntryNode());
@


1.38
log
@Renamed CFGnode to PgmStmt, then created new base
class CFGnode from which PgmStmt and CFGbblock are
derived. Added PgmStmt.getPred/getSucc helper functions
for cleaner lookups.
@
text
@d884 2
a885 2
  //- assign entrynode
  cfn->entrynode = cfn->cfglist.Head();
d910 4
a913 1
        this->entry = new PgmStmt(cfn);
d1152 1
a1152 1
			aid.filestem_id, aid.aid, entrynode->getAid().aid, exitnodes.Length(),
d1226 1
a1226 1
// CFG CONNECT CALL/FN NODES (SUPERGRAPH)
d1262 22
d1334 1
a1334 6
      PgmStmt * cn = cni.Current();
      suco_iterator<PgmExpr *> dfi(cn->nodelist);
      while(dfi.Iterate()){
        PgmExpr * df = dfi.Current();
        df->traverseRootNodes(CFG::assignCallTargets);
      }
d1426 1
a1426 6
  bool no_call = true;
  suco_iterator<PgmExpr *> dfi(this->nodelist);
  while(no_call && dfi.Iterate()){
    no_call &= dfi.Current()->traverseRootNodes(PgmExpr::notFunctionCall);
  }
  return !no_call;
d1485 1
a1485 1
  if(!entrynode){
d1490 3
a1492 3
  //- consume entrynode
  unusednodes.Remove(entrynode);
  pendingnodes.Insert(entrynode);
d1497 4
a1500 1
    this->bblocks.Append(new CFGbblock(cnode, unusednodes, pendingnodes));
d1604 1
a1604 4
    suco_iterator<PgmExpr *> dfi(cni.Current()->nodelist);
    while(dfi.Iterate()){
      dfi.Current()->traverseRootNodes(CFGfunction::collectLocalVars);
    }
d1622 8
@


1.37
log
@Earlier commented-out changes deleted.
@
text
@d34 1
a34 1
PgmExpr * PgmExpr::read(InputState& is, char * buf, CFGnode * parent)
d45 1
a45 1
          fprintf(stderr, "Reading call node with no parent CFGnode!\n");
d141 1
a141 1
void PgmExpr::readlist(InputState& is, char * buf, suco_llist<PgmExpr *>& nodelist, CFGnode * parent)
d151 1
a151 1
PExprParallel& PExprParallel::read(InputState& is, char * buf, CFGnode * parent)
d185 1
a185 1
PExprBranch& PExprBranch::read(InputState& is, char * buf, CFGnode * parent)
d220 1
a220 1
CFGnode& CFGnode::read(InputState& is, CFGfunction& par, char * buf)
d222 1
a222 1
  CFGnode * cfgn = new CFGnode(par);
d248 1
a248 1
        } else fprintf(stderr, "CFGnode::read: bad label marker on line %s", buf);
d256 1
a256 1
        fprintf(stderr, "CFGnode::read: next assertion failed on line %s", buf);
d266 1
a266 1
  } else fprintf(stderr, "CFGnode::read: bad start marker on line %s", buf);
d271 1
a271 1
void CFGnode::readlist(InputState& is, CFGfunction& par, char * buf, CFGnode *& current, suco_llist<CFGnode *>& nodelist)
d276 1
a276 1
    if(!CFGnode::readentry(is,par,buf,current,nodelist))
d282 1
a282 1
bool CFGnode::readentry(InputState& is, CFGfunction& par, char * buf, CFGnode *& current, suco_llist<CFGnode *>& nodelist)
d296 1
a296 1
	    CFGnode& pred_node = CFGnode::read(is, par, buf);
d302 1
a302 1
	      fprintf(stderr, "CFGnode::readentry: expecting while next on line %s", buf);
d312 3
a314 3
	    suco_llist<CFGnode *> snodelist;
	    CFGnode * scurrent = &pred_node;
	    CFGnode::readlist(is, par, buf, scurrent, snodelist);
d318 1
a318 1
	      fprintf(stderr, "CFGnode::readentry: expecting while end on line %s", buf);
d328 2
a329 2
	      suco_llist<CFGnode *> continuenodes;
	      suco_llist<CFGnode *> breaknodes;
d331 1
a331 1
	      suco_iterator<CFGnode *> sni(snodelist);
d333 1
a333 1
	        CFGnode * n = sni.Current();
d346 1
a346 1
	        suco_iterator<CFGnode *> cni(continuenodes);
d360 1
a360 1
	        CFGnode * outnode = new CFGnode(par);
d368 1
a368 1
	        suco_iterator<CFGnode *> bni(breaknodes);
d382 1
a382 1
	    CFGnode& pred_node = CFGnode::read(is, par, buf);
d388 1
a388 1
	      fprintf(stderr, "CFGnode::readentry: expecting do-while next on line %s", buf);
d392 2
a393 2
	    suco_llist<CFGnode *> snodelist;
	    CFGnode::readlist(is, par, buf, current, snodelist);
d397 1
a397 1
	      fprintf(stderr, "CFGnode::readentry: expecting do-while end on line %s", buf);
d417 2
a418 2
	      suco_llist<CFGnode *> continuenodes;
	      suco_llist<CFGnode *> breaknodes;
d420 1
a420 1
	      suco_iterator<CFGnode *> sni(snodelist);
d422 1
a422 1
	        CFGnode * n = sni.Current();
d439 1
a439 1
	        suco_iterator<CFGnode *> cni(continuenodes);
d448 1
a448 1
	        CFGnode * outnode = new CFGnode(par);
d457 1
a457 1
	        suco_iterator<CFGnode *> bni(breaknodes);
d468 1
a468 1
	    CFGnode& node1 = CFGnode::read(is, par, buf);
d473 1
a473 1
	    CFGnode& node2 = CFGnode::read(is, par, buf);
d477 1
a477 1
	    CFGnode& node3 = CFGnode::read(is, par, buf);
d482 1
a482 1
	      fprintf(stderr, "CFGnode::readentry: expecting for next on line %s", buf);
d498 3
a500 3
	    suco_llist<CFGnode *> snodelist;
	    CFGnode * scurrent = &node2;
	    CFGnode::readlist(is, par, buf, scurrent, snodelist);
d504 1
a504 1
	      fprintf(stderr, "CFGnode::readentry: expecting for end on line %s", buf);
d513 2
a514 2
	      suco_llist<CFGnode *> continuenodes;
	      suco_llist<CFGnode *> breaknodes;
d516 1
a516 1
	      suco_iterator<CFGnode *> sni(snodelist);
d518 1
a518 1
	        CFGnode * n = sni.Current();
d531 1
a531 1
	        suco_iterator<CFGnode *> cni(continuenodes);
d547 1
a547 1
	        CFGnode * outnode = new CFGnode(par);
d555 1
a555 1
	        suco_iterator<CFGnode *> bni(breaknodes);
d569 1
a569 1
	    CFGnode& pred_node = CFGnode::read(is, par, buf);
d580 1
a580 1
	      fprintf(stderr, "CFGnode::readentry: failed verify if next on line %s", buf);
d585 1
a585 1
	    CFGnode::readlist(is, par, buf, current, nodelist);
d588 1
a588 1
	    CFGnode * outnode = new CFGnode(par);
d595 1
a595 1
	      fprintf(stderr, "CFGnode::readentry: expecting if next on line %s", buf);
d600 1
a600 1
	    CFGnode::readlist(is, par, buf, current, nodelist);
d607 1
a607 1
	      fprintf(stderr, "CFGnode::readentry: expecting if end on line %s", buf);
d619 1
a619 1
	    CFGnode& pred_node = CFGnode::read(is, par, buf);
d629 1
a629 1
	      fprintf(stderr, "CFGnode::readentry: expecting switch next on line %s", buf);
d633 3
a635 3
	    CFGnode * scurrent = 0;
	    suco_llist<CFGnode *> snodelist;
	    CFGnode::readlist(is, par, buf, scurrent, snodelist);
d639 1
a639 1
	      fprintf(stderr, "CFGnode::readentry: expecting switch end on line %s", buf);
d648 2
a649 2
	      suco_llist<CFGnode *> casenodes;
	      suco_llist<CFGnode *> breaknodes;
d652 1
a652 1
	      suco_iterator<CFGnode *> sni(snodelist);
d654 1
a654 1
	        CFGnode * n = sni.Current();
d666 1
a666 1
	      CFGnode * outnode = new CFGnode(par);
d678 1
a678 1
	        suco_iterator<CFGnode *> cni(casenodes);
d690 1
a690 1
	        suco_iterator<CFGnode *> bni(breaknodes);
d702 1
a702 1
	    CFGnode& cfgn = CFGnode::read(is, par, buf);
d708 1
a708 1
	    fprintf(stderr, "CFGnode::readentry: bad start marker on line %s", buf);
d718 1
a718 1
	    CFGnode * n = new CFGnode(par, AID(fsid,aid));
d734 1
a734 1
	    CFGnode * n = new CFGnode(par, AID(fsid,aid));
d741 1
a741 1
	    CFGnode * n = new CFGnode(par, AID(fsid,aid));
d748 1
a748 1
	    CFGnode * n = new CFGnode(par, AID(fsid,aid));
d761 1
a761 1
	    CFGnode * n = new CFGnode(par, AID(fsid,aid));
d768 1
a768 1
	    CFGnode * n = new CFGnode(par, AID(fsid,aid));
d776 1
a776 1
	    CFGnode * n = new CFGnode(par, AID(fsid,aid));
d783 1
a783 1
	    fprintf(stderr, "CFGnode::readentry: bad jump marker on line %s", buf);
d793 1
a793 1
    fprintf(stderr, "CFGnode::readentry: bad prefix on line %s", buf);
d819 1
a819 1
  CFGnode * current = 0;
d824 1
a824 1
    CFGnode& cfgn = CFGnode::read(is, *cfn, buf);
d839 1
a839 1
    CFGnode::readentry(is, *cfn, buf, current, cfn->cfglist);
d844 2
a845 2
  suco_llist<CFGnode *> gotonodes;
  suco_iterator<CFGnode *> cni(cfn->cfglist);
d847 1
a847 1
    CFGnode * n = cni.Current();
d854 2
a855 2
    suco_llist<CFGnode *> labelcache;
    suco_iterator<CFGnode *> gni(gotonodes);
d857 1
a857 1
      CFGnode * gn = gni.Current();
d860 1
a860 1
        suco_iterator<CFGnode *> ani(cfn->cfglist);
d865 1
a865 1
      suco_iterator<CFGnode *> lni(labelcache);
d875 2
a876 2
    CFGnode * retn = new CFGnode(*cfn);
    retn->annot.kind = CFGnode::Annot::aReturn;
d910 1
a910 1
        this->entry = new CFGnode(cfn);
d1052 1
a1052 1
void CFGnode::debug_dump(FILE * outf, int indent, bool brief)
d1059 2
a1060 2
    for(int i = 0; i < nsuccs && succs[i]; ++i)
      fprintf(outf, " %d", succs[i]->aid.aid);
d1065 2
a1066 2
    for(int i = 0; i < npreds && preds[i]; ++i)
      fprintf(outf, " %d", preds[i]->aid.aid);
d1170 1
a1170 1
    suco_iterator<CFGnode *> nli(cfglist);
d1307 1
a1307 1
    suco_iterator<CFGnode *> cni(fn->cfglist);
d1309 1
a1309 1
      CFGnode * cn = cni.Current();
d1404 1
a1404 1
bool CFGnode::hasFunctionCalls()
d1414 5
a1418 6
CFGbblock::CFGbblock(CFGnode& headnode,
		     suco_llist<CFGnode *>& unusednodes,
		     suco_llist<CFGnode *>& pendingnodes)
: nodelist(), succs(0), preds(0),
  hascall(false),
  worklist_flag(false), mbu_fact()
d1423 1
a1423 1
  CFGnode * cnode = &headnode;
d1427 2
a1428 2
	  && cnode->succs[0]->countPreds() == 1	  //- successor has only one predecessor
	  && !cnode->succs[0]->hasFunctionCalls()) //- successor has no function calls
d1431 1
a1431 1
      cnode = cnode->succs[0];
d1437 3
a1439 3
  for(int i = 0; i < cnode->nsuccs; ++i)
    if(cnode->succs[i] && unusednodes.Remove(cnode->succs[i]))
      pendingnodes.Append(cnode->succs[i]);
d1443 1
a1443 1
CFGbblock * CFGfunction::lookupBlockByHead(CFGnode& cn)
d1454 1
a1454 1
CFGbblock * CFGfunction::lookupBlockByTail(CFGnode& cn)
d1466 1
a1466 1
  suco_llist<CFGnode *> unusednodes;
d1468 1
a1468 1
  suco_llist<CFGnode *> pendingnodes;
d1481 1
a1481 1
    CFGnode& cnode = *pendingnodes.RemoveHead();
d1507 1
a1507 1
      CFGnode& hnode = *bb.nodelist.Head();
d1510 2
a1511 2
      int npreds = hnode.countPreds();
      bb.preds = new CFGbblock * [npreds+1];
d1519 3
a1521 7
      if(hnode.preds){
        for(int j = 0; j < hnode.npreds; ++j){
          if(hnode.preds[j]){
            if((bb.preds[i] = this->lookupBlockByTail(*hnode.preds[j])) != 0)
              i++;
          }
        }
d1529 1
a1529 1
      CFGnode& tnode = *bb.nodelist.Last();
d1532 2
a1533 2
      int nsuccs = tnode.countSuccs();
      bb.succs = new CFGbblock * [nsuccs+1];
d1537 3
a1539 7
      if(tnode.succs){
        for(int j = 0; j < tnode.nsuccs; ++j){
          if(tnode.succs[j]){
            if((bb.succs[i] = this->lookupBlockByHead(*tnode.succs[j])) != 0)
              i++;
          }
        }
d1584 1
a1584 1
  suco_iterator<CFGnode *> cni(this->cfglist);
d1669 1
a1669 1
      fprintf(stderr, "CFGnode::addSuccessor: infrequent case encountered! (nsuccs=%d, aid=%d)\n", nsuccs, aid.aid);
d1696 1
a1696 1
      fprintf(stderr, "CFGnode::addPredecessor: infrequent case encountered! (npreds=%d, aid=%d)\n", n.npreds, n.aid.aid);
d1749 4
a1752 6
  if(preds){
    int i;
    for(i = 0; i < npreds && preds[i]; ++i)
      ;
    return i;
  } else return 0;
d1757 16
a1772 6
  if(succs){
    int i;
    for(i = 0; i < nsuccs && succs[i]; ++i)
      ;
    return i;
  } else return 0;
d1775 1
a1775 1
bool CFGnode::isEntryNode() const
d1780 1
a1780 1
bool CFGnode::hasLabel(const char * s) const
d1792 1
a1792 1
bool CFGnode::hasSwitchPred() const
d1794 2
a1795 2
  for(int i = 0; i < npreds; ++i)
    if(preds[i] && preds[i]->annot.kind == Annot::aSwitch)
@


1.36
log
@"Simplified" CFGnode succ/pred members to contain a single
array, rather than treating pred1/succ1 specially.
Old code commented out, will be cleaned out next.
@
text
@d334 1
a334 1
		if(n->annot.kind == Annot::aContinue && !n->/*succ1*/succs)
d336 1
a336 1
		if(n->annot.kind == Annot::aBreak && !n->/*succ1*/succs)
d423 1
a423 1
		if(n->annot.kind == Annot::aContinue && !n->/*succ1*/succs)
d425 1
a425 1
		if(n->annot.kind == Annot::aBreak && !n->/*succ1*/succs)
d519 1
a519 1
		if(n->annot.kind == Annot::aContinue && !n->/*succ1*/succs)
d521 1
a521 1
		if(n->annot.kind == Annot::aBreak && !n->/*succ1*/succs)
d661 1
a661 1
		if(n->annot.kind == Annot::aBreak && !n->/*succ1*/succs)
d680 1
a680 1
		  if(cni.Current()->/*pred1*/preds) cni.Current()->initPredsCount(2);
a1056 8
/*
  if(succ1){
    fprintf(outf, "(succ = %d", succ1->aid.aid);
    for(int i = 0; i < nsuccs && succs[i]; ++i)
      fprintf(outf, " %d", succs[i]->aid.aid);
    fprintf(outf, " )");
  }
*//**/
a1062 9
/**/
/*
  if(pred1){
    fprintf(outf, "(pred = %d", pred1->aid.aid);
    for(int i = 0; i < npreds && preds[i]; ++i)
      fprintf(outf, " %d", preds[i]->aid.aid);
    fprintf(outf, " )");
  }
*//**/
a1068 1
/**/
a1426 5
/*
    while(cnode->succ1 && !cnode->nsuccs	//- only one successor
	  && !cnode->succ1->npreds		//- successor has only one predecessor
	  && !cnode->succ1->hasFunctionCalls())	//- successor has no function calls
*//**/
a1429 1
/**/
d1432 1
a1432 1
      cnode = cnode->/*succ1*/succs[0];
a1437 4
/*
  if(cnode->succ1 && unusednodes.Remove(cnode->succ1))
    pendingnodes.Append(cnode->succ1);
*/
d1511 1
a1511 1
      int npreds = /*(hnode.pred1)?(1 + hnode.npreds):0*/hnode.countPreds();
d1520 1
a1520 5
      if(hnode./*pred1*/preds){
/*
        if((bb.preds[i] = this->lookupBlockByTail(*hnode.pred1)) != 0)
          i++;
*/
d1537 1
a1537 1
      int nsuccs = /*(tnode.succ1)?(1 + tnode.nsuccs):0*/tnode.countSuccs();
d1542 1
a1542 5
      if(tnode./*succ1*/succs){
/*
        if((bb.succs[i] = this->lookupBlockByHead(*tnode.succ1)) != 0)
          i++;
*/
a1662 5
/*
  if(!succ1){  //- common case
    succ1 = &n;
  }
*//**/
a1668 1
/**/
a1689 5
/*
  if(!n.pred1){  //- common case
    n.pred1 = this;
  }
*//**/
a1695 1
/**/
a1720 14
/*
    if(!succs){
      succs = new CFGnode * [nsuccs = n-1];
      for(int i = 0; i < nsuccs; ++i) succs[i] = 0;
    } else if(nsuccs < n-1){
      CFGnode ** temp = succs;
      succs = new CFGnode * [n-1];
      int i;
      for(i = 0; i < nsuccs; ++i) succs[i] = temp[i];
      delete [] temp;
      nsuccs = n-1;
      for(; i < nsuccs; ++i) succs[i] = 0;
    }
*//**/
a1733 1
/**/
a1739 14
/*
    if(!preds){
      preds = new CFGnode * [npreds = n-1];
      for(int i = 0; i < npreds; ++i) preds[i] = 0;
    } else if(npreds < n-1){
      CFGnode ** temp = preds;
      preds = new CFGnode * [n-1];
      int i;
      for(i = 0; i < npreds; ++i) preds[i] = temp[i];
      delete [] temp;
      npreds = n-1;
      for(; i < npreds; ++i) preds[i] = 0;
    }
*//**/
a1752 1
/**/
a1794 4
/*
  if(pred1 && pred1->annot.kind == Annot::aSwitch)
    return true;
*/
@


1.35
log
@Fixed bug in traverseCallGraph -- now properly halts
backward-propagation of recursion_id at a node already
marked recursive.
@
text
@d334 1
a334 1
		if(n->annot.kind == Annot::aContinue && !n->succ1)
d336 1
a336 1
		if(n->annot.kind == Annot::aBreak && !n->succ1)
d423 1
a423 1
		if(n->annot.kind == Annot::aContinue && !n->succ1)
d425 1
a425 1
		if(n->annot.kind == Annot::aBreak && !n->succ1)
d519 1
a519 1
		if(n->annot.kind == Annot::aContinue && !n->succ1)
d521 1
a521 1
		if(n->annot.kind == Annot::aBreak && !n->succ1)
d661 1
a661 1
		if(n->annot.kind == Annot::aBreak && !n->succ1)
d680 1
a680 1
		  if(cni.Current()->pred1) cni.Current()->initPredsCount(2);
d1057 1
d1064 9
d1079 8
d1445 1
d1448 7
a1454 1
	  && !cnode->succ1->hasFunctionCalls()){//- successor has no function calls
d1456 1
a1456 1
      cnode = cnode->succ1;
d1462 1
d1465 1
d1539 1
a1539 1
      int npreds = (hnode.pred1)?(1 + hnode.npreds):0;
d1548 2
a1549 1
      if(hnode.pred1){
d1552 1
d1569 1
a1569 1
      int nsuccs = (tnode.succ1)?(1 + tnode.nsuccs):0;
d1574 2
a1575 1
      if(tnode.succ1){
d1578 1
d1699 1
d1702 10
a1711 1
  } else {
d1720 1
a1720 1
/**/fprintf(stderr, "CFGnode::addSuccessor: infrequent case encountered! (nsuccs=%d, aid=%d)\n", succs, aid.aid);
d1727 1
d1732 1
d1735 10
a1744 1
  } else {
d1753 1
a1753 1
/**/fprintf(stderr, "CFGnode::addPredecessor: infrequent case encountered! (npreds=%d, aid=%d)\n", n.npreds, n.aid.aid);
d1760 1
d1769 1
d1782 15
d1803 1
d1816 15
d1834 20
d1873 1
d1876 1
@


1.34
log
@Rewrote callgraph-traversal to
1. number each function in depth-first order (can be used for
   approximate DFA worklist prioritization)
2. number each recursive group with a unique id
   (can be used to more precisely identify cases of possible
    recursion, when the callsite_top stuff and handleReturnDealloc
    stuff need to be treated differently)
Tested somewhat, not too thorough.
@
text
@a1211 2
    int counter = 0;
    int recursing = 0;
d1325 25
d1356 1
a1356 1
    if(recursing){ //- if recursing, stop traversal
d1358 1
a1358 1
    } else {
d1368 6
a1373 2
      if(rid) this->recursion_id = rid;
      return rid;
d1376 1
a1376 1
    if(this->recursion_id){ //- if already recursive, stop traversal, return rid
d1378 2
a1379 2
    } else { //- traverse actives, set recursion_id
      if(!recursing){
d1390 1
a1390 1
  } else { //--positive=visited
@


1.33
log
@1. Added callgraph to CFGfunction: wrote traverser to
   determing if a function is recursive;
   In DFA/callsite: pre-facts are met only if function
   is recursive (or flag_callsite_top is false, with -callmeet
   flag), and also handleReturnDealloc is bypassed when function
   is recursive.
2. Fixed bug with Switch case: before fix, nested switches were
   not handled correctly: pred node was connect to all enclosing
   case stmts, including those nested in deeper switches.
@
text
@d1148 1
a1148 1
  fprintf(outf, ", aid=<%d,%d>, entry=%d, exit=%d, recursive=%s):\n",
d1150 1
a1150 1
			recursive?"true":"false");
d1212 5
a1216 2
    this->mainfn->traverseCallGraph(false);
    if(flag_verbose) fprintf(stderr, "... done traversing callgraph.\n");
d1327 1
a1327 1
void CFGfunction::traverseCallGraph(bool recursing)
d1329 36
a1364 23
  switch(this->callgraph_mode){
    case cgm_inactive: {
        if(!recursing){ //- if recursing, stop traversal
          this->callgraph_mode = cgm_active;
          suco_iterator<CFGfunction *> cgi(this->callgraph);
          while(cgi.Iterate()){
            cgi.Current()->traverseCallGraph(false);
          }
          this->callgraph_mode = cgm_visited;
        }
      } break;
    case cgm_active: {
        if(!this->recursive){ //- if already recursive, stop traversal
          this->recursive = true;
          suco_iterator<CFGfunction *> cgi(this->callgraph);
          while(cgi.Iterate()){
            cgi.Current()->traverseCallGraph(true);
          }
        }
      } break;
    case cgm_visited: {
        //-- do nothing
      } break;
@


1.32
log
@Changed verbose output: added worklist profile (per function),
now summarized with top five plus active delta.
@
text
@d655 1
a655 1
		if(n->annot.kind == Annot::aCaseLabel && !n->hasPred(pred_node))
d657 1
a657 1
		if(n->annot.kind == Annot::aDefaultLabel && !n->hasPred(pred_node)){
d905 3
d946 1
a946 1
void PExprCall::debug_dump(FILE * outf, int indent)
d973 4
a976 2
  fprintf(outf, "%s    MBUfact: ", ispaces);
  mbu_fact.debug_dump(outf);
d981 1
a981 1
void PExprAssign::debug_dump(FILE * outf, int indent)
d996 1
a996 1
void PExprDecl::debug_dump(FILE * outf, int indent)
d1008 1
a1008 1
void PExprVerify::debug_dump(FILE * outf, int indent)
d1021 1
a1021 1
void PExprParallel::debug_dump(FILE * outf, int indent)
d1036 1
a1036 1
void PExprBranch::debug_dump(FILE * outf, int indent)
d1052 1
a1052 1
void CFGnode::debug_dump(FILE * outf, int indent)
d1123 1
a1123 1
  if(nodelist.IsEmpty()){
d1144 1
a1144 1
void CFGfunction::debug_dump(FILE * outf)
d1148 7
a1154 2
  fprintf(outf, ", aid=<%d,%d>, entry=%d, exit=%d):\n",
			aid.filestem_id, aid.aid, entrynode->getAid().aid, exitnodes.Length());
d1156 13
a1168 3
  fprintf(outf, "     LocalVars: ");
  AO::write_set_string_rep(outf, (suco_set<AO *>&)localvars);
  fprintf(outf, "\n");
d1170 4
a1173 10
  fprintf(outf, "  { Callsites:\n");
  suco_iterator<PExprCall *> csi(callsites);
  while(csi.Iterate()){
    csi.Current()->debug_dump(outf, 4);
  }
  fprintf(outf, "  } end callsites\n");

  suco_iterator<CFGnode *> nli(cfglist);
  while(nli.Iterate()){
    nli.Current()->debug_dump(outf, 2);
d1209 9
d1270 1
d1273 5
d1316 1
d1321 32
d1723 1
a1723 1
bool CFGnode::hasPred(CFGnode& n)
d1725 2
a1726 1
  if(pred1 == &n) return true;
d1728 2
a1729 1
    if(preds[i] == &n) return true;
@


1.31
log
@1. fixed bug with switch case that was causing "addPredecessor:
   infrequent case encountered" warnings.
   --> due to miscount when a switch statement has no default
   label -- an edge is added from pred_node to the outnode,
   but that edge was not counted when initializing the predecessor
   count in the outnode.
2. reshuffled CFGnode member functions -- privatized a bunch of 'em.
@
text
@d1454 1
a1454 1
    fprintf(stderr, "BLOCKS/NODES/MAX/AVG:\t%d\t%d\t%d\t%.2f\n",
d1456 2
a1457 1
		(float)stat_numnodes/(float)stat_numblocks);
d1462 1
a1462 1
  if(flag_verbose) fprintf(stderr, "Constructing basic blocks...\n");
@


1.30
log
@Renamed DFAnode to PgmExpr, and its subclasses from
DFA_ to PExpr_.
@
text
@d687 3
a689 1
	        outnode->initPredsCount(breaknodes.Length());
d1162 1
a1162 1
  fprintf(outf, " }-- end Function (aid=<%d,%d>):\n", aid.filestem_id, aid.aid);
@


1.29
log
@Wrote basic block mechanism, and routines to construct it.
Currently builds, runs, but not yet used.
Also, consolidated CFG initialization into one function:
CFG:: prepareCFG, called by tca.cpp.
Makefile dependencies updated.
@
text
@d34 1
a34 1
DFAnode * DFAnode::read(InputState& is, char * buf, CFGnode * parent)
d36 1
a36 1
  DFAnode * df = 0;
d51 1
a51 1
          DFAcall& dfc = *new DFAcall(AID(fsid,aidno), faos, nargs, *parent);
d56 1
a56 1
            dfc.args[i] = new DFAarg(AID(fsid, argaid), argaos);
d65 1
a65 1
        df = new DFAassign(AID(fsid,aidno), e1aos, e2aos);
d72 1
a72 1
        if(pid) df = new DFAdecl(pid->get_AOId(), fsid, DFAdecl::dFormal, argno);
d92 1
a92 1
        df = new DFAverify((buf[2] == mVT)?(DFAnode::fVT):(DFAnode::fVP), AID(fsid,aidno), aos, estr);
d98 1
a98 1
        if(pid) df = new DFAdecl(pid->get_AOId(), fsid, DFAdecl::dLocal);
d105 1
a105 1
        if(pid) df = new DFAdecl(pid->get_AOId(), fsid, DFAdecl::dStatic);
d112 1
a112 1
        if(aid) df = new DFAdecl(aid->get_AOMalloc(), fsid, DFAdecl::dMalloc);
d118 1
a118 1
            df = &DFAparallel::read(is, buf, parent);
d121 1
a121 1
            df = &DFAbranch::read(is, buf, parent);
d124 1
a124 1
            // not valid DFAnode; return 0
d130 1
a130 1
        // end of DFA list; return 0
d133 1
a133 1
        fprintf(stderr, "DFAnode::read: invalid node ignored: %s", buf);
d136 1
a136 1
  } else fprintf(stderr, "DFAnode::read: bad prefix on line %s", buf);
d141 1
a141 1
void DFAnode::readlist(InputState& is, char * buf, suco_llist<DFAnode *>& nodelist, CFGnode * parent)
d144 1
a144 1
    DFAnode * df = DFAnode::read(is,buf,parent);
d151 1
a151 1
DFAparallel& DFAparallel::read(InputState& is, char * buf, CFGnode * parent)
d153 1
a153 1
  DFAparallel * df = new DFAparallel;
d166 1
a166 1
      suco_llist<DFAnode *>& nodelist = *new suco_llist<DFAnode *>;
d168 1
a168 1
      DFAnode::readlist(is, buf, nodelist, parent);
d175 1
a175 1
      fprintf(stderr, "DFAparallel::read: expecting end marker on line %s", buf);
d178 1
a178 1
      fprintf(stderr, "DFAparallel::read: numlist mismatch: header = %d, count = %d\n", numlists, countlists);
d180 1
a180 1
  } else fprintf(stderr, "DFAparallel::read: bad start marker on line %s", buf);
d185 1
a185 1
DFAbranch& DFAbranch::read(InputState& is, char * buf, CFGnode * parent)
d187 1
a187 1
  DFAbranch * df = new DFAbranch;
d194 1
a194 1
    fprintf(stderr, "DFAbranch::read: bad start marker on line %s", buf);
d200 1
a200 1
    DFAnode::readlist(is, buf, df->tnodelist, parent);
d202 1
a202 1
  else fprintf(stderr, "DFAbranch::read: expecting true list in %s", buf );
d208 1
a208 1
    DFAnode::readlist(is, buf, df->fnodelist, parent);
d210 1
a210 1
  else fprintf(stderr, "DFAbranch::read: expecting false list in %s", buf );
d215 1
a215 1
    fprintf(stderr, "DFAbranch::read: expecting end marker on line %s", buf);
d262 1
a262 1
      cfgn->nodelist.Append(DFAnode::read(is, buf, cfgn));
d913 1
a913 1
      DFAnode * df = DFAnode::read(is, buf, 0);
d941 1
a941 1
void DFAcall::debug_dump(FILE * outf, int indent)
d974 1
a974 1
void DFAassign::debug_dump(FILE * outf, int indent)
d989 1
a989 1
void DFAdecl::debug_dump(FILE * outf, int indent)
d1001 1
a1001 1
void DFAverify::debug_dump(FILE * outf, int indent)
d1014 1
a1014 1
void DFAparallel::debug_dump(FILE * outf, int indent)
d1019 1
a1019 1
  suco_iterator<suco_llist<DFAnode *> *> flsi(nodelists);
d1022 1
a1022 1
    suco_iterator<DFAnode *> fli(*flsi.Current());
d1029 1
a1029 1
void DFAbranch::debug_dump(FILE * outf, int indent)
d1035 1
a1035 1
  suco_iterator<DFAnode *> tfi(tnodelist);
d1039 1
a1039 1
  suco_iterator<DFAnode *> ffi(fnodelist);
d1124 1
a1124 1
    suco_iterator<DFAnode *> fli(nodelist);
d1149 1
a1149 1
  suco_iterator<DFAcall *> csi(callsites);
d1167 1
a1167 1
  suco_iterator<DFAnode *> gfi(globnodes);
d1200 1
a1200 1
bool DFAnode::traverseRootNodes(bool (*fp)(DFAnode& dn))
d1205 1
a1205 1
        suco_iterator<suco_llist<DFAnode *> *> fli(((DFAparallel *)this)->nodelists);
d1207 1
a1207 1
          suco_iterator<DFAnode *> dfi(*fli.Current());
d1214 1
a1214 1
        suco_iterator<DFAnode *> tfi(((DFAbranch *)this)->tnodelist);
d1217 1
a1217 1
        suco_iterator<DFAnode *> ffi(((DFAbranch *)this)->fnodelist);
d1233 1
a1233 1
DFAcall * CFG::act_caller_node = 0;
d1255 1
a1255 1
bool CFG::assignCallTargets(DFAnode& dn)
d1257 2
a1258 2
  if(dn.kind == DFAnode::fCall){
    CFG::act_caller_node = (DFAcall *)&dn;
d1278 1
a1278 1
      suco_iterator<DFAnode *> dfi(cn->nodelist);
d1280 1
a1280 1
        DFAnode * df = dfi.Current();
d1292 1
a1292 1
bool DFAnode::notFunctionCall(DFAnode& dn)
d1294 1
a1294 1
  return (dn.getKind() != DFAnode::fCall);
d1300 1
a1300 1
  suco_iterator<DFAnode *> dfi(this->nodelist);
d1302 1
a1302 1
    no_call &= dfi.Current()->traverseRootNodes(DFAnode::notFunctionCall);
d1474 1
a1474 1
bool CFGfunction::collectLocalVars(DFAnode& df)
d1476 1
a1476 1
  if(df.getKind() == DFAnode::fDecl){
d1478 1
a1478 1
      DFAdecl& dd = (DFAdecl &)df;
d1492 1
a1492 1
    suco_iterator<DFAnode *> dfi(cni.Current()->nodelist);
d1514 1
a1514 1
AO * DFAassign::getSingletonLHSloc()
d1530 1
a1530 1
const char * DFAnode::getKindString()
d1544 1
a1544 1
const char * DFAdecl::getDkindString()
@


1.28
log
@DFA: bug fix: lessThan had logical error -- fixed.
Also -- renamed and rewrote switchAndCompare, now
absorbAndCompare, which meets rather than switches
with the newly computed facts (and consumes it as
well, if need be).
CFG: added mbu_fact debug_dump
@
text
@d10 1
d1189 7
d1200 1
a1200 1
void DFAnode::traverseRootNodes(void (*fp)(DFAnode& dn))
d1202 1
d1206 1
a1206 1
        while(fli.Iterate()){
d1208 2
a1209 2
          while(dfi.Iterate()){
            dfi.Current()->traverseRootNodes(fp);
d1215 2
a1216 2
        while(tfi.Iterate())
          tfi.Current()->traverseRootNodes(fp);
d1218 2
a1219 2
        while(ffi.Iterate())
          ffi.Current()->traverseRootNodes(fp);
d1227 1
a1227 1
        fp(*this);
d1230 1
d1255 1
a1255 1
void CFG::assignCallTargets(DFAnode& dn)
d1264 1
d1269 2
d1285 181
d1474 1
a1474 1
void CFGfunction::collectLocalVars(DFAnode& df)
d1484 1
d1501 2
d1506 2
@


1.27
log
@1. in TCAstate, mbu is now a member -- it stores the results
   to be output later.
2. MBU now contains a result fact, and DFA analysis now
   progresses in two modes: iterating and collecting,
   the latter calling collectResultsVerifyTag(/Ptr)
   to accumulate the results.
3. in cfg.cpp/h, DFAdecl now has filestem_id argument,
   needed for consistent output.
Current state of program: compiles, runs without crashing,
but results are wrong (no output on many examples, suspect
function call handling error?).
@
text
@d966 4
d1127 3
@


1.26
log
@Major changes -- fixed logical flaws in ability to collect
MBU results.
1. Added suco_llist::Copy and suco_set::Union (non-destructive version)
2. In cfg.cpp/h, added new type DFAarg to represent a function
   call actual argument.
3. In dfa.cpp/h, MBUfacts now stores (in LocAidNode) for each
   AO, in place of just a single set of aids:
    - nodes:DFAnode - assignments, calls, and formal decls
    - args::DFAarg - function call arguments
    - rets:CFGnode - function return node
@
text
@d71 1
a71 1
        if(pid) df = new DFAdecl(pid->get_AOId(), DFAdecl::dFormal, argno);
d97 1
a97 1
        if(pid) df = new DFAdecl(pid->get_AOId(), DFAdecl::dLocal);
d104 1
a104 1
        if(pid) df = new DFAdecl(pid->get_AOId(), DFAdecl::dStatic);
d111 1
a111 1
        if(aid) df = new DFAdecl(aid->get_AOMalloc(), DFAdecl::dMalloc);
@


1.25
log
@Added argaids to DFAcall class (aids for function
call arguments).
@
text
@d53 3
a55 3
            dfc.argaids[i].filestem_id = fsid;
            dfc.argaids[i].aid = strtoul(cp, &cp, 10);
            dfc.argaoss[i] = &AO::stringToAOset(cp, &cp, is.aidmap, is.pidmap, is.values);
d959 5
a963 3
    fprintf(outf, "%s    Arg %d (aid=<%d,%d>): ",
		  ispaces, i+1, argaids[i].filestem_id, argaids[i].aid);
    if(argaoss[i]) AO::write_set_string_rep(outf, *argaoss[i]);
@


1.24
log
@Removed previously commented-out stuff (old aid/aidnos).
Also, moved CFG::writeFileStemMap to AID::writeFileStemMap.
@
text
@d52 3
a54 1
          for(int i = 0; i < nargs; ++i)
d56 1
d959 2
a960 1
    fprintf(outf, "%s    Arg %d: ", ispaces, i);
@


1.23
log
@Changed CFG nodes' AID member to be of type AID, which
is a pair <filestem_id, aid>; MBUfacts now tracks a set
of (references to) these, so we can have access to the
filestem_id for output.
Old code commented out -- will clear out in next checkin.
@
text
@d18 11
d812 1
a812 1
  CFGfunction * cfn = new CFGfunction(/*filestem_id,*/ *ao, AID(filestem_id,aidno));
a888 2
//  this->filestemlist.Append(filestem);
//  int filestem_id = this->filestemlist.Length();
a1126 2
//  fprintf(outf, ", aid=%d, fstem_id=%d, entry=%d, exit=%d):\n",
//			aid, filestemId, entrynode->getAid(), exitnodes.Length());
a1169 13

//- assign and write map of number to function name
void CFG::writeFileStemMap(FILE * outf)
{
/*
  int fnid = 0;
  suco_iterator<const char *> fli(this->filestemlist);
  while(fli.Iterate()){
    fnid++;
    fprintf(outf, "! @@ %d %s\n", fnid, fli.Current());
  }
*/
}
@


1.22
log
@Reorganized global flags, stat-collection and output;
moved TCcollectStats to diag.cpp/h, renamed to TCstats,
and absorbed what used to be in diag.cpp/h.
Global flags have been moved to flags.h, (they're defined
in tca.cpp, for now).
Removed the -stat flag: the "stat" output is now always
dumped, to the output file rather than stderr.
Added -mbu# flag, though haven't done anything with the
different mbu levels yet.
@
text
@d12 7
d27 1
d39 1
a39 1
          DFAcall& dfc = *new DFAcall(aidno, faos, nargs, *parent);
d50 1
a50 1
        df = new DFAassign(aidno, e1aos, e2aos);
d77 1
a77 1
        df = new DFAverify((buf[2] == mVT)?(DFAnode::fVT):(DFAnode::fVP), aidno, aos, estr);
d214 3
a216 1
    cfgn->aid = strtoul(cp, &cp, 10);
d226 1
a226 1
           && cfgn->aid == strtoul(cp, &cp, 10)){ // asserts, and advances cp!
d271 2
d701 1
a701 1
	    CFGnode * n = new CFGnode(par, aid);
d717 1
a717 1
	    CFGnode * n = new CFGnode(par, aid);
d724 1
a724 1
	    CFGnode * n = new CFGnode(par, aid);
d731 1
a731 1
	    CFGnode * n = new CFGnode(par, aid);
d744 1
a744 1
	    CFGnode * n = new CFGnode(par, aid);
d751 1
a751 1
	    CFGnode * n = new CFGnode(par, aid);
d759 1
a759 1
	    CFGnode * n = new CFGnode(par, aid);
d782 1
a782 1
CFGfunction& CFGfunction::read(InputState& is, char * buf, const char * filestem)
d801 1
a801 1
  CFGfunction * cfn = new CFGfunction(filestem, *ao, aidno);
d877 6
d885 1
a885 1
      CFGfunction& cfn = CFGfunction::read(is, buf, filestem);
d932 2
a933 1
  fprintf(outf, "%s--{ Node %s (aid=%d, nargs=%d)\n", ispaces, getKindString(), aid, nargs);
d958 2
a959 1
  fprintf(outf, "%s--{ Node %s (aid=%d)\n", ispaces, getKindString(), aid);
d985 2
a986 1
  fprintf(outf, "%s--{ Node %s (aid=%d)\n", ispaces, getKindString(), aid);
d1028 2
a1029 1
  fprintf(outf, "%s--{ Node (aid=%d)", ispaces, aid);
d1031 1
a1031 1
    fprintf(outf, "(succ = %d", succ1->aid);
d1033 1
a1033 1
      fprintf(outf, " %d", succs[i]->aid);
d1037 1
a1037 1
    fprintf(outf, "(pred = %d", pred1->aid);
d1039 1
a1039 1
      fprintf(outf, " %d", preds[i]->aid);
d1109 2
a1110 1
    fprintf(outf, "%s}-- end Node (aid=%d)\n", ispaces, aid);
d1118 4
a1121 2
  fprintf(outf, ", aid=%d, fstem=%s, entry=%d, exit=%d):\n",
			aid, filestem, entrynode->getAid(), exitnodes.Length());
d1139 1
a1139 1
  fprintf(outf, " }-- end Function (aid=%d):\n", aid);
d1161 21
d1185 1
a1185 1
void DFAnode::traverseRootNodes(void (*fp)(DFAnode& df))
d1238 1
a1238 1
void CFG::assignCallTargets(DFAnode& df)
d1240 2
a1241 2
  if(df.kind == DFAnode::fCall){
    CFG::act_caller_node = (DFAcall *)&df;
d1365 1
a1365 1
/**/fprintf(stderr, "CFGnode::addSuccessor: infrequent case encountered! (nsuccs=%d, aid=%d)\n", succs, aid);
d1387 1
a1387 1
/**/fprintf(stderr, "CFGnode::addPredecessor: infrequent case encountered! (npreds=%d, aid=%d)\n", n.npreds, n.aid);
@


1.21
log
@Resturctured:
 1. may-be-uninit analysis is now called directly from
    tca.cpp to mbu.doAnalysis, rather than with an intermediate
    cfg.mayBeUninitAnalysis.
 2. updated CFG data structures, so that
    a. each CFG has a unique entry node (with no DFA content,
       so that its facts can be assigned after computing
       global facts). Note that while this node's parent is
       set to main, it doesn't count as main's entry node.
    b. DFAcall nodes now have mbu_facts, and pointers to
       their parents.
 3. in DFA, refined further analysis process, so that all
    that remains to be written are
    a. handleFormal(), which will look up the callsites
       and compute whatever facts are needed, and
    b. fCall case, which needs to handle return values
       as well (may be non-trivial, this one).
@
text
@a9 1
#include "ty.h" // for TCA_BUF_SIZE
@


1.20
log
@Deleted previously-commented out stuff (old MBU stuff, now in dfa.cpp/h)
@
text
@d16 1
a16 1
DFAnode * DFAnode::read(InputState& is, char * buf)
d25 12
a36 8
        char * cp = &buf[4];
        int aidno = strtoul(cp, &cp, 10);
        suco_set<AO *>& faos = AO::stringToAOset(cp, &cp, is.aidmap, is.pidmap, is.values);
        int nargs = strtoul(cp, &cp, 10);
        DFAcall& dfc = *new DFAcall(aidno, faos, nargs);
        df = &dfc;
        for(int i = 0; i < nargs; ++i)
          dfc.argaoss[i] = &AO::stringToAOset(cp, &cp, is.aidmap, is.pidmap, is.values);
d96 1
a96 1
            df = &DFAparallel::read(is, buf);
d99 1
a99 1
            df = &DFAbranch::read(is, buf);
d119 1
a119 1
void DFAnode::readlist(InputState& is, char * buf, suco_llist<DFAnode *>& nodelist)
d122 1
a122 1
    DFAnode * df = DFAnode::read(is,buf);
d129 1
a129 1
DFAparallel& DFAparallel::read(InputState& is, char * buf)
d146 1
a146 1
      DFAnode::readlist(is, buf, nodelist);
d163 1
a163 1
DFAbranch& DFAbranch::read(InputState& is, char * buf)
d178 1
a178 1
    DFAnode::readlist(is, buf, df->tnodelist);
d186 1
a186 1
    DFAnode::readlist(is, buf, df->fnodelist);
d238 1
a238 1
      cfgn->nodelist.Append(DFAnode::read(is, buf));
d872 9
a880 2
      if(!strcmp(cfn.idao.getPid().getname(), ".main"))
        this->mainfn = &cfn;
d883 1
a883 1
      DFAnode * df = DFAnode::read(is, buf);
d1171 1
a1171 1
DFAcall * CFG::act_call_target = 0;
d1177 1
a1177 1
    if(CFG::act_fnlist && CFG::act_call_target){ // assertion
d1183 2
a1184 2
            CFG::act_call_target->targetfns.Insert(fli.Current());
            fli.Current()->callsites.Insert(CFG::act_call_target);
d1196 2
a1197 2
    CFG::act_call_target = (DFAcall *)&df;
    suco_iterator<AO *> faoi(CFG::act_call_target->faos);
d1260 1
a1260 1
// MAY-BE-UNINIT ANALYSIS
a1278 17
void CFG::mayBeUninitAnalysis()
{
  if(!mainfn || !mainfn->entrynode){
    fprintf(stderr, "DFA: main function not found, or has no entrynode: cannot do DFA\n");
    return;
  }

//-- note: for may-be-unalloc analyses, must first process globals

  MBU mbu;
  mbu.doAnalysis(*mainfn->entrynode);
}

//----------------------------------
// OTHER MEMBER FUNCTIONS
//----------------------------------

d1388 5
@


1.19
log
@Wrote much stuff for MBU (may-be-uninit) analysis, but
changed them, abstracting them out into the new files
dfa.cpp/dfa.h. That now seems to work, but the old stuff
have been left behind, commented out. The next checkin will
delete these commented-out parts.
@
text
@a1266 314
/*
MBU_facts::~MBU_facts()
{
  LocAidNode * np = head;
  while(np){
    LocAidNode * del = np;
    np = np->next;
    delete del;
  }
}

void MBU_facts::debug_dump(FILE * outf)
{
  LocAidNode * np;
  fprintf(outf, "MBU:");
  for(np = this->head; np; np = np->next){
    fprintf(outf, "[ ");
    np->ao.write_string_rep(outf);
    fprintf(outf, ":");
    suco_iterator<int> ai(np->aids);
    while(ai.Iterate())
      fprintf(outf, " %d", ai.Current());
    fprintf(outf, " ]");
  }
  fprintf(outf, "\n");
}

void MBU_facts::stealFrom(MBU_facts& mf)
{
  this->head = mf.head;
  mf.head = 0;
}

//-- set union
void MBU_facts::meet(MBU_facts * mf)
{
  if(mf){
    //-- copy elements of mf into this
    LocAidNode ** tnpp = &this->head;
    LocAidNode * mnp = mf->head;
    while(mnp){
      if((!*tnpp) || (&mnp->ao < &(*tnpp)->ao)){ //- copy over
        *tnpp = new LocAidNode(*mnp, *tnpp);
        mnp = mnp->next;
        tnpp = &(*tnpp)->next;
      } else if(&mnp->ao == &(*tnpp)->ao){ //- add aids
        suco_iterator<int> mni(mnp->aids);
        while(mni.Iterate())
          (*tnpp)->aids.Insert(mni.Current());
        mnp = mnp->next;
        tnpp = &(*tnpp)->next;
      } else { //- continue
        tnpp = &(*tnpp)->next;
      }
    }
  } //-- else, !mf --> "top"
}

//-- set intersection
void MBU_facts::join(MBU_facts& mf)
{
  LocAidNode ** tnpp = &this->head;
  LocAidNode * mnp = mf.head;
  while(*tnpp){
    if((!mnp) || (&(*tnpp)->ao < &mnp->ao)){ //- not in mf, delete
      LocAidNode * del = *tnpp;
      *tnpp = (*tnpp)->next;
      delete del;
    } else if(&(*tnpp)->ao == &mnp->ao){ //- add aids
      suco_iterator<int> mni(mnp->aids);
      while(mni.Iterate())
        (*tnpp)->aids.Insert(mni.Current());
      mnp = mnp->next;
      tnpp = &(*tnpp)->next;
    } else { //- continue
      mnp = mnp->next;
    }
  }
}

bool MBU_facts::keysEqual(MBU_facts& mf)
{
  LocAidNode * tnp = this->head;
  LocAidNode * mnp = mf.head;
  while(tnp && mnp && (&tnp->ao == &mnp->ao)){
    tnp = tnp->next;
    mnp = mnp->next;
  }
  return (!tnp && !mnp);
}

void MBU_facts::addFact(AO& ao, int aidno)
{
  LocAidNode ** np;
  for(np = &head; *np && (&(*np)->ao < &ao); np = &(*np)->next);
  if(*np && (&(*np)->ao == &ao)){ //-- node found, add aidno
    if(aidno)
      (*np)->aids.Insert(aidno);
  } else {
    *np = new LocAidNode(ao, aidno, *np);
  }
}

void MBU_facts::removeFacts(AO& ao)
{
  LocAidNode ** np;
  for(np = &head; *np && (&(*np)->ao < &ao); np = &(*np)->next);
  if(*np && (&(*np)->ao == &ao)){ //-- node found, remove
    LocAidNode * del = *np;
    *np = (*np)->next;
    delete del;
  }
}

//-- static helpers for addUnsafeAliasLocs
MBU_facts * MBU_facts::aual_facts = 0;
int MBU_facts::aual_aid = 0;
bool MBU_facts::add_locs_to_aual_facts(AO& ao)
{
  if(MBU_facts::aual_facts && ao.isLoc() && (ao.getTSC() >= AO::TSC_EXPOSED))
    aual_facts->addFact(ao, MBU_facts::aual_aid);
  return true;
}

//-- traverse aliases of aoset, add safe and exposed locs
//   to this.
void MBU_facts::addUnsafeAliasLocs(suco_set<AO *>& aoset, int aidno)
{
  //-- collect aoset's ecrset
  suco_set<ECR *> ecrset;
  suco_iterator<AO *> aoi(aoset);
  while(aoi.Iterate())
    if(aoi.Current()->hasECR())
      ecrset.Insert(&ECR::getECR(*aoi.Current()));

  //-- set aual_facts, aual_aid
  MBU_facts::aual_facts = this;
  MBU_facts::aual_aid = aidno;

  //-- do traversal
  ECR::traverseSetAliases(ecrset, MBU_facts::add_locs_to_aual_facts);
}

//-- static helpers for intersectsAliases --
suco_set<ECR *> MBU_facts::ia_ecrset;

bool MBU_facts::is_ia_ecrset(ECR& ecr)
{
  return !MBU_facts::ia_ecrset.Contains(&ecr);
}

//-- check to see if this intersects with the alias set of aoset.
//   We'll do this by collecting this' ecrset, and do a traversal
//   of aoset's ecrs to see if they reach any of this' ecrset.
bool MBU_facts::intersectsAliases(suco_set<AO *>& aoset)
{
  //-- collect this's aos' ecrset
  MBU_facts::ia_ecrset.Clear();
  LocAidNode * np;
  for(np = head; np; np = np->next)
    if(np->ao.hasECR())
      MBU_facts::ia_ecrset.Insert(&ECR::getECR(np->ao));

  //-- collect aoset's ecrset
  suco_set<ECR *> ecrset;
  suco_iterator<AO *> aoi(aoset);
  while(aoi.Iterate())
    if(aoi.Current()->hasECR())
      ecrset.Insert(&ECR::getECR(*aoi.Current()));

  //-- do traversal
  return !ECR::traverseSetAliases(ecrset, 0, MBU_facts::is_ia_ecrset);
}
*/
#if 0 /* { */
suco_queue<CFGnode *> MBUanalysis::worklist;

void MBUanalysis::propagateDFAnode(DFAnode& dn, MBU_facts& mf)
{
  switch(dn.getKind()){
    case DFAnode::fCall: {
        DFAcall& dc = (DFAcall&) dn;
      } break;
    case DFAnode::fAssign: {
        DFAassign& da = (DFAassign&) dn;
        AO * lhsloc = da.getSingletonLHSloc();
        if(lhsloc){
          //-- strong assignment
          if(lhsloc->getTSC() >= AO::TSC_EXPOSED){
            if(mf.intersectsAliases(da.getRHS())){
              mf.addFact(*lhsloc, da.getAid());
            } else {
              mf.removeFacts(*lhsloc);
            }
          }
        } else {
          //-- weak assignment
          if(AO::getSetTSC(da.getLHS()) >= AO::TSC_EXPOSED){
            if(mf.intersectsAliases(da.getRHS())){
              mf.addUnsafeAliasLocs(da.getLHS(), da.getAid());
            } //-- else cannot kill anything
          }
        }
      } break;
    case DFAnode::fDecl: {
        DFAdecl& dd = (DFAdecl&) dn;
        if(dd.isLocal() || dd.isMalloc()){
          AO& ao = dd.getAO();
          if(ao.getTSC() >= AO::TSC_EXPOSED)	//-- filter safe and tracked AOs
            mf.addFact(ao);
        }
      } break;
    case DFAnode::fParallel: {
        DFAparallel& dp = (DFAparallel&) dn;
        MBU_facts smf; //- smf = source mf
        smf.stealFrom(mf); //- -> smf is original, mf is empty
        bool mf_is_bottom = true;
        suco_iterator<suco_llist<DFAnode *> *> lli(dp.getNodeLists());
        while(lli.Iterate()){
          MBU_facts tmf(&smf); //- tmf = temp mf, for this branch
          suco_iterator<DFAnode *> li(*lli.Current());
          while(li.Iterate())
            propagateDFAnode(*li.Current(), tmf);
          //-- do join
          if(mf_is_bottom){
            mf.stealFrom(tmf);
            mf_is_bottom = false;
          } else {
            mf.join(tmf);
          }
          //-- local tmf will self-destruct
        }
        if(mf_is_bottom) //-- should not occur (empty parallel)
          mf.stealFrom(smf);
/**/if(!smf.keysEqual(mf)){
/**/fprintf(stderr, "Parallel: ");
/**/dp.debug_dump(stderr);
/**/fprintf(stderr, "Pre-Facts: ");
/**/smf.debug_dump(stderr);
/**/fprintf(stderr, "Post-Facts: ");
/**/mf.debug_dump(stderr);
/**/}
        //-- local smf will self-destruct
      } break;
    case DFAnode::fBranch: {
        DFAbranch& db = (DFAbranch&) dn;
        MBU_facts fmf(&mf);
        //-- send mf through true branch, fmf through false branch
        suco_iterator<DFAnode *> tni(db.getTrueNodes());
        while(tni.Iterate())
          propagateDFAnode(*tni.Current(), mf);
        suco_iterator<DFAnode *> fni(db.getFalseNodes());
        while(fni.Iterate())
          propagateDFAnode(*fni.Current(), fmf);
        //-- now meet
        mf.meet(&fmf);
        //-- local fmf will self-destruct
      } break;
    case DFAnode::fVT: //- no action
    case DFAnode::fVP: //- no action
      break;
  }
}

void MBUanalysis::propagateCFGnode(CFGnode& cn)
{
  //-- get in-facts, by meeting copies of predecessor facts
  MBU_facts * mf = new MBU_facts();
  if(cn.pred1){
    mf->meet(cn.pred1->mbu_facts);
    if(cn.preds)
    for(int i = 0; i < cn.npreds && cn.preds[i]; ++i)
      mf->meet(cn.preds[i]->mbu_facts);
  }

  //-- process CFG node
  suco_iterator<DFAnode *> nli(cn.nodelist);
  while(nli.Iterate())
    propagateDFAnode(*nli.Current(), *mf);

  //-- compare with out-facts: if different, add successors to worklist
  bool add_succs = false;
  if(!cn.mbu_facts){
    cn.mbu_facts = mf;
    add_succs = true;
  } else {
    MBU_facts& old = *cn.mbu_facts;
    cn.mbu_facts = mf;	//-- always update with latest
    add_succs = !mf->keysEqual(old); //-- compare old with mf : should only ever be >=
    delete &old; //-- delete old
  }

  //-- add successors to worklist
  if(add_succs){
    //-- regular successors
    if(cn.succ1){
      worklist.Insert(cn.succ1);
      for(int i = 0; i < cn.nsuccs && cn.succs[i]; ++i)
        worklist.Insert(cn.succs[i]);
    }
    //-- function return successors
  }
}

void MBUanalysis::doAnalysis(CFGnode& entry)
{
  worklist.Clear();
  worklist.Enqueue(&entry);
  while(!worklist.IsEmpty()){
    CFGnode * cn = worklist.Dequeue();
    propagateCFGnode(*cn);
  }
}
#endif /* } if 0 */
d1276 1
a1276 1
//  MBUanalysis::doAnalysis(*mainfn->entrynode);
@


1.18
log
@CFG: wrote MBUfacts test for intersection between a MBUfact
and an AOset's alias set (done using ECR::traverseAliases).
Cascaded changes to AO/ECR include:
1. AO::ts_categ is now explicitly enumerated to allow >=
   comparison
2. ECR::traverseAliases now takes bool functions, and
   returns a bool, true if all applications return true,
   and false if *any* application returns false (and also
   halts traversal -- this is an optimization for the
   intersection check added: once an intersection is found,
   no further traversal is needed).
@
text
@d1267 2
a1268 2

MBUfacts::~MBUfacts()
d1278 1
a1278 1
void MBUfacts::debug_dump(FILE * outf)
d1294 8
a1301 1
void MBUfacts::meet(MBUfacts * mf)
d1325 23
a1347 1
bool MBUfacts::keysEqual(MBUfacts& mf)
d1358 1
a1358 1
void MBUfacts::addFact(AO& ao, int aidno)
d1370 42
a1411 1
suco_set<ECR *> MBUfacts::ia_ecrset;
d1413 1
a1413 1
bool MBUfacts::is_ia_ecrset(ECR& ecr)
d1415 1
a1415 1
  return !MBUfacts::ia_ecrset.Contains(&ecr);
d1421 1
a1421 1
bool MBUfacts::intersectsAliases(suco_set<AO *>& aoset)
d1424 1
a1424 1
  MBUfacts::ia_ecrset.Clear();
d1428 1
a1428 1
      MBUfacts::ia_ecrset.Insert(&ECR::getECR(np->ao));
d1438 1
a1438 1
  return !ECR::traverseSetAliases(ecrset, is_ia_ecrset);
d1440 3
d1444 1
a1444 3
suco_queue<CFGnode *> MBU::worklist;

void MBU::propagateDFAnode(DFAnode& dn, MBUfacts& mf)
d1457 1
a1457 1
/**/fprintf(stderr, "Strong Assign Intersects Yes\n");
d1459 1
a1459 1
/**/fprintf(stderr, "Strong Assign Intersects No\n");
d1466 2
a1467 4
/**/fprintf(stderr, "Weak Assign Intersects Yes\n");
            } else {
/**/fprintf(stderr, "Weak Assign Intersects No\n");
            }
d1481 29
d1513 11
d1531 1
a1531 1
void MBU::propagateCFGnode(CFGnode& cn)
d1534 1
a1534 1
  MBUfacts * mf = new MBUfacts();
d1553 1
a1553 1
    MBUfacts& old = *cn.mbu_facts;
d1571 1
a1571 1
void MBU::doAnalysis(CFGnode& entry)
d1580 1
d1590 3
a1592 1
  MBU::doAnalysis(*mainfn->entrynode);
@


1.17
log
@Added determination of strong/weak assignments.
@
text
@d1163 1
a1163 1
void CFG::addAOtoCallTarget(AO& ao)
d1179 1
d1341 30
d1383 8
a1390 1
//-- strong assignment
d1392 8
a1399 1
//-- weak assignment
d1406 1
a1406 2
          if(ao.getTSC() == AO::TSC_SAFE ||	//-- filter safe and tracked AOs
	     ao.getTSC() == AO::TSC_EXPOSED)
@


1.16
log
@Started writing MBU, MBUfacts classes.
Skeletal framework started, not done.
@
text
@d1251 16
d1317 23
d1342 1
a1342 1
void MBU::propagateDFAnode(DFAnode& dn)
d1344 32
d1386 1
a1386 1
        mf->meet(cn.preds[i]->mbu_facts);
d1390 3
d1400 1
a1400 1
    MBUfacts * old = cn.mbu_facts;
d1402 2
a1403 4
    //-- now, compare old with mf

    //-- delete old
    delete old;
d1412 1
a1412 1
          worklist.Insert(cn.succs[i]);
@


1.15
log
@Added Malloc decl.
@
text
@d1251 57
a1307 1
void CFG::mayBeUninitAnalysis()
d1309 23
a1331 3
  if(!mainfn){
    fprintf(stderr, "DFA: main function not found, cannot do DFA\n");
    return;
d1334 11
a1344 1
//-- note: for may-be-unalloc analyses, first process globals
d1346 4
a1349 2
  suco_queue<CFGnode *> worklist;
  worklist.Enqueue(mainfn->entrynode);
d1352 1
d1354 11
@


1.14
log
@1. Added collectLocalDecls/collectLocalVars to collect
   the set of local variables in each function.
2. Readjusted function exit handling so that (a) all exit
   nodes are annotated RETURN, (b) each function is associated
   with a set of exitnodes, rather than a single exitnode,
2a.Each CFGnode now has a pointer to its parent function
2b.Return nodes now handle the AOs that were previously
   not output by tc -assign.
@
text
@d16 1
a16 1
DFAfact * DFAfact::read(InputState& is, char * buf)
d18 1
a18 1
  DFAfact * df = 0;
d47 1
a47 1
        else fprintf(stderr, "Invalid Pid (%d) read for CFG formal fact\n", pidno);
d65 2
a66 2
        } else if(*cp != '@@') fprintf(stderr, "Invalid expr-string for verifyTag fact: %s", cp);
        df = new DFAverify((buf[2] == mVT)?(DFAfact::fVT):(DFAfact::fVP), aidno, aos, estr);
d73 1
a73 1
        else fprintf(stderr, "Invalid Pid (%d) read for CFG local-decl fact\n", pidno);
d80 8
a87 1
        else fprintf(stderr, "Invalid Pid (%d) read for CFG static-decl fact\n", pidno);
d98 1
a98 1
            // not valid DFAfact; return 0
d107 1
a107 1
        fprintf(stderr, "DFAfact::read: invalid fact ignored: %s", buf);
d110 1
a110 1
  } else fprintf(stderr, "DFAfact::read: bad prefix on line %s", buf);
d115 1
a115 1
void DFAfact::readlist(InputState& is, char * buf, suco_llist<DFAfact *>& factlist)
d118 3
a120 3
    DFAfact * df = DFAfact::read(is,buf);
    if(df) factlist.Append(df);
    else break; // non-fact item; break out
d136 1
a136 1
    //-- process factlists
d140 1
a140 1
      suco_llist<DFAfact *>& factlist = *new suco_llist<DFAfact *>;
d142 2
a143 2
      DFAfact::readlist(is, buf, factlist);
      df->factlists.Append(&factlist);
d170 1
a170 1
  //-- process true factlist
d174 1
a174 1
    DFAfact::readlist(is, buf, df->tfactlist);
d178 1
a178 1
  //-- process false factlist
d182 1
a182 1
    DFAfact::readlist(is, buf, df->ffactlist);
d231 1
a231 1
    //-- process facts, until node end
d234 1
a234 1
      cfgn->factlist.Append(DFAfact::read(is, buf));
d872 2
a873 2
      DFAfact * df = DFAfact::read(is, buf);
      if(df) this->globfacts.Append(df);
d904 1
a904 1
  fprintf(outf, "%s--{ Fact %s (aid=%d, nargs=%d)\n", ispaces, getKindString(), aid, nargs);
d929 1
a929 1
  fprintf(outf, "%s--{ Fact %s (aid=%d)\n", ispaces, getKindString(), aid);
d943 1
a943 1
  fprintf(outf, "%s--{ Fact %s / %s (", ispaces, getKindString(), getDkindString());
d947 1
a947 1
  idao.write_string_rep(outf);
d955 1
a955 1
  fprintf(outf, "%s--{ Fact %s (aid=%d)\n", ispaces, getKindString(), aid);
d968 1
a968 1
  suco_iterator<suco_llist<DFAfact *> *> flsi(factlists);
d971 1
a971 1
    suco_iterator<DFAfact *> fli(*flsi.Current());
d984 1
a984 1
  suco_iterator<DFAfact *> tfi(tfactlist);
d988 1
a988 1
  suco_iterator<DFAfact *> ffi(ffactlist);
d1064 1
a1064 1
  if(factlist.IsEmpty()){
d1072 1
a1072 1
    suco_iterator<DFAfact *> fli(factlist);
d1111 1
a1111 1
  suco_iterator<DFAfact *> gfi(globfacts);
d1129 1
a1129 1
void DFAfact::traverseRootFacts(void (*fp)(DFAfact& df))
d1133 1
a1133 1
        suco_iterator<suco_llist<DFAfact *> *> fli(((DFAparallel *)this)->factlists);
d1135 1
a1135 1
          suco_iterator<DFAfact *> dfi(*fli.Current());
d1137 1
a1137 1
            dfi.Current()->traverseRootFacts(fp);
d1142 1
a1142 1
        suco_iterator<DFAfact *> tfi(((DFAbranch *)this)->tfactlist);
d1144 2
a1145 2
          tfi.Current()->traverseRootFacts(fp);
        suco_iterator<DFAfact *> ffi(((DFAbranch *)this)->ffactlist);
d1147 1
a1147 1
          ffi.Current()->traverseRootFacts(fp);
d1181 1
a1181 1
void CFG::assignCallTargets(DFAfact& df)
d1183 1
a1183 1
  if(df.kind == DFAfact::fCall){
d1201 1
a1201 1
      suco_iterator<DFAfact *> dfi(cn->factlist);
d1203 2
a1204 2
        DFAfact * df = dfi.Current();
        df->traverseRootFacts(CFG::assignCallTargets);
d1216 1
a1216 1
void CFGfunction::collectLocalVars(DFAfact& df)
d1218 1
a1218 1
  if(df.getKind() == DFAfact::fDecl){
d1220 4
a1223 1
      CFGfunction::cld_curlvars->Insert(&((DFAdecl &)df).getIdAO());
d1233 1
a1233 1
    suco_iterator<DFAfact *> dfi(cni.Current()->factlist);
d1235 1
a1235 1
      dfi.Current()->traverseRootFacts(CFGfunction::collectLocalVars);
d1271 1
a1271 1
const char * DFAfact::getKindString()
d1291 1
@


1.13
log
@Added initial framework for flow-sensitive stuff in tca.cpp/h.
Wrote functions to connect call/return nodes to function nodes
to create supergraph.
Minor change in id.cpp/h: get_AOId returns reference to AOId
rather than AO object; similarly for get_AOStringLit/get_AOMalloc.
@
text
@d187 1
a187 1
CFGnode& CFGnode::read(InputState& is, char * buf)
d189 1
a189 1
  CFGnode * cfgn = new CFGnode;
d236 1
a236 1
void CFGnode::readlist(InputState& is, char * buf, CFGnode *& current, suco_llist<CFGnode *>& nodelist)
d241 1
a241 1
    if(!CFGnode::readentry(is,buf,current,nodelist))
d247 1
a247 1
bool CFGnode::readentry(InputState& is, char * buf, CFGnode *& current, suco_llist<CFGnode *>& nodelist)
d259 1
a259 1
	    CFGnode& pred_node = CFGnode::read(is, buf);
d277 1
a277 1
	    CFGnode::readlist(is, buf, scurrent, snodelist);
d323 1
a323 1
	        CFGnode * outnode = new CFGnode;
d345 1
a345 1
	    CFGnode& pred_node = CFGnode::read(is, buf);
d356 1
a356 1
	    CFGnode::readlist(is, buf, current, snodelist);
d411 1
a411 1
	        CFGnode * outnode = new CFGnode;
d431 1
a431 1
	    CFGnode& node1 = CFGnode::read(is, buf);
d436 1
a436 1
	    CFGnode& node2 = CFGnode::read(is, buf);
d440 1
a440 1
	    CFGnode& node3 = CFGnode::read(is, buf);
d463 1
a463 1
	    CFGnode::readlist(is, buf, scurrent, snodelist);
d510 1
a510 1
	        CFGnode * outnode = new CFGnode;
d532 1
a532 1
	    CFGnode& pred_node = CFGnode::read(is, buf);
d548 1
a548 1
	    CFGnode::readlist(is, buf, current, nodelist);
d551 1
a551 1
	    CFGnode * outnode = new CFGnode;
d563 1
a563 1
	    CFGnode::readlist(is, buf, current, nodelist);
d582 1
a582 1
	    CFGnode& pred_node = CFGnode::read(is, buf);
d598 1
a598 1
	    CFGnode::readlist(is, buf, scurrent, snodelist);
d629 1
a629 1
	      CFGnode * outnode = new CFGnode;
d663 1
a663 1
	    CFGnode& cfgn = CFGnode::read(is, buf);
d679 1
a679 1
	    CFGnode * n = new CFGnode(aid);
d695 1
a695 1
	    CFGnode * n = new CFGnode(aid);
d702 1
a702 1
	    CFGnode * n = new CFGnode(aid);
d709 5
a713 1
	    CFGnode * n = new CFGnode(aid);
d715 2
d722 1
a722 1
	    CFGnode * n = new CFGnode(aid);
d729 1
a729 1
	    CFGnode * n = new CFGnode(aid);
d737 1
a737 1
	    CFGnode * n = new CFGnode(aid);
d785 1
a785 1
    CFGnode& cfgn = CFGnode::read(is, buf);
d800 1
a800 1
    CFGnode::readentry(is, buf, current, cfn->cfglist);
a804 1
  suco_llist<CFGnode *> returnnodes;
d809 1
a809 1
    if(n->isReturn()) returnnodes.Append(n);
d833 11
a843 3
  //- add current to returnnodes, if non-null and not already counted
  if(current && !current->isReturn())
    returnnodes.Insert(current);
a847 14
  //- assign exitnode
  if(returnnodes.Length() == 1){
    cfn->exitnode = returnnodes.Head();
  } else { //-- if nontrivial return, join all return nodes to single exit node
    cfn->exitnode = new CFGnode;
    cfn->exitnode->initPredsCount((current?1:0) + returnnodes.Length());

    //-- now add return nodes
    suco_iterator<CFGnode *> rni(returnnodes);
      while(rni.Iterate()) rni.Current()->addSuccessor(*cfn->exitnode);

    cfn->cfglist.Append(cfn->exitnode);
  }

d1020 7
a1026 1
      fprintf(outf, "(RETURN)");
d1079 6
a1084 1
			aid, filestem, entrynode->getAid(), exitnode->getAid());
d1091 1
d1096 1
d1119 1
a1119 1
// CFG MANIPULATION/ANALYSIS FUNCTIONS
d1203 38
d1246 8
@


1.12
log
@Added "expression string" (estr) argument to verifyTag and
verifyPtr facts.
@
text
@d6 1
d759 1
a759 1
  AO * ao = 0;
d771 2
a772 1
  if(!ao) ao = &is.values.get_AOValue(TCtype::tcVoidType);
d860 5
d902 9
d941 1
a941 1
  pidao.write_string_rep(outf);
d1072 1
a1072 1
  pidao.write_string_rep(outf);
d1075 6
d1105 93
@


1.11
log
@Added include <ctype.h>
@
text
@d48 1
a48 6
      case mVT: {
        char * cp = &buf[4];
        int aidno = strtoul(cp, &cp, 10);
        suco_set<AO *>& aos = AO::stringToAOset(cp, &cp, is.aidmap, is.pidmap, is.values);
        df = new DFAverify(DFAfact::fVT, aidno, aos);
      } break;
d53 13
a65 1
        df = new DFAverify(DFAfact::fVP, aidno, aos);
d934 1
@


1.10
log
@Changed DFAformal to DFAdecl; now accepts three kinds
of decls: formal, local, and static.
Also, CFG::read will read in global decls and assignments
(actually, will accept all facts, but should be restricted
only to decls and assignments)
@
text
@d1 1
@


1.9
log
@Reduced scope of AOlist class: this is only to be used
specially within the AO tree to look up AOs.
All other occurrences (in ecr, cfg, etc) have been converted
to use suco_set<AO *>.
Should be no change in behavior.
@
text
@d44 1
a44 1
        if(pid) df = new DFAformal(argno, pid->get_AOId());
d59 14
d86 4
d91 1
a91 1
        // not valid DFAfact; return 0
d847 1
a847 1
    if(buf[2] == mStart && buf[4] == mFunction){
d850 4
a853 1
    //-- todo: add other cases (for external decls) here
d883 1
a883 1
  fprintf(outf, "%s--{ Fact %s (aid=%d, nargs=%d)\n", ispaces, kindToString(kind), aid, nargs);
d899 1
a899 1
  fprintf(outf, "%s--{ Fact %s (aid=%d)\n", ispaces, kindToString(kind), aid);
d909 1
a909 1
void DFAformal::debug_dump(FILE * outf, int indent)
d913 4
a916 1
  fprintf(outf, "%s--{ Fact %s (argno=%d, ao = ", ispaces, kindToString(kind), argno);
d925 1
a925 1
  fprintf(outf, "%s--{ Fact %s (aid=%d)\n", ispaces, kindToString(kind), aid);
d1060 5
d1066 1
a1066 1
  while(fli.Iterate()){
a1067 1
  }
d1079 1
a1079 1
const char * DFAfact::kindToString(enum Kind k)
d1081 1
a1081 1
  switch(k){
d1084 1
a1084 1
    case fFormal:   return "Formal";
d1090 11
@


1.8
log
@Augmented cfg DFfacts with references to AOs;
the respective read functions call AO::stringToAOs,
which requires the pidmap and aidmap arguments from tca,
so a new class InputState was created (in tca.h) to
pass these around conveniently.
Also, added another helper function AO::stringToAOlist
to read in lists of AOs, separated by ',', terminated by
'.'.
@
text
@d25 1
a25 1
        AOlist& faol = AO::stringToAOlist(cp, &cp, is.aidmap, is.pidmap, is.values);
d27 1
a27 1
        DFAcall& dfc = *new DFAcall(aidno, faol, nargs);
d30 1
a30 1
          dfc.argaols[i] = &AO::stringToAOlist(cp, &cp, is.aidmap, is.pidmap, is.values);
d35 3
a37 3
        AOlist& e1aol = AO::stringToAOlist(cp, &cp, is.aidmap, is.pidmap, is.values);
        AOlist& e2aol = AO::stringToAOlist(cp, &cp, is.aidmap, is.pidmap, is.values);
        df = new DFAassign(aidno, e1aol, e2aol);
d50 2
a51 2
        AOlist& aol = AO::stringToAOlist(cp, &cp, is.aidmap, is.pidmap, is.values);
        df = new DFAverify(DFAfact::fVT, aidno, aol);
d56 2
a57 2
        AOlist& aol = AO::stringToAOlist(cp, &cp, is.aidmap, is.pidmap, is.values);
        df = new DFAverify(DFAfact::fVP, aidno, aol);
d864 1
a864 1
  faol.write_string_rep(outf);
d868 1
a868 1
    argaols[i]->write_string_rep(outf);
d880 1
a880 1
  e1aol.write_string_rep(outf);
d883 1
a883 1
  e2aol.write_string_rep(outf);
d903 1
a903 1
  aol.write_string_rep(outf);
@


1.7
log
@Incorporated cfg.cpp/cfg.h into rtca project.
Modified DFfacts to be abstract, and have many children;
CFGfunction now stores a "filestem" argument;
tca -debug mode now dumps the CFG as well;
currently cfg input reads aid and other integral arguments
of DFfacts; yet to do: read in AO arguments.
@
text
@d4 2
a5 1
//#include "ao.h"
d8 1
d14 1
a14 1
DFAfact * DFAfact::read(FILE * inf, char * buf)
d18 1
a18 1
  if(!buf[0]) fgets(buf, TCA_BUF_SIZE, inf);
d25 6
a30 2
//        AO * ao = AO::stringToAO(cp, &cp, aidmap, pidmap, values);
        df = new DFAcall(aidno);
d35 3
a37 1
        df = new DFAassign(aidno);
d43 3
a45 1
        df = new DFAformal(argno, pidno);
d50 2
a51 1
        df = new DFAverify(DFAfact::fVT, aidno);
d56 2
a57 1
        df = new DFAverify(DFAfact::fVP, aidno);
d62 1
a62 1
            df = &DFAparallel::read(inf, buf);
d65 1
a65 1
            df = &DFAbranch::read(inf, buf);
d81 1
a81 1
void DFAfact::readlist(FILE * inf, char * buf, suco_llist<DFAfact *>& factlist)
d83 2
a84 2
  while(!feof(inf)){
    DFAfact * df = DFAfact::read(inf,buf);
d91 1
a91 1
DFAparallel& DFAparallel::read(FILE * inf, char * buf)
d95 1
a95 1
  if(!buf[0]) fgets(buf, TCA_BUF_SIZE, inf);
d104 2
a105 2
    fgets(buf, TCA_BUF_SIZE, inf);
    while(!feof(inf) && buf[0] == mPfx && buf[2] == mNext && buf[4] == mParallel){
d108 1
a108 1
      DFAfact::readlist(inf, buf, factlist);
d125 1
a125 1
DFAbranch& DFAbranch::read(FILE * inf, char * buf)
d129 1
a129 1
  if(!buf[0]) fgets(buf, TCA_BUF_SIZE, inf);
d137 1
a137 1
  fgets(buf, TCA_BUF_SIZE, inf);
d140 1
a140 1
    DFAfact::readlist(inf, buf, df->tfactlist);
d145 1
a145 1
  if(!buf[0]) fgets(buf, TCA_BUF_SIZE, inf);
d148 1
a148 1
    DFAfact::readlist(inf, buf, df->ffactlist);
d152 1
a152 1
  if(!buf[0]) fgets(buf, TCA_BUF_SIZE, inf);
d160 1
a160 1
CFGnode& CFGnode::read(FILE * inf, char * buf)
d164 1
a164 1
  if(!buf[0]) fgets(buf, TCA_BUF_SIZE, inf);
d176 1
a176 1
        fgets(buf, TCA_BUF_SIZE, inf);
d192 1
a192 1
      fgets(buf, TCA_BUF_SIZE, inf);
d198 4
a201 4
    fgets(buf, TCA_BUF_SIZE, inf);
    while(!feof(inf) && (buf[0] != mPfx || buf[2] != mEnd || buf[4] != mNode)){
      cfgn->factlist.Append(DFAfact::read(inf, buf));
      fgets(buf, TCA_BUF_SIZE, inf);
d209 1
a209 1
void CFGnode::readlist(FILE * inf, char * buf, CFGnode *& current, suco_llist<CFGnode *>& nodelist)
d211 1
a211 1
  if(!buf[0]) fgets(buf, TCA_BUF_SIZE, inf);
d213 2
a214 2
  while(!feof(inf)){ // && (buf[0] != mPfx || (buf[2] != mNext && buf[2] != mEnd))){
    if(!CFGnode::readentry(inf,buf,current,nodelist))
d216 1
a216 1
    fgets(buf, TCA_BUF_SIZE, inf);
d220 1
a220 1
bool CFGnode::readentry(FILE * inf, char * buf, CFGnode *& current, suco_llist<CFGnode *>& nodelist)
d222 1
a222 1
  if(!buf[0]) fgets(buf, TCA_BUF_SIZE, inf);
d232 1
a232 1
	    CFGnode& pred_node = CFGnode::read(inf, buf);
d236 1
a236 1
	    fgets(buf, TCA_BUF_SIZE, inf);
d250 1
a250 1
	    CFGnode::readlist(inf, buf, scurrent, snodelist);
d318 1
a318 1
	    CFGnode& pred_node = CFGnode::read(inf, buf);
d322 1
a322 1
	    fgets(buf, TCA_BUF_SIZE, inf);
d329 1
a329 1
	    CFGnode::readlist(inf, buf, current, snodelist);
d404 1
a404 1
	    CFGnode& node1 = CFGnode::read(inf, buf);
d409 1
a409 1
	    CFGnode& node2 = CFGnode::read(inf, buf);
d413 1
a413 1
	    CFGnode& node3 = CFGnode::read(inf, buf);
d416 1
a416 1
	    fgets(buf, TCA_BUF_SIZE, inf);
d436 1
a436 1
	    CFGnode::readlist(inf, buf, scurrent, snodelist);
d505 1
a505 1
	    CFGnode& pred_node = CFGnode::read(inf, buf);
d514 1
a514 1
	    fgets(buf, TCA_BUF_SIZE, inf);
d521 1
a521 1
	    CFGnode::readlist(inf, buf, current, nodelist);
d536 1
a536 1
	    CFGnode::readlist(inf, buf, current, nodelist);
d555 1
a555 1
	    CFGnode& pred_node = CFGnode::read(inf, buf);
d563 1
a563 1
	    fgets(buf, TCA_BUF_SIZE, inf);
d571 1
a571 1
	    CFGnode::readlist(inf, buf, scurrent, snodelist);
d636 1
a636 1
	    CFGnode& cfgn = CFGnode::read(inf, buf);
d727 1
a727 1
CFGfunction& CFGfunction::read(FILE * inf, char * buf, const char * filestem)
d729 1
a729 2
  CFGfunction * cfn = new CFGfunction(filestem);
  CFGnode * current = 0;
d731 2
a732 1
  if(!buf[0]) fgets(buf, TCA_BUF_SIZE, inf);
d737 5
a741 2
    cfn->pid = strtoul(cp, &cp, 10);
    cfn->aid = strtoul(cp, &cp, 10);
d744 4
d751 1
a751 1
    CFGnode& cfgn = CFGnode::read(inf, buf);
d758 1
a758 1
    fgets(buf, TCA_BUF_SIZE, inf);
d764 4
a767 4
  fgets(buf, TCA_BUF_SIZE, inf);
  while(!feof(inf) && (buf[0] != mPfx || buf[2] != mEnd || buf[4] != mFunction)){
    CFGnode::readentry(inf, buf, current, cfn->cfglist);
    fgets(buf, TCA_BUF_SIZE, inf);
d824 1
a824 1
void CFG::read(FILE * inf, char * buf, const char * filestem)
d826 1
a826 1
  if(!buf[0]) fgets(buf, TCA_BUF_SIZE, inf);
d828 1
a828 1
  while(!feof(inf)){
d830 1
a830 1
      CFGfunction& cfn = CFGfunction::read(inf, buf, filestem);
d836 1
a836 1
    fgets(buf, TCA_BUF_SIZE, inf);
d862 10
a871 1
  fprintf(outf, "%s--{ Fact %s (aid=%d) }--\n", ispaces, kindToString(kind), aid);
d878 8
a885 1
  fprintf(outf, "%s--{ Fact %s (aid=%d) }--\n", ispaces, kindToString(kind), aid);
d892 3
a894 1
  fprintf(outf, "%s--{ Fact %s (argno=%d, pid=%d) }--\n", ispaces, kindToString(kind), argno, pid);
d901 5
a905 1
  fprintf(outf, "%s--{ Fact %s (aid=%d) }--\n", ispaces, kindToString(kind), aid);
d1022 4
a1025 2
  fprintf(outf, " --{ Function (pid=%d, aid=%d, fstem=%s, entry=%d, exit=%d):\n",
			pid, aid, filestem, entrynode->getAid(), exitnode->getAid());
d1030 1
a1030 1
  fprintf(outf, " }-- end Function (pid=%d, aid=%d):\n", pid, aid);
a1173 10
#if defined(STANDALONE) /* { */
int main()
{
  char buf[TCA_BUF_SIZE] = {0};
  CFG c;
  c.read(stdin, buf, "test");
  c.debug_dump(stdout);
  return 0;
}
#endif /* } defined(STANDALONE) */
@


1.6
log
@Changed case label input function from strtoul to strtol.
@
text
@d2 1
d4 1
d21 4
a24 1
        df = new DFAfact(DFAfact::fCall);
d27 3
a29 1
        df = new DFAfact(DFAfact::fAssign);
d32 4
a35 1
        df = new DFAfact(DFAfact::fFormal);
d38 3
a40 1
        df = new DFAfact(DFAfact::fVT);
d43 3
a45 1
        df = new DFAfact(DFAfact::fVP);
d121 1
a121 1
     || strtoul(buf, 0, 10) != 2)
d133 1
a133 1
  fgets(buf, TCA_BUF_SIZE, inf);
d140 1
a140 1

d145 1
d715 1
a715 1
CFGfunction& CFGfunction::read(FILE * inf, char * buf)
d717 1
a717 1
  CFGfunction * cfn = new CFGfunction;
d805 1
a805 1
CFG& CFG::read(FILE * inf, char * buf)
a806 2
  CFG * cfg = new CFG;

d811 2
a812 2
          CFGfunction& cfn = CFGfunction::read(inf, buf);
          cfg->fnlist.Append(&cfn);
a818 2

  return *cfg;
d829 9
a837 2
static const char space_buffer[] = "                                                  ";
static const char * spaces = &space_buffer[sizeof(space_buffer)-1];
d839 1
a839 1
void DFAfact::debug_dump(FILE * outf, int indent)
d841 22
a862 1
  if(indent > sizeof(space_buffer) - 1) indent = sizeof(space_buffer) - 1;
d864 1
a864 1
  fprintf(outf, "%s--{ Fact %s (aid=%d) }--\n", spaces-indent, kindToString(kind), aid);
d869 2
a870 2
  if(indent > sizeof(space_buffer) - 1) indent = sizeof(space_buffer) - 1;
  fprintf(outf, "%s--{ Parallel (aid=%d):\n", spaces-indent, aid);
d874 1
a874 1
    fprintf(outf, "%s--: NEXT :\n", spaces-indent);
d879 1
a879 1
  fprintf(outf, "%s}-- end Parallel (aid=%d)\n", spaces-indent, aid);
d884 2
a885 2
  if(indent > sizeof(space_buffer) - 1) indent = sizeof(space_buffer) - 1;
  fprintf(outf, "%s--{ Branch (aid=%d):\n", spaces-indent, aid);
d887 1
a887 1
  fprintf(outf, "%s--: TRUE :\n", spaces-indent);
d891 1
a891 1
  fprintf(outf, "%s--: FALSE :\n", spaces-indent);
d895 1
a895 1
  fprintf(outf, "%s}-- end Branch (aid=%d)\n", spaces-indent, aid);
d900 2
a901 2
  if(indent > sizeof(space_buffer) - 1) indent = sizeof(space_buffer) - 1;
  fprintf(outf, "%s--{ Node (aid=%d)", spaces-indent, aid);
d975 1
a975 1
    fprintf(outf, "%s}-- end Node (aid=%d)\n", spaces-indent, aid);
d981 2
a982 2
  fprintf(outf, " --{ Function (pid=%d, aid=%d, entry=%d, exit=%d):\n",
			pid, aid, entrynode->getAid(), exitnode->getAid());
d1037 1
a1037 1
/**/fprintf(stderr, "CFGnode::addSuccessor: infrequent case encountered!\n");
d1059 1
a1059 1
/**/fprintf(stderr, "CFGnode::addSuccessor/addPredecessor: infrequent case encountered!\n");
d1131 1
d1135 2
a1136 1
  CFG& c = CFG::read(stdin, buf);
d1140 1
@


1.5
log
@First stable version.
Can read and successfully (as far as I can tell) build CFG
from sml output. However, facts are currently rudimentary
(exp arguments not yet handled), and there are some annoying-looking
empty parallel node issues that should probably be optimized?
@
text
@d671 1
a671 1
	    n->annot.u.integer = strtoul(cp, &cp, 10);
@


1.4
log
@Added while and for cases; todo: if and switch.
@
text
@d2 1
a199 2
	char * cp = &buf[6];
	unsigned int iarg1 = strtoul(cp, &cp, 10);
a201 1
	    unsigned int aid = iarg1;
d270 1
a287 1
	    unsigned int aid = iarg1;
d358 1
d374 1
a374 1
	    unsigned int aid = iarg1;
d457 1
d475 1
a475 1
	    unsigned int aid = iarg1;
d477 9
d487 4
d492 14
d507 15
a521 1
	    //-- piece together
d523 1
d525 1
a525 1
	    unsigned int aid = iarg1;
d527 8
d536 4
d541 9
d551 55
d607 1
d634 1
a634 1
	    n->annot.label = nc;
d668 15
d736 1
a736 3
  //-- join all return nodes to single exit node
  CFGnode * exitnode = new CFGnode;

d738 1
d743 1
a744 1
  exitnode->initPredsCount((current?1:0) + returnnodes.Length());
d746 19
a764 2
  //-- first, add current (if non null)
  if(current) current->addSuccessor(*exitnode);
d766 17
a782 3
  //-- now add return nodes
  suco_iterator<CFGnode *> rni(returnnodes);
    while(rni.Iterate()) rni.Current()->addSuccessor(*exitnode);
d784 2
a785 1
  cfn->cfglist.Append(exitnode);
d883 1
a883 1
      fprintf(outf, "(GOTO %s)", (annot.label)?(annot.label):"null!");
d910 1
a910 1
      fprintf(outf, "(CASE)");
d915 3
d942 2
a943 1
  fprintf(outf, " --{ Function (pid=%d, aid=%d):\n", pid, aid);
d1034 13
a1046 11
  if(!succs){
    succs = new CFGnode * [nsuccs = n-1];
    for(int i = 0; i < nsuccs; ++i) succs[i] = 0;
  } else if(nsuccs < n-1){
    CFGnode ** temp = succs;
    succs = new CFGnode * [n-1];
    int i;
    for(i = 0; i < nsuccs; ++i) succs[i] = temp[i];
    delete [] temp;
    nsuccs = n-1;
    for(; i < nsuccs; ++i) succs[i] = 0;
d1052 25
a1076 11
  if(!preds){
    preds = new CFGnode * [npreds = n-1];
    for(int i = 0; i < npreds; ++i) preds[i] = 0;
  } else if(npreds < n-1){
    CFGnode ** temp = preds;
    preds = new CFGnode * [n-1];
    int i;
    for(i = 0; i < npreds; ++i) preds[i] = temp[i];
    delete [] temp;
    npreds = n-1;
    for(; i < npreds; ++i) preds[i] = 0;
d1078 8
@


1.3
log
@Version seems correct, but not complete (loop/structures: only
While case written; now will try to abstract some of that code
into functions for reuse).
@
text
@d41 1
a41 1
//            fprintf(stderr, "DFAfact::read: bad start marker on line %s", buf);
d46 1
a46 1
//        fprintf(stderr, "DFAfact::read: bad marker on line %s", buf);
a237 2
	      CFGnode * snhead = snodelist.Head();

d287 1
d290 1
d292 80
a371 3
	    //-- dowhile next marker / verify
	    //-- statements, until dowhile end marker
	    //-- piece together
d373 1
d377 4
d382 3
d386 3
d390 16
d407 65
a471 1
	    //-- piece together
d473 1
d553 1
a553 1
       	}
@


1.2
log
@Semi-working version -- only while loop handled.
Appears to still be buggy, but at least stable enough to
check in.
@
text
@d215 6
d224 1
a224 1
	    CFGnode * scurrent = 0;
a232 1
	      if(current) current->addSuccessor(pred_node);
a233 1
	      pred_node.initSuccsCount(2);
a234 1
	      current = &pred_node;
d253 1
a253 5
	      //-- attach current to pred_node
	      if(current) current->addSuccessor(pred_node);
	      current = &pred_node;

	      //-- attach statement exits / continue nodes to pred_node
d256 1
a256 1
	        continuenodes.Append(scurrent);
d284 2
d287 1
a287 3
	    //-- piece together
	    nodelist.Append(&pred_node);
	    nodelist.Attach(snodelist);
d360 5
d367 5
d374 5
a386 1
//        fprintf(stderr, "CFGnode::readentry: bad marker on line %s", buf);
d388 1
a388 1
      } break;
d433 20
a489 1
  fprintf(outf, "%s--{ Fact %s (aid=%d):\n", spaces-indent, kindToString(kind), aid);
d491 1
a491 1
  fprintf(outf, "%s--} Fact %s (aid=%d)\n", spaces-indent, kindToString(kind), aid);
d506 1
a506 1
  fprintf(outf, "%s--} Parallel (aid=%d)\n", spaces-indent, aid);
d522 1
a522 1
  fprintf(outf, "%s--} Branch (aid=%d)\n", spaces-indent, aid);
a584 1
  fprintf(outf, ":\n");
d586 14
a599 3
  suco_iterator<DFAfact *> fli(factlist);
  while(fli.Iterate()){
    fli.Current()->debug_dump(outf, indent+1);
a600 2

  fprintf(outf, "%s--} Node (aid=%d)\n", spaces-indent, aid);
d610 1
a610 1
  fprintf(outf, " --} Function (pid=%d, aid=%d):\n", pid, aid);
d620 1
a620 1
  fprintf(outf, "--} CFG (%d functions)\n", fnlist.Length());
d677 1
a677 1
        n.preds[i] = &n;
d687 1
a687 1
      n.preds[i] = &n;
@


1.1
log
@Initial revision
@
text
@d6 1
d13 2
a55 1
  fgets(buf, TCA_BUF_SIZE, inf);
d60 1
a60 1
    fgets(buf, TCA_BUF_SIZE, inf);
d64 1
a64 1
DFAparallel& DFAparallel::read(FILE * inf, char * str)
a66 1
  char buf[TCA_BUF_SIZE];
d68 1
a68 2
  if(str) strcpy(buf, str);
  else fgets(buf, TCA_BUF_SIZE, inf);
d74 19
a94 11
  //-- process factlists
  fgets(buf, TCA_BUF_SIZE, inf);
  while(buf[0] == mPfx && buf[2] == mNext && buf[4] == mParallel){
    suco_llist<DFAfact *> factlist;
    DFAfact::readlist(inf, buf, factlist);
    df->factlists.Append(&factlist);
  }
  // (assert end marker)
  if(buf[0] != mPfx || buf[2] != mEnd || buf[4] != mParallel)
    fprintf(stderr, "DFAparallel::read: expecting end marker on line %s", buf);

d98 1
a98 1
DFAbranch& DFAbranch::read(FILE * inf, char * str)
a100 1
  char buf[TCA_BUF_SIZE];
d102 1
a102 2
  if(str) strcpy(buf, str);
  else fgets(buf, TCA_BUF_SIZE, inf);
d111 2
a112 1
  if(buf[0] == mPfx && buf[2] == mNext && buf[4] == mBranch)
d114 1
d119 2
a120 1
  if(buf[0] == mPfx && buf[2] == mNext && buf[4] == mBranch)
d122 1
d132 457
d591 15
a685 155
CFGnode& CFGnode::read(FILE * inf, char * str)
{
  CFGnode * cfgn = new CFGnode;
  char buf[TCA_BUF_SIZE];

  if(str) strcpy(buf, str);
  else fgets(buf, TCA_BUF_SIZE, inf);

  //-- process node start header: read aid and numlabels
  if(buf[0] == mPfx && buf[2] == mStart && buf[4] == mNode){
    char * cp = &buf[6];
    cfgn->aid = strtoul(cp, &cp, 10);
    cfgn->nlabels = strtoul(cp, &cp, 10);
  } else fprintf(stderr, "CFGnode::read: bad start marker on line %s", buf);

  //-- process labels
  if(cfgn->nlabels){
    cfgn->labels = new char * [cfgn->nlabels];
    for(int i = 0; i < cfgn->nlabels; ++i){
      fgets(buf, TCA_BUF_SIZE, inf);
      char * cp = &buf[4];
      if(buf[0] == mPfx && buf[2] == mLabel
         && cfgn->aid == strtoul(cp, &cp, 10)){ // asserts, and advances cp!
        while(isspace(*cp)) ++cp;
        int s = strlen(cp) - 1;
        while(isspace(cp[s])) --s;
        cp[++s] = 0;
        cfgn->labels[i] = new char[s];
        strcpy(cfgn->labels[i], cp);
/**/fprintf(stderr, "DIAG: read label <%s>\n", cfgn->labels[i]);
      } else fprintf(stderr, "CFGnode::read: bad label marker on line %s", buf);
    }
  }

  //-- process node next (assert)
  {
    fgets(buf, TCA_BUF_SIZE, inf);
    if(buf[0] != mPfx || buf[2] != mNext || buf[4] != mNode)
      fprintf(stderr, "CFGnode::read: next assertion failed on line %s", buf);
  }

  //-- process facts, until node end
  fgets(buf, TCA_BUF_SIZE, inf);
  while(!feof(inf)){
    cfgn->factlist.Append(DFAfact::read(inf, buf));
    fgets(buf, TCA_BUF_SIZE, inf);
  }


  return *cfgn;
}

//----------------------------------

CFGfunction& CFGfunction::read(FILE * inf, char * str)
{
  CFGfunction * cfn = new CFGfunction;
  CFGnode * current = 0;
  char buf[TCA_BUF_SIZE];

  if(str) strcpy(buf, str);
  else fgets(buf, TCA_BUF_SIZE, inf);

  //-- process function start header: read pid/aid
  if(buf[0] == mPfx && buf[2] == mStart && buf[4] == mFunction){
    char * cp = &buf[6];
    cfn->pid = strtoul(cp, &cp, 10);
    cfn->aid = strtoul(cp, &cp, 10);
  } else fprintf(stderr, "CFGfunction::read: bad start marker on line %s", buf);

  //-- process formals
  {
    fgets(buf, TCA_BUF_SIZE, inf);
    CFGnode& cfgn = CFGnode::read(inf, buf);
    cfn->cfglist.Insert(&cfgn);
    current = &cfgn;
  }

  //-- process function next (assert)
  {
    fgets(buf, TCA_BUF_SIZE, inf);
    if(buf[0] != mPfx || buf[2] != mNext || buf[4] != mFunction)
      fprintf(stderr, "CFGfunction::read: next assertion failed on line %s", buf);
  }

  //-- process body, until function end
  fgets(buf, TCA_BUF_SIZE, inf);
  while(!feof(inf)){
    if(buf[0] == mPfx){
      switch(buf[2]){
        case mStart: {
	    char * cp = &buf[6];
	    int iarg1 = strtoul(cp, &cp, 10);
            switch(buf[4]){
              case mWhile: {
		int aid = iarg1;
		//-- predicate node
		//-- while next marker / verify
		//-- statements, until while end marker
		//-- piece together
              } break;
              case mDoWhile: {
		int aid = iarg1;
		//-- predicate node
		//-- dowhile next marker / verify
		//-- statements, until dowhile end marker
		//-- piece together
              } break;
              case mFor: {
		int aid = iarg1;
		//-- node1
		//-- node2
		//-- node3
		//-- for next marker / verify
		//-- statements, until for end marker
		//-- piece together
              } break;
              case mIf: {
		int aid = iarg1;
		//-- predicate node
		//-- if next marker / verify
		//-- true statements, until if next marker
		//-- false statements, until if end marker
		//-- piece together
              } break;
              case mSwitch: {
		int aid = iarg1;
		//-- predicate node
		//-- predicate next marker / verify
		//-- statements, until switch end marker
		//-- piece together
              } break;
              case mNode: {
		CFGnode& cfgn = CFGnode::read(inf, buf);
		current->addSuccessor(cfgn);
		current = &cfgn;
              } break;
              default: {
		fprintf(stderr, "CFGfunction::read: bad start marker on line %s", buf);
              } break;
            }
          } break;
        case mJump: {
          } break;
        default: {
            fprintf(stderr, "CFGfunction::read: bad marker on line %s", buf);
          } break;
      }
    } else fprintf(stderr, "CFGfunction::read: bad prefix on line %s", buf);
    fgets(buf, TCA_BUF_SIZE, inf);
  }

  return *cfn;
}

d687 1
a687 23

CFG& CFG::read(FILE * inf, char * str)
{
  CFG * cfg = new CFG;
  char buf[TCA_BUF_SIZE];

  if(str) strcpy(buf, str);
  else fgets(buf, TCA_BUF_SIZE, inf);

  while(!feof(inf)){
    if(buf[2] == mStart && buf[4] == mFunction){
          CFGfunction& cfn = CFGfunction::read(inf, buf);
          cfg->fnlist.Append(&cfn);
    //-- todo: add other cases (for external decls) here
    } else {
      fprintf(stderr, "CFG::read error on line %s", buf);
    }
    fgets(buf, TCA_BUF_SIZE, inf);
  }

  return *cfg;
}

d692 3
a694 1
  CFG c = CFG::read(stdin);
@
