head	1.50;
access;
symbols;
locks
	suan:1.50; strict;
comment	@// @;


1.50
date	2004.06.29.20.02.32;	author suan;	state Exp;
branches;
next	1.49;

1.49
date	2004.06.23.17.16.49;	author suan;	state Exp;
branches;
next	1.48;

1.48
date	2004.06.23.14.57.00;	author suan;	state Exp;
branches;
next	1.47;

1.47
date	2004.05.25.14.02.29;	author suan;	state Exp;
branches;
next	1.46;

1.46
date	2004.05.12.18.53.04;	author suan;	state Exp;
branches;
next	1.45;

1.45
date	2004.05.11.15.01.15;	author suan;	state Exp;
branches;
next	1.44;

1.44
date	2004.05.07.23.30.14;	author suan;	state Exp;
branches;
next	1.43;

1.43
date	2004.05.07.19.52.39;	author suan;	state Exp;
branches;
next	1.42;

1.42
date	2004.05.07.18.54.14;	author suan;	state Exp;
branches;
next	1.41;

1.41
date	2004.05.06.23.42.03;	author suan;	state Exp;
branches;
next	1.40;

1.40
date	2004.05.02.18.50.18;	author suan;	state Exp;
branches;
next	1.39;

1.39
date	2004.04.29.18.44.41;	author suan;	state Exp;
branches;
next	1.38;

1.38
date	2004.02.18.16.06.52;	author suan;	state Exp;
branches;
next	1.37;

1.37
date	2004.02.13.22.23.01;	author suan;	state Exp;
branches;
next	1.36;

1.36
date	2003.11.14.22.47.57;	author suan;	state Exp;
branches;
next	1.35;

1.35
date	2003.11.12.00.10.31;	author suan;	state Exp;
branches;
next	1.34;

1.34
date	2003.11.07.20.39.42;	author suan;	state Exp;
branches;
next	1.33;

1.33
date	2003.11.06.20.56.46;	author suan;	state Exp;
branches;
next	1.32;

1.32
date	2003.11.06.20.06.18;	author suan;	state Exp;
branches;
next	1.31;

1.31
date	2003.11.05.21.26.08;	author suan;	state Exp;
branches;
next	1.30;

1.30
date	2003.06.18.20.08.46;	author suan;	state Exp;
branches;
next	1.29;

1.29
date	2003.06.11.23.05.24;	author suan;	state Exp;
branches;
next	1.28;

1.28
date	2003.03.14.23.48.59;	author suan;	state Exp;
branches;
next	1.27;

1.27
date	2003.02.25.20.04.46;	author suan;	state Exp;
branches;
next	1.26;

1.26
date	2003.02.25.16.41.45;	author suan;	state Exp;
branches;
next	1.25;

1.25
date	2003.02.21.17.40.11;	author suan;	state Exp;
branches;
next	1.24;

1.24
date	2002.11.14.16.47.36;	author suan;	state Exp;
branches;
next	1.23;

1.23
date	2002.11.13.01.42.39;	author suan;	state Exp;
branches;
next	1.22;

1.22
date	2002.11.07.00.40.47;	author suan;	state Exp;
branches;
next	1.21;

1.21
date	2002.10.30.20.47.39;	author suan;	state Exp;
branches;
next	1.20;

1.20
date	2002.10.23.20.26.57;	author suan;	state Exp;
branches;
next	1.19;

1.19
date	2002.10.17.15.46.02;	author suan;	state Exp;
branches;
next	1.18;

1.18
date	2002.10.16.15.57.27;	author suan;	state Exp;
branches;
next	1.17;

1.17
date	2002.09.18.15.35.20;	author suan;	state Exp;
branches;
next	1.16;

1.16
date	2002.08.19.14.22.25;	author suan;	state Exp;
branches;
next	1.15;

1.15
date	2002.08.15.23.39.23;	author suan;	state Exp;
branches;
next	1.14;

1.14
date	2002.08.15.21.16.25;	author suan;	state Exp;
branches;
next	1.13;

1.13
date	2002.08.15.16.50.54;	author suan;	state Exp;
branches;
next	1.12;

1.12
date	2002.08.14.23.03.01;	author suan;	state Exp;
branches;
next	1.11;

1.11
date	2002.08.14.19.31.03;	author suan;	state Exp;
branches;
next	1.10;

1.10
date	2002.08.12.21.59.52;	author suan;	state Exp;
branches;
next	1.9;

1.9
date	2002.08.10.21.26.24;	author suan;	state Exp;
branches;
next	1.8;

1.8
date	2002.07.30.19.48.50;	author suan;	state Exp;
branches;
next	1.7;

1.7
date	2002.07.29.14.53.42;	author suan;	state Exp;
branches;
next	1.6;

1.6
date	2002.07.25.15.48.58;	author suan;	state Exp;
branches;
next	1.5;

1.5
date	2002.05.26.05.43.21;	author suan;	state Exp;
branches;
next	1.4;

1.4
date	2002.05.25.18.58.05;	author suan;	state Exp;
branches;
next	1.3;

1.3
date	2002.04.19.16.45.01;	author suan;	state Exp;
branches;
next	1.2;

1.2
date	2002.04.18.17.06.19;	author suan;	state Exp;
branches;
next	1.1;

1.1
date	2002.04.18.15.55.32;	author suan;	state Exp;
branches;
next	;


desc
@ECR (Equivalent-Class Representative) for performing pointer
analysis.
@


1.50
log
@ADDED evaluation of each library function call to determine
if its target (where relevant) is exposed -- this will mainly
be used in -vulnw mode to remove instrumentation when a
function's target is exposed (needed to avoid false positive).
Eventually, it may also be used in -ptr/ptrw mode to remove
instrumentation when a library function's target is not
exposed -- though currently this never happens because of
context-insensitive analysis and overly-conservative models.
SUPPLEMENTAL CHANGES to achieve the above:
 1. Created ExposedStatus class in ao.cpp/ao.h (was previously
    an enum in AO class)
 2. Changed PExprcall::isDirectCall() to return the ID of the
    direct call, rather than just a bool.
 3. Exported "flag_readwrite" to become a global -- it's about
    time (I'd been misguidedly trying to avoid this for far
    too long, creating a bigger mess instead)
@
text
@#include <stdio.h>

#include "diag.h"
#include "ecr.h"
#include "flags.h"

//------------------------------------------------------
//------------------------------------------------------

int ECRargRet::max_nargs = 0;

ECRargRet& ECRargRet::followFwdPtr()
{
  ECRargRet * tail = this;
  while(tail->fwdptr)
    tail = tail->fwdptr;
  if(tail != this)
    this->fwdptr = tail; //- update fwdptr
  return *tail;
}

void ECRargRet::findMaxNargs(AO& ao)
{
  if(ao.getKind() == AO::aoArg
     && max_nargs < ((AOArg&) ao).argNo())
    max_nargs = ((AOArg&) ao).argNo();
}

ECR& ECRargRet::getMainParent()
{
  main_parent = &main_parent->followECR();
  return *main_parent;
}

ECR& ECRargRet::getRet()
{
  if(!ret) ret = &ECR::new_ECR();
  else ret = &ret->followECR();
  return *ret;
}

ECR * ECRargRet::get_arg(int argno) const
{
  if(argno > this->argsize) return 0;
  else return this->args[argno-1];
}

ECR& ECRargRet::getArg(int argno)
{
  ECR *& ar = getArgPtr(argno);

  if(!ar) ar = &ECR::new_ECR();
  else ar = &ar->followECR();
  return *ar;
}

ECR *& ECRargRet::getArgPtr(int argno) // argno is 1-based!
{
  if(argno > this->argsize){ // reallocate
    ECR ** oldargs = this->args;
    int oldargsize = this->argsize;

    if(this->argsize < max_nargs)
      this->argsize = this->nargs;
    if(this->argsize < argno){
      this->argsize = argno * 2;
      if(this->argsize < 10) this->argsize = 10; // minimum size
    }

    this->args = new ECR*[this->argsize];

    int i = 0;
    //- copy old args
    for(; i < oldargsize; ++i)
      this->args[i] = oldargs[i];
    //- initialize new entries
    for(; i < this->argsize; ++i)
      this->args[i] = 0;

    //- free oldargs
    if(oldargs){
      delete [] oldargs;
    }
  }
  if(this->nargs < argno) // adjust nargs
    this->nargs = argno;
  return this->args[argno-1]; // adjust for 1-based argno!
}

void ECRargRet::addArg(int argno, ECR& ecr) //- assume ecr normalized
{
  ECR *& ar = getArgPtr(argno);
  //- absorb ecr
  if(ar){
    ar->absorb(ecr);
  } else {
    ar = &ecr;
  }
}

void ECRargRet::addRet(ECR& ecr) //- assume ecr normalized
{
  if(ret){
    ret->absorb(ecr);
  } else {
    ret = &ecr;
  }
}

// - 2. forall i: tmp[i]       <-- this->arg[i]
//                this->arg[i] <-- null
// - 3. forall i: targ[i] absorb tmp[i]
//                if this->arg[i] = null
//                then this->arg[i] <-- targ[i]
//                     targ[i] = null
//                else go back to step 2
// Note: use recursion for tmp[]

//- absorb args and ret into this; assume this has followed fwdptr
//  again, use recursion to store temps
void ECRargRet::absorbArgRet(int argno, ECR ** args, ECR * ret)
{
  if(argno){ //- doing arg
    //- remember ECRs
    ECR * larg = this->getArgPtr(argno); //-- do this once to instantiate args, if not already allocated
    this->args[argno-1] = 0;

    //- recurse
    absorbArgRet(argno-1, args, ret);

    //- larg absorb rarg (if rarg non null)
    ECR * rarg = args?args[argno-1]:0;	//-- NOT SAFE: argno may go OOB?
    if(larg && rarg) larg->followECR().absorb(rarg->followECR());
    else if(!larg) larg = rarg;

    if(larg){
      while(this->args[argno-1]){
        ECR * tmp = this->args[argno-1];
        this->args[argno-1] = 0;
        larg->followECR().absorb(tmp->followECR());
      }
      this->args[argno-1] = &larg->followECR();
    } // else do nothing

  } else { //- doing ret; also terminates recursion

    if(ret){
      while(this->ret){
        ECR * tmp = this->ret;
        this->ret = 0;
        ret->followECR().absorb(tmp->followECR());
      }
      this->ret = &ret->followECR();
    } //- else do nothing

  }
}

void ECRargRet::absorb(ECRargRet * ar) //- ar will be cleared
{
  // - 1. this  <-- larger nargs
  //      ar    <-- null
  //      targs <-- smaller nargs
  //      ar --[fwdptr]--> this
  ECR ** targs;
  int tnargs;
  if(ar->nargs > this->nargs){
    targs = this->args;
    tnargs = this->nargs;
    this->args = ar->args;
    this->argsize = ar->argsize;
    this->nargs = ar->nargs;
    ar->args = 0;
    ar->argsize = 0;
    ar->nargs = 0;
    ar->fwdptr = this;
  } else {
    targs = ar->args;
    tnargs = ar->nargs;
    ar->args = 0;
    ar->argsize = 0;
    ar->nargs = 0;
    ar->fwdptr = this;
  }
  ECR * tret = ar->ret;
  ar->ret = 0;

  // - 2. forall i: tmp[i]       <-- this->arg[i]
  //                this->arg[i] <-- null
  // - 3. forall i: targ[i] absorb tmp[i]
  //                if this->arg[i] = null
  //                then this->arg[i] <-- targ[i]
  //                     targ[i] = null
  //                else go back to step 2
  // Note: use recursion for tmp[]

  absorbArgRet(tnargs, targs, tret);

  delete [] targs;
}

//------------------------------------------------------

int ECR::traverseCounter = 0;
suco_llist<ECR *> ECR::ecr_pool;

ECR& ECR::new_ECR()
{
  ECR * ecr = new ECR;
  ECR::ecr_pool.Insert(ecr);
  return *ecr;
}

ECR& ECR::followECR()
{
  ECR * tail = this;
  while(tail->fwdptr)
    tail = tail->fwdptr;
  if(tail != this)
    this->fwdptr = tail; //- update fwdptr
  return *tail;
}

void ECR::linkAO(AO& ao)
{
  if(ao.ecr != this){
    if(ao.ecr){
      //- unlink ao.ecr
      ao.ecr->aoset.Remove(&ao);

      //- optional: call garbage-collector here? to clean up ao.ecr? 
      //            just beware that ecr may still be referred to by
      //            other ECRs, as well as edges and other AO
      //            (aoset and edge lists will have been carried
      //            forward to the tail?)
    }
    ao.ecr = this;
    this->aoset.Insert(&ao);
  }
}

void ECR::garbageCollect()
{
  int numecrs = 0;
  int deleted = 0;
  suco_iterator<ECR *> ei(ECR::ecr_pool);
  while(ei.Iterate()){
    numecrs++;
    if(ei.Current()->traverseTag != ECR::traverseCounter){
      ECR * tmp = ei.Current();
      ei.DeleteCurrent();
      deleted++;
//--debug: assert all fields are empty
      if(   (tmp->ptsTo)
	 || (!tmp->ptsFrom.IsEmpty())
	 || (!tmp->inclFrom.IsEmpty())
	 || (!tmp->inclTo.IsEmpty())){
        fprintf(stderr, "WARNING(ECR::garbageCollect): ecr has some non-empty fields\n");
      }
//--end assert
      delete tmp;
    }
  }
  fprintf(stderr, "ECR::garbageCollection: deleted %d out of %d\n", deleted, numecrs);
}

void ECR::finalizeECRset(suco_set<ECR *>& eset)
{
  suco_iterator<ECR *> pfi(eset);
  suco_set<ECR *> newset;
  while(pfi.Iterate()){
    ECR * curr = pfi.Current();
    ECR * tail = &curr->followECR();
    if(curr != tail){
      pfi.DeleteCurrent();
      newset.Insert(tail);
    }
    tail->finalizeECR();
  }
  eset.UnionConsume(newset);
}

void ECRargRet::fixECRs()
{
  //- main parent: probably useless
  this->main_parent = &this->main_parent->followECR();
  this->main_parent->finalizeECR();
  //- ret
  if(this->ret){
    this->ret = &this->ret->followECR();
    this->ret->finalizeECR();
  }
  //- args
  if(this->args && this->argsize){
    for(int i = 0; i < this->argsize; ++i){
      if(this->args[i]){
        this->args[i] = &this->args[i]->followECR();
        this->args[i]->finalizeECR();
      }
    }
  }
}

void ECR::finalizeECR()
{
  if(this->fwdptr)
    fprintf(stderr, "ERROR(finalizeECR): ecr non-null fwdptr!\n");

  if(this->traverseTag == ECR::traverseCounter) // visited; return
    return;
  this->traverseTag = traverseCounter; // mark this ECR as "visited"

  //- fix all ECR pointers:
  // - ptsFrom
  ECR::finalizeECRset(this->ptsFrom);
  // - ptsTo
  if(this->ptsTo){
    this->ptsTo = &this->ptsTo->followECR();
    this->ptsTo->finalizeECR();
  }
  // - inclFrom
  ECR::finalizeECRset(this->inclFrom);
  // - inclTo
  ECR::finalizeECRset(this->inclTo);
  // - alias_ecrset (just clear)
  if(this->alias_ecrset){
    fprintf(stderr, "WARNING(finalizeECR): alias_ecrset is non-null\n");
  }
  // - argret
  if(this->argRet()){
    this->argRet()->fixECRs();
  }
}

void ECR::fixECR(AO& ao) //- if no ECR, creates a new one
{
  if(!ao.ecr)
    new_ECR().linkAO(ao);
  else {
    //- follow forward pointer
    ECR& tail = ao.ecr->followECR();
    if(ao.ecr != &tail)
      tail.linkAO(ao);
  }
  ao.ecr->finalizeECR();
}

ECR& ECR::getECR(AO& ao) //- if no ECR, creates a new one
{
  if(!ao.ecr)
    new_ECR().linkAO(ao);
  else {
    //- follow forward pointer
    ECR& tail = ao.ecr->followECR();
    if(ao.ecr != &tail)
      tail.linkAO(ao);
  }
  return *ao.ecr;
}

void ECR::absorb(ECR& ecr) //- assume both this and ecr are normalized
{
  if(this != &ecr){ //- different ecrs
    //-- absorb ecr into this
    // - transfer aoset
    this->aoset.UnionConsume(ecr.aoset); // should be distinct sets anyway
    // - set fwd pointer
    ecr.fwdptr = this;
    // - transfer ptsFrom
    this->ptsFrom.UnionConsume(ecr.ptsFrom);
    // - transfer inclFrom,inclTo
    this->inclFrom.UnionConsume(ecr.inclFrom);
    this->inclTo.UnionConsume(ecr.inclTo);
    // - transfer ptsTo - triggers further absorbs, so be careful of non-termination
    if(ecr.ptsTo){
      //- first, dismantle ptsTo connection
      ECR &tgtecr = ecr.getPointsTo();
      tgtecr.ptsFrom.Remove(&ecr);
      ecr.ptsTo = 0;
      //- now, we're safe to call the pointsTo function
      this->pointsTo(tgtecr);
    }
    //- unify arg and returns
    if(ecr.argRet()){
      if(ecr.argRet() == this->followECR().argRet()){
        ecr.detachArgRet();
      } else if(this->followECR().argRet()){
        ECRargRet * eargret = ecr.detachArgRet(); //- ecr.argret already followed fwdptr in outer if stmt
        this->followECR().argRet()->absorb(eargret); //- eargret is cleared by absorb
      } else {
        this->followECR().argret = ecr.argRet();
        ecr.argret = 0;
      }
    } // else - nothing to absorb
  }
}

void ECR::unifyECRs(AO& ao1, AO& ao2)
{
  if(!ao1.ecr)
    getECR(ao2).linkAO(ao1);
  else if(!ao2.ecr)
    getECR(ao1).linkAO(ao2);
  else //- both ecrs allocated
    getECR(ao1).absorb(getECR(ao2));
}

ECRargRet * ECR::argRet() //- follows fwdptr
{
  if(this->argret)
    this->argret = &argret->followFwdPtr();
  return this->argret;
}

ECRargRet& ECR::getArgRet()
{
  if(!argret){
    argret = new ECRargRet(*this);
  }
  return *argRet();
}

ECRargRet * ECR::detachArgRet() //- does not follow fwdptr
{
  ECRargRet * ret = this->argRet();
  if(ret)
    this->argret = 0;
  return ret;
}

ECR& ECR::getPointsTo()
{
  if(!this->ptsTo){
    this->ptsTo = &new_ECR();
  } else {
    //- follow forward pointer
    this->ptsTo = &this->ptsTo->followECR();
  }
  return *this->ptsTo;
}

void ECR::pointsTo(ECR& ecr) // assume this and ecr normalized
{
  if(flag_collapse_ptsto_cycle && (this != &ecr)){
    suco_set<ECR *> cyEcrs;
    ECR::traverseCounter++;
    if(ecr.findPtsToCycle(*this, cyEcrs)){
      //- cycle found: collapse
      TCstats::cde_pt_num_collapses++;
      TCstats::cde_pt_nodes_collapsed += cyEcrs.Length();

/**/if(this->ptsTo && (&this->ptsTo->followECR() == &ecr)) fprintf(stderr, "already points-to, still collapsing! (%d)\n", cyEcrs.Length());

      suco_iterator<ECR *> cei(cyEcrs);
      while(cei.Iterate())
        ecr.followECR().absorb(cei.Current()->followECR());

      return;	//- break out
    }
  }
  if(!this->ptsTo){
    this->ptsTo = &ecr;
    ecr.ptsFrom.Insert(this);
  } else {
    ecr.absorb(this->getPointsTo());
  }
}

//- simulate larg --ASSIGN--> rarg
//       and lret <--ASSIGN-- rret (when argno = 0)
//  trick: use recursion to remember ECRs to simulate
void ECR::simulateAssign(int argno, ECRargRet& largret, ECRargRet& rargret) //- assume largret, rargret have followed fwdptr
{
  if(argno){ //- doing arg
    //- remember ECRs
    ECR& larg = largret.getArg(argno);
    ECR& rarg = rargret.getArg(argno);

    //- recurse
    simulateAssign(argno-1, largret, rargret);

    //- do arg : simulate larg --ASSIGN--> rarg
    rarg.followECR().getPointsTo().includesTo(larg.followECR().getPointsTo());

  } else { //- doing ret; also terminates recursion

    //- do ret : simulate lret <--ASSIGN-- rret
    largret.getRet().getPointsTo().includesTo(rargret.getRet().getPointsTo());

  }
}

void ECR::processArgRetFlow(ECRargRet& largret, ECRargRet& rargret) //- assume largret, rargret have followed fwdptr
{
  int minLRnargs = (largret.nargs < rargret.nargs) ? largret.nargs : rargret.nargs;
  int maxLRnargs = (largret.nargs > rargret.nargs) ? largret.nargs : rargret.nargs;
  simulateAssign(maxLRnargs, largret, rargret);

  if(minLRnargs != maxLRnargs){
//TODO: propagate
    fprintf(stderr, "WARNING! Different LR nargs (%d,%d); for robustness, run with -fixnargs\n", minLRnargs, maxLRnargs);

  }
}

// assume this and ecr normalized
//- NOTE: since the current analysis has out-degree = 1 for
//-       points-to edges, we don't need this recursive
//-       traversal.  However, I'll leave this implementation
//-       to accommodate possible future extensions to higher
//-       out degrees.
bool ECR::findPtsToCycle(ECR& dest, suco_llist<ECR *>& cyEcrs)
{
  if(this->traverseTag == ECR::traverseCounter) // visited node
    return cyEcrs.Contains(this); //- return true if previously-identified cycle
  this->traverseTag = ECR::traverseCounter; // mark this ECR as "visited"

  if(this == &dest){ // cycle detected
    cyEcrs.Insert(this);
    return true;
  }

  //- follow points-to target
  if(this->ptsTo &&
	this->ptsTo->followECR().findPtsToCycle(dest, cyEcrs)){
    //- part of cycle - collect results
    cyEcrs.Insert(this);
    return true;
  } else return false;
}

// assume this and ecr normalized
bool ECR::findInclToCycle(ECR& dest, suco_llist<ECR *>& cyEcrs)
{
  if(this->traverseTag == ECR::traverseCounter) // visited node
    return cyEcrs.Contains(this); //- return true if previously-identified cycle
  this->traverseTag = ECR::traverseCounter; // mark this ECR as "visited"

  if(this == &dest){ // cycle detected
    cyEcrs.Insert(this);
    return true;
  }

  //- traverse incl-to targets depth-first
  bool ret = false;
  suco_iterator<ECR *> ei(this->inclTo);
  while(ei.Iterate())
    ret |= ei.Current()->followECR().findInclToCycle(dest, cyEcrs);

  if(ret){ //- part of cycle - collect results
    cyEcrs.Insert(this);
    return true;
  } else return false;
}
    
// assume this and ecr normalized
// return true if new edge added
void ECR::includesTo(ECR& ecr)
{
  //- first, detect cycles introduced by this new edge
  if(flag_collapse_inclto_cycle && this != &ecr){
    suco_set<ECR *> cyEcrs;
    ECR::traverseCounter++;
    if(ecr.findInclToCycle(*this, cyEcrs)){
      //- cycle found: collapse: absorb all into ecr
      TCstats::cde_incl_num_collapses++;
      TCstats::cde_incl_nodes_collapsed += cyEcrs.Length();

      suco_iterator<ECR *> cei(cyEcrs);
      while(cei.Iterate())
        ecr.followECR().absorb(cei.Current()->followECR());

      //- delete redundant inclTo/inclFrom entries
      {
        ECR& ecrn = ecr.followECR();
        suco_iterator<ECR *> tei(ecrn.inclTo);
        while(tei.Iterate())
          if(&tei.Current()->followECR() == &ecrn)
            tei.DeleteCurrent();
        suco_iterator<ECR *> fei(ecrn.inclFrom);
        while(fei.Iterate())
          if(&fei.Current()->followECR() == &ecrn)
            fei.DeleteCurrent();
      }

//TODO: assert that &this->followECR() == ecr.followECR()
      return;	//- must break out, so "this and ecr are normalized"
    }		//  invariant holds for following if test
  }

  if(this != &ecr && // don't include self
     this->inclTo.Insert(&ecr)){ // true means new incl target
    ecr.inclFrom.Insert(this);
    //- unify points-to targets
    if(this->ptsTo)
      ecr.pointsTo(this->getPointsTo());
    else
      this->pointsTo(ecr.getPointsTo());

    //- do arg-ret assignment simulations
    // a. if lhs has argret, but not rhs, set rhs.argret to point to lhs.argret
    //    AND follow incl forward to link all reachable w/no argret
    //        IF reaches another argret, then must perform "virtual assignment" (step d. below)
    // b. if rhs has argret but not lhs, DON'T NEED to go backwards (enough to do in one
    //    direction) --> do nothing
    // c. if both have no argret, do nothing: defer to steps a. and b. later if needed
    //    (optimizing for common case?)
    // d. if both have argret, perform the effect of the assignments
    //      lhs.arg  -ASSIGN-> rhs*.arg; i.e. rhs*.ret.pointsTo -includesTo-> lhs.arg.pointsTo
    //      lhs.ret <-ASSIGN-  rhs*.ret; i.e. lhs.ret.pointsTo  -includesTo-> rhs*.ret.pointsTo
    //    BUT:
    //    if lhs.nargs > rhs.nargs, must search forward, to propagate to other reachable argrets
    //    if rhs.nargs > lhs.nargs, same but search backwards
    ECR& lhs = this->followECR(); //- must recompute, since
    ECR& rhs = ecr.followECR();  //-  unification may have occurred

    ECRargRet * largret = lhs.argRet();
    ECRargRet * rargret = rhs.argRet();
    if(largret == rargret){
      // already share argret -- do nothing
      // or neither has argrets (step c.) - do nothing (defer)
    } else if(largret){
      if(rargret){ // both have argrets (step d.)

        processArgRetFlow(*largret, *rargret);

      } else { // lhs has argrets, but not rhs (step a.) - search forward

        //- traverse include edges, collect frontier ECRs
        suco_set<ECR *> frontier;
        traverseCounter++;
        rhs.collectArgRetFrontier(frontier, *largret);

        //- for each frontier ECR, simulate assignment
        suco_iterator<ECR *> ei(frontier); // follow inclusion edges
        while(ei.Iterate()){
          processArgRetFlow(lhs.followECR().getArgRet(), ei.Current()->followECR().getArgRet());
        }
      }
    } // rhs has argrets, but not lhs (step b.) - do nothing
  }
}

//- traverses include edges forward until nodes with
//  non-0 argrets (that's not equal to ar);
//  collect these ecrs in frontier
void ECR::collectArgRetFrontier(suco_set<ECR *> & frontier, ECRargRet& ar) // assume ar already followed fwdptr
{
  if(this->traverseTag == traverseCounter) // cycle; return
    return;
  this->traverseTag = traverseCounter; // mark this ECR as "visited"

  if(!this->argRet()){ //- copy, and continue search
    this->argret = &ar;

    suco_iterator<ECR *>  ei(inclTo); // follow inclusion edges
    while(ei.Iterate())
      ei.Current()->followECR().collectArgRetFrontier(frontier, ar);
  } else if(this->argRet() != &ar){ //- add to frontier, and stop search
      frontier.Insert(this);
  } //- else this->argret == &ar, do nothing
}

//- follows inclusion edges, while true
//  if either fp returns false, stop and return false
bool ECR::followInclEdges(bool (*aofp)(AO& o), bool (*ecrfp)(ECR& e))
{
  if(this->traverseTag == traverseCounter) // cycle; return
    return true;
  this->traverseTag = traverseCounter; // mark this ECR as "visited"

  bool ret = true;
  if(ecrfp) ret = ecrfp(*this); // apply to this ECR

  if(aofp){ // apply to this's AOs
    suco_iterator<AO *> aoi(this->aoset);
    while(ret && aoi.Iterate())
      ret = aofp(*aoi.Current());
  }

  suco_iterator<ECR *> ei(inclTo); // follow inclusion edges
  while(ret && ei.Iterate())
    ret = ei.Current()->followECR().followInclEdges(aofp, ecrfp);

  return ret;
}

bool ECR::traverseAliases(bool (*aofp)(AO& o), bool (*ecrfp)(ECR& e))
{
  traverseCounter++;
  return this->followECR().followInclEdges(aofp, ecrfp);
}

//-- using this only increments traverseCounter once, to avoid
//   repeated visits from multiple ecrs in eset
bool ECR::traverseSetAliases(suco_set<ECR *>& eset, bool (*aofp)(AO& o), bool (*ecrfp)(ECR& e))
{
  traverseCounter++;
  bool ret = true;
  suco_iterator<ECR *> ei(eset);
  while(ret && ei.Iterate())
    ret = ei.Current()->followECR().followInclEdges(aofp, ecrfp);
  return ret;
}

//- affecting=true: for "star x", collect aliases for x also
void ECR::collectAliasECRs(suco_set<ECR *>& eset, bool affecting)
{
  ECR& tecr = this->followECR();

  if(eset.Insert(&tecr)){

    suco_iterator<ECR *> ei(tecr.inclTo); // follow inclusion edges
    while(ei.Iterate())
      ei.Current()->collectAliasECRs(eset, affecting);

    //- for "op x" and "ext x", must collect also
    //  aliases of x
    //- if affecting=true, ditto for "star x"
    suco_iterator<AO *> aoi(tecr.getAOset());
    while(aoi.Iterate()){
      AO * target_ao = aoi.Current();
      while(1){
        if(target_ao->getKind() == AO::aoOp){
          target_ao = &((AOOp *)target_ao)->getTarget();
        } else if(target_ao->getKind() == AO::aoExt){
          target_ao = &((AOExt *)target_ao)->getTarget();
        } else if(affecting && (target_ao->getKind() == AO::aoStar)){
          target_ao = &((AOStar *)target_ao)->getTarget();
        } else {
          break; //- break out of loop
        }
        if(target_ao->isVal()){
          break; //- break out of loop
        }
        if(!eset.Contains(&ECR::getECR(*target_ao))){
          ECR::getECR(*target_ao).collectAliasECRs(eset, affecting);
        }
      }
    }
  } //- else: already present, don't traverse children
}

void ECR::filterLocArgRet(suco_set<ECR *>& eset)
{
  suco_iterator<ECR *> ei(eset);
  while(ei.Iterate()){
    bool has_loc = false;
    suco_iterator<AO *> ai(ei.Current()->getAOset());
    while(ai.Iterate()){
      if(ai.Current()->isLocArgRet()){
        has_loc = true;
        break;
      }
    }
    if(!has_loc){
      ei.DeleteCurrent();
    }
  }
}

void ECR::collectInclFromECRs(suco_set<ECR *>& eset)
{
  ECR& tecr = this->followECR(); //- should not be necessary

  if(eset.Insert(&tecr)){

    suco_iterator<ECR *> ei(tecr.inclFrom); // follow inclusion edges backwards
    while(ei.Iterate())
      ei.Current()->collectInclFromECRs(eset);

  } //- else: already present, don't traverse parent
}

// WARNING: this function caches its lookup result,
// so it should only be called after the points-to graph
// has quiesced, which is to say after completion of
// all points-to analysis phases.
suco_set<ECR *>& ECR::getAliasECRs()
{
  if(!this->alias_ecrset){
    this->alias_ecrset = new suco_set<ECR *>;
    this->collectAliasECRs(*this->alias_ecrset);
    ECR::filterLocArgRet(*this->alias_ecrset);
  }
  return *this->alias_ecrset;
}

//- mark this node invalid, and propagate backwards along incl edges
void ECR::markInvalid(bool propDeref)
{
  if(invalid) return; //-- terminates backward search
  invalid = true;
  suco_iterator<ECR *> ifi(inclFrom); //SY: verify that inclFrom contains all included-from edges
  while(ifi.Iterate()) ifi.Current()->followECR().markInvalid(propDeref);

  if(propDeref){
    //-- find deref children: if p is invalid, then *p is also invalid
    suco_iterator<AO *> ai(aoset);
    while(ai.Iterate()){
      AO * starAO = ai.Current()->find(AO::aoStar);
      if(starAO)
        starAO->getECR().markInvalid(propDeref);
    }
  }

  //-- also - find struct/union children, and mark those
  //   (not necessary if collapse-always)
//TODO
}

//- limit_malloc: consider only malloc objects
//- do_touched: check not only exposed, but touched flag as well
//- do_vuln: vuln mode, check for vuln_locs rather than exposed
ExposedStatus ECR::inclToExposed(bool limit_malloc, bool do_touched, bool do_vuln)
{
  if(this->traverseTag == traverseCounter) // cycle; return
    return ExposedStatus::NA;
  this->traverseTag = traverseCounter; // mark this ECR as "visited"

  ExposedStatus ret = ExposedStatus::NA;

  if(do_vuln){ //- vuln mode: search for vuln_locs (using vuln_deref flag as hint)
    if(this->is_vuln_deref){
      suco_iterator<AO *> aoi(this->aoset);
      while(aoi.Iterate()){
        AO& ao = *aoi.Current();
        if((limit_malloc)?(ao.getKind() == AO::aoMalloc)
			 :(ao.isLoc())){
          if(ao.isVulnerableLoc() && ( do_touched ? this->touched : true )){
            ret.combine(ExposedStatus::All);
            if(ret.isSome()) return ret; //- short-circuit; no need to check further
          } else {
            ret.combine(ExposedStatus::None);
            if(ret.isSome()) return ret; //- short-circuit; no need to check further
          }
        }
      }
    } else { //- no vulnerable aliases; stop search
      return ExposedStatus::None;
    }

  } else { //- exposed/touched mode: can shortcut using exposed/touched flags
    bool count_this_step;

    if(!limit_malloc){
      count_this_step = !this->aoset.IsEmpty();
    } else { //- if limit_malloc, only count this step if this has malloc nodes
      count_this_step = false;
      //-- see if there are any malloc nodes
      suco_iterator<AO *> aoi(this->aoset);
      while(aoi.Iterate()){
        if(aoi.Current()->getKind() == AO::aoMalloc){
          count_this_step = true;
          break;
        }
      }
    }

    if(count_this_step && this->exposed && ( do_touched ? this->touched : true ))
      return ExposedStatus::All;

    ret = (count_this_step)?(ExposedStatus::None):(ExposedStatus::NA); //- starting point
  }

  //- follow inclusion edge
  suco_iterator<ECR *> iei(this->inclTo);
  while(iei.Iterate()){
    ret.combine(iei.Current()->inclToExposed(limit_malloc, do_touched, do_vuln));
    if(ret.isSome()) return ret; //- short-circuit; no need to check further
  }
  return ret;
}

void ECR::propagateInfluential()
{
  if(!influential){
    influential = true;

    //- mark AOs here?
    suco_iterator<AO *> ai(aoset);
    while(ai.Iterate())
      ai.Current()->setTSC(AO::TSC_INFLUENTIAL);

    propagateExposed();
    suco_iterator<ECR *> fi(inclFrom);
    while(fi.Iterate())
      fi.Current()->followECR().propagateInfluential();
  }
}

void ECR::propagateExposed()
{
  if(!exposed){
    exposed = true;

    //- mark AOs here?
    suco_iterator<AO *> ai(aoset);
    while(ai.Iterate())
      ai.Current()->setTSC(AO::TSC_EXPOSED);

    suco_iterator<ECR *> ti(inclTo);
    while(ti.Iterate())
      ti.Current()->followECR().propagateExposed();
  }
}

void ECR::touchExposedAndPropagate()
{
  if(exposed && !this->touched){
    this->touched = true;

    //- out of laziness, AOs won't be individually marked

    //- propagate forward
    suco_iterator<ECR *> ti(inclTo);
    while(ti.Iterate())
      ti.Current()->followECR().touchExposedAndPropagate();
  }
}

void ECR::markVulnerableDerefAndPropagate()
{
  if(!this->is_vuln_deref){
    this->is_vuln_deref = true;

    //- propagate backwards
    suco_iterator<ECR *> ti(this->inclFrom);
    while(ti.Iterate())
      ti.Current()->followECR().markVulnerableDerefAndPropagate();
  }
}

//- if ecrno == 0 (unassigned), then assign an ecrno
//- further, if outf != 0 and ecrno is unassigned, then
//           write inclTo list for this ecr, which
//           triggers this process for inclTo targets
int ECR::getEcrNo(FILE * outf)
{
  static int ecrno_counter = 0;

  if(!ecrno){
    ecrno = ++ecrno_counter;
    if(outf && !inclTo.IsEmpty()){
      suco_iterator<ECR *> iti(inclTo);
      //- pass 1: trigger output of unassigned ECRs
      while(iti.Iterate())
        iti.Current()->followECR().getEcrNo(outf);
      //- pass 2: write output
      iti.Rewind();
      fprintf(outf, "> %d", ecrno);
      while(iti.Iterate())
        fprintf(outf, " %d", iti.Current()->followECR().getEcrNo());
      fprintf(outf, "\n");
    }
  }

  return ecrno;
}

void ECR::debug_traceInclude(ECR& e)
{
  fprintf(AO::aoWriteStream, "--ECR[%08x]:\n", (unsigned int) &e);
}

void ECR::debug_dump(FILE * outf)
{
  fprintf(outf, "ECR[%08x] %s poss-type:", (unsigned int)this, invalid?"invalid":"valid");
  poss_type.debug_dump(outf);
  fprintf(outf, " contains:\n");
  suco_iterator<AO *> aoi(this->aoset);
  while(aoi.Iterate())
    aoi.Current()->debug_dump(outf);
  fprintf(outf, "INCLUDES TO ECRs:");
  suco_iterator<ECR *> ii(inclTo);
  while(ii.Iterate()) fprintf(outf, " [%08x]", (unsigned int)&ii.Current()->followECR());
  fprintf(outf, "\n");
  fprintf(outf, "POINTS TO ECR[%08x].\n", ptsTo?((unsigned int)&getPointsTo()):0);
  if(ptsTo && ptsTo->aoset.IsEmpty()){
    fprintf(outf, "([%08x] points to [%08x], incl to:", (unsigned int)ptsTo, ptsTo->ptsTo?((unsigned int)&ptsTo->getPointsTo()):0);
    suco_iterator<ECR *> pi(ptsTo->inclTo);
    while(pi.Iterate()) fprintf(outf, " [%08x]", (unsigned int)&pi.Current()->followECR());
    fprintf(outf, ")\n");
  }
}

void ECR::debug_dump_list(suco_llist<ECR *>& elist, FILE * outf)
{
  fprintf(outf, "ecrlist(%d): ", elist.Length());
  suco_iterator<ECR *> ei(elist);
  while(ei.Iterate()){
    fprintf(outf, "[%8x]", (unsigned int)ei.Current());
  }
  fprintf(outf, "\n");
}

//------------------------------------------------------

@


1.49
log
@Added "/V" output (freearg status for vuln mode).
Entailed hackishly modifying ECR::inclToExposed().
@
text
@d815 1
a815 1
AO::exposed_status ECR::inclToExposed(bool limit_malloc, bool do_touched, bool do_vuln)
d818 1
a818 1
    return AO::esNA;
d821 1
a821 1
  AO::exposed_status ret = AO::esNA;
d831 2
a832 5
            switch(ret){
	      case AO::esNA: ret = AO::esAll; break;
	      case AO::esAll: break; //-NOP
	      case AO::esNone: return AO::esSome;
            }
d834 2
a835 5
            switch(ret){
	      case AO::esNA: ret = AO::esNone; break;
	      case AO::esNone: break; //-NOP
	      case AO::esAll: return AO::esSome;
            }
d840 1
a840 1
      return AO::esNone;
d861 1
a861 1
      return AO::esAll;
d863 1
a863 1
    ret = (count_this_step)?(AO::esNone):(AO::esNA); //- starting point
d869 2
a870 25
    AO::exposed_status es = iei.Current()->inclToExposed(limit_malloc, do_touched, do_vuln);
    switch(ret){
      case AO::esAll:
	switch(es){
	  case AO::esSome:
	  case AO::esNone: return AO::esSome;
	  case AO::esAll:
	  case AO::esNA:   break;
	} break;
      case AO::esNone:
	switch(es){
	  case AO::esAll:
	  case AO::esSome: return AO::esSome;
	  case AO::esNone:
	  case AO::esNA:   break;
	} break;
      case AO::esNA:
        if(es == AO::esSome)
	  return AO::esSome;
	ret = es;
	break;
      case AO::esSome:	//- should not occur
	fprintf(stderr, "WARNING: inclToExposed encountered esSome\n");
	break;
    }
@


1.48
log
@MAJOR ADDITION: added -vuln mode computations to output
1. vulnerable locations (function pointers and first
   arguments to exec,system,longjmp,...)
2. vulnerable dereferences (any Ref ao that may point
   to a vulnerable location)
@
text
@d812 4
a815 1
AO::exposed_status ECR::inclToExposed(bool limit_malloc, bool do_touched)
d821 1
a821 1
  bool count_this_step;
d823 40
a862 10
  if(!limit_malloc){
    count_this_step = !this->aoset.IsEmpty();
  } else { //- if limit_malloc, only count this step if this has malloc nodes
    count_this_step = false;
    //-- see if there are any malloc nodes
    suco_iterator<AO *> aoi(this->aoset);
    while(aoi.Iterate()){
      if(aoi.Current()->getKind() == AO::aoMalloc){
        count_this_step = true;
        break;
a864 1
  }
d866 2
a867 2
  if(count_this_step && this->exposed && ( do_touched ? this->touched : true ))
    return AO::esAll;
d869 2
a870 1
  AO::exposed_status ret = (count_this_step)?(AO::esNone):(AO::esNA);
d872 1
d875 1
a875 1
    AO::exposed_status es = iei.Current()->inclToExposed(limit_malloc, do_touched);
@


1.47
log
@Added helper function ECR::debug_dump_list().
@
text
@d917 12
@


1.46
log
@Fixed efficiency bug: in ECR::collectAliasECRs, the
"has_locs" filter mechanism was removing non-loc ECRs
from the list too early, so the same sub-graph would've
been traversed multple times.
Now, loc-filtering is done separately, by a new function
ECR::filterLocArgRet().
@
text
@d970 10
@


1.45
log
@MAJOR UPDATE: towards relevant aos.
THIS VERSION RELIES ON ExpDescr's aoset TO CAPTURE
ALL DEPENDENCE INFORMATION, WHICH IS NOT THE CASE.
@
text
@a705 1
//- limit_loc=true: collect only ECRs with loc AOs
d707 1
a707 1
void ECR::collectAliasECRs(suco_set<ECR *>& eset, bool limit_loc, bool affecting)
d715 1
a715 1
      ei.Current()->collectAliasECRs(eset, limit_loc, affecting);
d737 1
a737 1
          ECR::getECR(*target_ao).collectAliasECRs(eset, limit_loc, affecting);
d741 2
d744 10
a753 13
    if(limit_loc){ //- if tecr has no loc, remove it!
		   //  NOTE: doing this here, as we needed to keep
		   //	tecr in eset during recursive collection
      bool has_loc = false;
      suco_iterator<AO *> ai(tecr.getAOset());
      while(ai.Iterate()){
        if(ai.Current()->isLocArgRet()){
          has_loc = true;
          break;
        }
      }
      if(!has_loc){
        eset.Remove(&tecr);
d756 4
a759 1
  } //- else: already present, don't traverse children
d784 1
@


1.44
log
@More work towards filtering relevant AOs:
 - Added flag -relevant-aos
 - AO added "dfa_relevant" bit for each AO
 - ECR added "collectInclFromECRs() helper that's
   needed when collecting relevant aos
 - TCA added a bunch of helpers:
   - markRelevantLocs() which calls
     1. clearRelevantTags() on each AO, to clear
        the dfa_relevant tags
     2. markStartingPoints(), which walks the
        assignment edges (in the CFG!) to populate
        the initial set of aos (based on readwrite
        flag and whether we want to mark safe AOs
        (for MBU) or unsafe ones (for RAN)).
     3. propagate along (flow-insensitive) assign
        edges.
@
text
@d706 3
a708 1
void ECR::collectAliasECRs(suco_set<ECR *>& eset)
d716 1
a716 1
      ei.Current()->collectAliasECRs(eset);
d718 40
@


1.43
log
@Changed AO/ECR relationship: added AO::getECR() function
that is to be called after pt-analysis finalization of
ECRs -- so, PRIOR to finalization, must use ECR::getECR()
(as is now done in pta.cpp), but AFTER, must only use
AO::getECR() which outputs a fatal error message if ECR
not found.
@
text
@d719 13
@


1.42
log
@Added routines to "finalize" ecrset after pt-analysis:
- added new factory method to keep the set of all
  allocated ECRs, to allow garbage collection when
  "finalizing";
- finalizers are called in tca.cpp:supplementalPTanalysis.
In tca.cpp: started adding code to compute filter set
for ptr-MBU analysis -- current version is very slow.
@
text
@d746 1
a746 1
        ECR::getECR(*starAO).markInvalid(propDeref);
@


1.41
log
@Added function fixECR() to finalize points-to graph
ECR mappings.
@
text
@d12 10
d29 6
d37 1
a37 1
  if(!ret) ret = new ECR;
d52 1
a52 1
  if(!ar) ar = new ECR;
d205 8
d233 3
a235 3
      //            other ECRs (can follow backptr), as well as edges
      //            and other AO (aoset and edge lists will have been
      //            carried forward to the tail?
d242 93
d338 1
a338 1
    (new ECR())->linkAO(ao);
d345 1
d350 8
a357 1
  ECR::fixECR(ao);
a368 1
    this->backptr.Insert(&ecr);
a389 2
//        if(!eargret->refcount) //- causing crash - why??
//          delete eargret;
d391 1
a391 1
        this->followECR().argret = ecr.argRet(); //- shortcutting refcount decr/incr
d410 3
a412 10
  if(argret){
    while(argret->fwdptr){
      ECRargRet * tmp = argret;
      argret = argret->fwdptr;
      tmp->refcount--;
//      if(!tmp->refcount) // causing crash - why?
//        delete tmp;
    }
  }
  return argret;
a418 1
    argret->refcount++;
d426 1
a426 1
  if(ret){
a427 2
    ret->refcount--;
  }
d434 1
a434 1
    this->ptsTo = new ECR;
a654 1
    ar.refcount++;
@


1.40
log
@Eliminated ECR::ecrsToLocAOs() -- functionality migrated
to ECRlocSet::addToAOset().
@
text
@d218 1
a218 1
ECR& ECR::getECR(AO& ao) //- if no ECR, creates a new one
d228 5
@


1.39
log
@Renamed ECR::setToNonLocAOset() to ECR::ecrsToLocAOs().
(Old name was a misnomer!)
@
text
@a589 14
//- collect AO set from ECR set; filter out non-location AOs
void ECR::ecrsToLocAOs(suco_set<ECR *>& ecrset, suco_set<AO *>& aoset)
{
  suco_iterator<ECR *> ei(ecrset);
  while(ei.Iterate()){
    aoset.Union(ei.Current()->getAOset());
  }
  suco_iterator<AO *> ai(aoset);
  while(ai.Iterate()){
    if(!ai.Current()->isLoc())
      ai.DeleteCurrent();
  }
}

@


1.38
log
@CHANGE 1: wrote ECR::getAliasECRs(), which collects and
  caches an ecrset of alias ECRs.
  This function replaces the functionality of
  collectAliasECRs(), but should only be called after
  the points-to graph is finalized.
CHANGE 2: changed RAN and REDp to account for MayFree
  set (CFGfunction::getGFreeHeap()).
  For RAN, this affected: filterCallsiteFact,
  intraProcHandleCall, and handleFreeCall (previously
  empty).
  For RED, this affected only REDp::intraProcHandleCall.
  For CFGfunction: added gfreeheap_ecrs/getGFreeHeapEcrs()
  to cache the freeheap ecrset for use in the above
  phases.
@
text
@d591 1
a591 1
void ECR::setToNonLocAOset(suco_set<ECR *>& ecrset, suco_set<AO *>& aoset)
@


1.37
log
@Small quickie bug-fix (not sure if it's necessarily the
correct fix): in ECRargRet::absorbArgRet, did not previously
check if args is null; added this check, but am now not sure
whether that should ever happen.  (I'm thinking it's OK)
@
text
@d617 13
@


1.36
log
@DONE implementing backedge filter stuff:
 - introduced new helper ECR::setToNonLocAOset
   (also used by earlier code for IMOD/IREF collection)
 - "borrowed" use of CFGfunction stuff that's used for
   IMOD/IREF collection.
 - Appears to work.
@
text
@d116 1
a116 1
    ECR * rarg = args[argno-1];
@


1.35
log
@1. Adjustment to "_" (untouched exposed aos) behavior: reports only
   one status, rather than a separate status for ptr/ptrw as was done
   before.  This is because the tsl analysis is already dependent on
   ptr/ptrw-ness, so it makes no sense to report both when doing one
   particular analysis.
   Involved change to ECR class definition (used to have two booleans
   touched_ptr/touched_ptrw; now just one).

2. Updated "/" (freearg) to account for untouched-ness: by adding
   a flag to AO::pointsToExposed/ECR::inclToExposed saying whether
   or not to check the touched flag.
@
text
@d590 14
@


1.34
log
@1. Added code to find untouched exposed locations (so they
   can be unexposed/untracked):
   - in ECR, added members touched_ptr, touched_ptrw
   - in RANc(FactHandler), for each Verify, touch the
     affected ECRs
   - at the end, traverse all AOs, and for each EXPOSED
     ao that's untouched, output a "_ [T|U] [T|U] <O>"
     line (T=touched, U=untouched; 1st=ptr, 2nd=ptrw).
   - (sml code has concurrently been modified to read
     those lines and treat <O> as SAFE when untouched)
2. Behavioral change: -cde-incl and -cde-pt are now
   on by default!
@
text
@d626 1
a626 1
AO::exposed_status ECR::inclToExposed(bool limit_malloc)
d648 1
a648 1
  if(this->exposed && count_this_step)
d655 1
a655 1
    AO::exposed_status es = iei.Current()->inclToExposed(limit_malloc);
d717 1
a717 4
//- note: if ptrw=false then only touched_ptr
//	  if ptrw=true  then BOTH touched_ptr and touched_ptrw
//	  (i.e. touched_ptrw => touched_ptr)
void ECR::touchExposedAndPropagate(bool ptrw)
d719 2
a720 4
  bool touched = touched_ptr && (ptrw?touched_ptrw:true);
  if(exposed && !touched){
    touched_ptr = true;
    if(ptrw) touched_ptrw = true;
d727 1
a727 1
      ti.Current()->followECR().touchExposedAndPropagate(ptrw);
@


1.33
log
@Changed argument to find_Cycle() from suco_set to suco_llist,
so the cycle collapse will consume the nodes linearly rather
than randomly.
@
text
@d717 19
@


1.32
log
@Fixed bug in points-to cycle detection function.
@
text
@d395 1
a395 1
bool ECR::findPtsToCycle(ECR& dest, suco_set<ECR *>& cyEcrs)
d416 1
a416 1
bool ECR::findInclToCycle(ECR& dest, suco_set<ECR *>& cyEcrs)
@


1.31
log
@Added implementation of cycle detection and elimination
of points-to cycles (had previously only implemented
for includes-to cycles).
CAVEAT: it's unclear whether the two algorithms will
clash; am now testing.
@
text
@d327 1
a327 1
  if(flag_collapse_ptsto_cycle && (this->ptsTo != &ecr)){
d334 2
@


1.30
log
@Gave the code the -Wall treatment: adjusted things to
get rid of warnings:
 - reordered initializers to match declaration order
 - made some destructors virtual (note that for many
   classes with no explicit destructors, I did not
   add explicit virtual destructors, so -Wall warnings
   remain)
 - made some signed/unsigned casts
 - made some pointer/unsigned int casts for printfs
 - filled in unaccounted-for cases in switch statements
@
text
@d3 1
d327 15
d388 26
d447 3
@


1.29
log
@HEAPSTACK UPDATE: enhance -ptr/-ptrw mode to optionally consider
freed-heap and stack locations as "possibly invalid" locations.

Augmented markInvalid to take a flag propDeref, to determine
whether or not to propagate "invalid" down dereference.
True: p invalid => *p invalid - used to mark "virtual"
      invalid locations, like what VALUE_int points to
False: p invalid =/=> *p invalid - used to mark "real"
       locations marked invalid, e.g. stack variable.
@
text
@a616 1
//    case AO::esSome:	//- should not occur
d629 3
d699 1
a699 1
  fprintf(AO::aoWriteStream, "--ECR[%08x]:\n", &e);
d704 1
a704 1
  fprintf(outf, "ECR[%08x] %s poss-type:", this, invalid?"invalid":"valid");
d706 1
a706 1
  fprintf(outf, " contains:\n", this);
d712 1
a712 1
  while(ii.Iterate()) fprintf(outf, " [%08x]", &ii.Current()->followECR());
d714 1
a714 1
  fprintf(outf, "POINTS TO ECR[%08x].\n", ptsTo?&getPointsTo():0);
d716 1
a716 1
    fprintf(outf, "([%08x] points to [%08x], incl to:", ptsTo, ptsTo->ptsTo?&ptsTo->getPointsTo():0);
d718 1
a718 1
    while(pi.Iterate()) fprintf(outf, " [%08x]", &pi.Current()->followECR());
@


1.28
log
@Hack-fixed bug in ugly-ugly ECRargRet::absorbArgRet function:
since nargs does NOT imply that args is allocated, the first
touch of args[argno-1] must instantiate it -- this is now
done using the already-written function getArgPtr -- used
only the first time; the remaining accesses are direct (for
efficiency).
@
text
@d557 1
a557 1
void ECR::markInvalid()
d562 1
a562 1
  while(ifi.Iterate()) ifi.Current()->followECR().markInvalid();
d564 8
a571 6
  //-- find deref children: if p is invalid, then *p is also invalid
  suco_iterator<AO *> ai(aoset);
  while(ai.Iterate()){
    AO * starAO = ai.Current()->find(AO::aoStar);
    if(starAO)
      ECR::getECR(*starAO).markInvalid();
@


1.27
log
@Added -cde-incl and -cde-pt flags -- only the latter
has been implemented: in ECR::includesTo, check for
cycle, and collapse these ECRs; also, remove redundant
inclTo/inclFrom edges as a result of the collapse.
Also, the output for -pta mode has been modified to
be more a summary, to allow better comparison between differnet
versions.
@
text
@d108 1
a108 1
    ECR * larg = this->args[argno-1];
@


1.26
log
@Fixed collectAliasECRs, which was incorrect -- it used
the traverseAlias short-circuiting mechanism which would
terminate traversals prematurely.
Rewrote as a single recursive function -- which turns out
to be rather small and simple.
@
text
@d4 1
d372 24
d397 1
a397 1
bool ECR::includesTo(ECR& ecr)
d399 28
d477 1
a477 4

    return true;

  } else return false;
@


1.25
log
@Updated redundant analysis: strong and weak assignments written;
to do: function calls and result collection.
Entailed following changes:
  PExprAssign::getLHS to return ExpDescr instead of AO set.
  DFA handleWeakAssign's second argument is now ExpDescr rather than AO set.
  ECR: added helper collectAliasECRs (not tested!)
@
text
@d493 5
a497 1
suco_set<ECR *> * ECR::cae_eset = 0;
d499 3
a501 5
bool ECR::cae_add_ecr(ECR& e)
{
  //- should assert cae_eset?
  return ECR::cae_eset->Insert(&e);
}
d503 1
a503 5
void ECR::collectAliasECRs(suco_set<ECR *>& eset)
{
  cae_eset = &eset;
  this->traverseAliases(0,ECR::cae_add_ecr);
  cae_eset = 0;
@


1.24
log
@Augmented traverseSetAliases to also pass AO function
(was previously just commented out, expecting it not
to be needed)
@
text
@d493 15
@


1.23
log
@CFG: wrote MBUfacts test for intersection between a MBUfact
and an AOset's alias set (done using ECR::traverseAliases).
Cascaded changes to AO/ECR include:
1. AO::ts_categ is now explicitly enumerated to allow >=
   comparison
2. ECR::traverseAliases now takes bool functions, and
   returns a bool, true if all applications return true,
   and false if *any* application returns false (and also
   halts traversal -- this is an optimization for the
   intersection check added: once an intersection is found,
   no further traversal is needed).
@
text
@d483 1
a483 1
bool ECR::traverseSetAliases(suco_set<ECR *>& eset, /* bool (*aofp)(AO& o), */ bool (*ecrfp)(ECR& e))
d489 1
a489 1
    ret = ei.Current()->followECR().followInclEdges(0/*aofp*/, ecrfp);
@


1.22
log
@Reduced scope of AOlist class: this is only to be used
specially within the AO tree to look up AOs.
All other occurrences (in ecr, cfg, etc) have been converted
to use suco_set<AO *>.
Should be no change in behavior.
@
text
@d451 3
a453 1
void ECR::followInclEdges(void (*aofp)(AO& o), void (*ecrfp)(ECR& e))
d456 1
a456 1
    return;
d459 3
a461 1
  if(ecrfp) ecrfp(*this); // apply to this ECR
d464 2
a465 2
    while(aoi.Iterate())
      aofp(*aoi.Current());
d469 10
a478 2
  while(ei.Iterate())
    ei.Current()->followECR().followInclEdges(aofp, ecrfp);
d481 3
a483 1
void ECR::traverseAliases(void (*aofp)(AO& o), void (*ecrfp)(ECR& e))
d486 5
a490 1
  this->followECR().followInclEdges(aofp, ecrfp);
@


1.21
log
@Added freearg handling: for each assignment to the first
argument of free, check to see if the argument points to
none, some, or all exposed objects -- with current implementation
it is sufficient to check the exposed flag of the corresponding
ECR objects (but must still follow inclTo edges).
Note -- attributes for two policies are computed, one considering
all AOs, another considering only Malloc AOs. The latter is unsafe
(but "usually safe", one would hope), but likely more efficient.
Output is "/ A M O" where A is the status for all AOs, M for malloc
AOs only, and O the AO in question.
@
text
@d203 1
a203 1
      ao.ecr->aolist.remove(ao);
d208 1
a208 1
      //            and other AO (aolist and edge lists will have been
d212 1
a212 1
    this->aolist.insert(ao);
d233 2
a234 2
    // - transfer aolist
    this->aolist.concatenate(ecr.aolist); // should be distinct sets; could also do merge
d458 5
a462 1
  if(aofp) this->aolist.foreachAO(aofp); // apply to this's AOs
d484 3
a486 3
  AOlistIterator ai(aolist);
  while(ai.iterate()){
    AO * starAO = ai.current()->find(AO::aoStar);
d505 1
a505 1
    count_this_step = !this->aolist.isEmpty();
d509 3
a511 3
    AOlistIterator aoi(this->aolist);
    while(aoi.iterate()){
      if(aoi.current()->getKind() == AO::aoMalloc){
a550 34
/*
void ECR::inclToExposed(AO::exposed_status& es_allaos, AO::exposed_status& es_malloc)
{
  if(this->traverseTag == traverseCounter) // cycle; return
    return;
  this->traverseTag = traverseCounter; // mark this ECR as "visited"

  if(this->exposed){
    if(es_allaos == AO::esNone) es_allaos = AO::esAll;
    if(es_malloc == AO::esNone){
      //-- see if there are any malloc nodes
      AOlistIterator aoi(this->aolist);
      while(aoi.iterate()){
        if(aoi.current()->getKind() == AO::aoMalloc){
          es_malloc = AO::esAll;
          break;
        }
      }
    }
  }

  suco_iterator<ECR *> iei(this->inclTo);
  while((es_allaos == AO::esNone || es_malloc == AO::esNone)
	&& iei.Iterate()){
    AO::exposed_status tmp_allaos = es_allaos;
    AO::exposed_status tmp_malloc = es_malloc;
    iei.Current()->inclToExposed(tmp_allaos,tmp_malloc);
    if(es_allaos == AO::esNone && tmp_allaos != AO::esNone)
      es_allaos = AO::esSome;
    if(es_malloc == AO::esNone && tmp_malloc != AO::esNone)
      es_malloc = AO::esSome;
  }
}
*/
d558 3
a560 3
    AOlistIterator ai(aolist);
    while(ai.iterate())
      ai.current()->setTSC(AO::TSC_INFLUENTIAL);
d575 3
a577 3
    AOlistIterator ai(aolist);
    while(ai.iterate())
      ai.current()->setTSC(AO::TSC_EXPOSED);
d622 3
a624 1
  aolist.debug_dump(outf);
d630 1
a630 1
  if(ptsTo && ptsTo->aolist.isEmpty()){
@


1.20
log
@Added mechanism to collect stats about safe/unsafe tracked/untracked
pointer/fnptr/ptrs-in-structs/locations; involved various new additions
(including 'f' defined-function directive from instr-ast.sml)
@
text
@d492 90
@


1.19
log
@(Added space)
@
text
@d482 1
a482 1
    AO * starAO = ai.current()->find_AOStar();
@


1.18
log
@BUG FIX: added followECR() to each iterator-iteration of
ecrs -- was giving hard-to-predict incorrect behavior.
@
text
@d82 1
@


1.17
log
@Major Revision: include ECR number and incl-to edges in output.
@
text
@d444 1
a444 1
      ei.Current()->collectArgRetFrontier(frontier, ar);
d476 1
a476 1
  while(ifi.Iterate()) ifi.Current()->markInvalid();
d504 1
a504 1
      fi.Current()->propagateInfluential();
d520 1
a520 1
      ti.Current()->propagateExposed();
@


1.16
log
@Added Type-safety Category assignment.
(major change).
Appears working, tested on gcc, verified on small examples,
not thoroughly verified.
Also, added -readable flag.
@
text
@d524 27
@


1.15
log
@Revamped TClatType;
renamed ECR::rtType to poss_type;
rewrote TCAstate functions for initializing poss-types;
also left a skeleton function for generating constraints.
Todo: augment TClatType with constraint graph capabilities,
generate contraints, and solve.
Also, AO needs to have required-type.
@
text
@d491 33
@


1.14
log
@Added routine to mark dereference nodes.
@
text
@d498 3
a500 3
  fprintf(outf, "ECR[%08x] %s runtime-type(", this, invalid?"invalid":"valid");
  rttype.debug_dump(outf);
  fprintf(outf, ") containing:\n", this);
@


1.13
log
@Modified debug output to dump enough information to
reconstruct pt-graph.
@
text
@d470 21
d498 1
a498 1
  fprintf(outf, "ECR[%08x] runtime-type(", this);
@


1.12
log
@Finished "add arg-ret assignment" functionality;
entailed adding "mainParent" member to ECRargRet, which
refers to the main parent, which is used as the basis
for finding function pointer resolutions -- make sure
mainParent is set correctly -- that is, getArg is only
called in the PTA initialization function.
Also added a couple of static helper functions in tca,
and made a bunch of ECR/ECRargRet accessors public.
@
text
@d481 3
a483 4
  fprintf(outf, "POINTS TO ECR[%08x]:\n", ptsTo);
  AO::aoWriteStream = outf; //- probably already set
  if(this->ptsTo)
    this->getPointsTo().traverseAliases(AO::writeAO, ECR::debug_traceInclude);
d485 7
@


1.11
log
@Deleted ECRset and ECRsetIterator; replaced with suco set and iterator.
@
text
@d24 6
d295 1
a295 1
    argret = new ECRargRet;
d399 3
a401 1
    if(lhs.argRet() == rhs.argRet()){
d404 2
a405 2
    } else if(lhs.argRet()){
      if(rhs.argRet()){ // both have argrets (step d.)
d407 1
a407 1
        processArgRetFlow(lhs.getArgRet(), rhs.getArgRet());
d414 1
a414 1
        rhs.collectArgRetFrontier(frontier, lhs.getArgRet());
d418 1
a418 1
        while(ei.Iterate())
d420 1
a420 1

@


1.10
log
@Expanded traverseAliasese to take two functions, one to traverse AOs,
another for ECRs (used by new debug funcion).
Also, more importantly, FIXED BUG with traversal program: did not
previously followECR, therefore many ECR/AOs were skipped in the
traversal.
@
text
@a7 84
ECRset::~ECRset()
{
  node * n = head;
  while(n){
    node * del = n;
    n = n->next;
    delete del;
  }
}

bool ECRset::insert(ECR& e) // returns true if "success" (not already present)
{
  node ** np;
  for(np = &head; *np && &(*np)->ecr <= &e; np = &(*np)->next)
    if(&(*np)->ecr == &e)
      return false;
  *np = new node(e, *np);
  return true;
}

void ECRset::debug_dump(FILE * os)
{
  fprintf(os, "ECRset(");
  for(node * n = head; n; n = n->next){
    fprintf(os, " ");
    n->ecr.debug_dump(os);
  }
  fprintf(os, " )\n");
}

// - only does pointer-comparison for equality
// - removes elements from eset
void ECRset::merge(ECRset& eset)
{
  node ** tp = &this->head;
  node * ep = eset.head;
  eset.head = 0;
  while(ep){
    if(!*tp){
      *tp = ep;
      return;
    } else if(&(*tp)->ecr < &ep->ecr){
      tp = &(*tp)->next;
    } else if(&(*tp)->ecr == &ep->ecr){
      node * tmp = ep;
      ep = ep->next;
      delete tmp;
    } else {
      node * tmp = ep;
      ep = ep->next;
      tmp->next = *tp;
      *tp = tmp;
    }
  }
}

void ECRset::remove(ECR& e)
{
  node ** np;
  for(np = &head; *np && &(*np)->ecr <= &e; np = &(*np)->next)
    if(&(*np)->ecr == &e){
      node * del = *np;
      *np = (*np)->next;
      delete del;
      return;
    }
}

//------------------------------------------------------

bool ECRsetIterator::iterate()
{
  if(initial) initial = false;
  else if(nptr) nptr = nptr->next;
  return (nptr != 0);
}

ECR * ECRsetIterator::current()
{
  return nptr?(&nptr->ecr):(ECR *)0;
}

//------------------------------------------------------

d230 1
a230 1
    this->backptr.insert(ecr);
d232 1
a232 1
    this->ptsFrom.merge(ecr.ptsFrom);
d234 2
a235 2
    this->inclFrom.merge(ecr.inclFrom);
    this->inclTo.merge(ecr.inclTo);
d240 1
a240 1
      tgtecr.ptsFrom.remove(ecr);
d320 1
a320 1
    ecr.ptsFrom.insert(*this);
d368 2
a369 2
     this->inclTo.insert(ecr)){ // true means new incl target
    ecr.inclFrom.insert(*this);
d404 1
a404 1
        ECRset frontier;
d409 3
a411 3
        ECRsetIterator ei(frontier); // follow inclusion edges
        while(ei.iterate())
          processArgRetFlow(lhs.followECR().getArgRet(), ei.current()->followECR().getArgRet());
d424 1
a424 1
void ECR::collectArgRetFrontier(ECRset& frontier, ECRargRet& ar) // assume ar already followed fwdptr
d434 3
a436 3
    ECRsetIterator ei(inclTo); // follow inclusion edges
    while(ei.iterate())
      ei.current()->collectArgRetFrontier(frontier, ar);
d438 1
a438 1
      frontier.insert(*this);
d451 3
a453 3
  ECRsetIterator ei(inclTo); // follow inclusion edges
  while(ei.iterate())
    ei.current()->followECR().followInclEdges(aofp, ecrfp);
@


1.9
log
@Added points-to set output option: -pta now dumps points-to sets
(alias groups)...
 - ao: added isRef flag/accessor
 - ecr.cpp/h: modified traversePointsToSet - is now traverseAliases
 - tca.cpp/h: top level callers.
@
text
@d526 1
a526 1
void ECR::followInclEdges(void (*fp)(AO& o))
d532 2
a533 1
  this->aolist.foreachAO(fp); // apply to this's AOs
d537 1
a537 1
    ei.current()->followInclEdges(fp);
d540 1
a540 1
void ECR::traverseAliases(void (*fp)(AO& o))
d543 6
a548 1
  followInclEdges(fp);
d560 1
a560 1
    this->getPointsTo().traverseAliases(AO::writeAO);
@


1.8
log
@Added skeleton for lvalType(), with initial seeding rules
in tca.cpp, and ECR debug_dump to include rttype.
Must rethink strategy for solving constraints before
proceeding
@
text
@d539 1
a539 1
void ECR::traversePointsToSet(void (*fp)(AO& o))
d542 1
a542 2
  if(this->ptsTo)
    this->getPointsTo().followInclEdges(fp);
d553 2
a554 1
  traversePointsToSet(AO::writeAO);
@


1.7
log
@Fixed couple of typos in comments.
@
text
@d548 3
a550 1
  fprintf(outf, "ECR[%08x] containing:\n", this);
@


1.6
log
@major fixes (in Malaysia): now handles argret stuff
correctly (I think).
also, renamed fixnargs to maxnargs.
@
text
@d478 1
a478 1
      // already share argret -; do nothing
d498 1
a498 1
    } // either rhs has argrets, but not lhs (step b.) - do nothing
@


1.5
log
@3) added -fixnargs flag to compute max nargs and use
   that for all argrets. simpler solution...

4) added fwdptr to argret - necessary to ensure
   correctness (?).
   This resulted in a major overhaul - argret::absorb
   must now be wary of clashes with ecr::absorb -
   added recursive trick, etc.
   Currently seems to work, but have not validated results.
   NOTE: this change resulted in a crash that was eliminated
   only after I removed both deletes of argrets. FIND BUG!?!
@
text
@d21 1
a21 1
  for(np = &head; *np; np = &(*np)->next)
d24 1
a24 1
  *np = new node(e);
a27 5
void ECRset::insert_no_check(ECR& e)
{
  head = new node(e, head);
}

d38 2
a39 4
//-- currently inefficient (quadratic);
//   to do better, list should be at least sorted
//   - only does pointer-comparison for equality
//   - removes elements from eset
d42 18
a59 13
  while(eset.head){
    node * ep = eset.head;
    eset.head = eset.head->next;
    node * tp;
    for(tp = this->head; tp; tp = tp->next){
      if(&tp->ecr == &ep->ecr){ // element found
        delete ep;
        break;
      }
    }
    if(!tp){ // not found: insert into this
      ep->next = this->head; // just transfer the node over
      this->head = ep;
d67 1
a67 1
  for(np = &head; *np; np = &(*np)->next)
d92 1
a92 1
int ECRargRet::fix_nargs = 0;
d97 2
a98 2
     && fix_nargs < ((AOArg&) ao).argNo())
    fix_nargs = ((AOArg&) ao).argNo();
d123 1
a123 1
    if(this->argsize < fix_nargs)
d169 9
d185 1
a185 4
    ECR * rarg = args[argno-1];

    if(!this->args[argno-1])
      this->args[argno-1] = rarg;
d191 1
d193 10
d206 8
a213 7
    if(this->ret){
      if(ret){
        this->ret->followECR().absorb(ret->followECR());
      } //- else nothing to absorb
    } else {
      this->ret = ret;
    }
d220 4
a223 1
  //-- absorb args
d247 9
a255 2
  // absorb from targs/tret into this->args/ret
  // again, use recursion to store temps
d314 1
a314 1
    this->backptr.insert_no_check(ecr);
d404 1
a404 1
    ecr.ptsFrom.insert_no_check(*this);
@


1.4
log
@Major change: added ArgRet handling stuff:
defined ECRargRet class, wrote functions
ECR::processArgRetFlow/simulateAssign/collectArgRetFrontier...
Only aspect not handled: after simulating assignment for
argrets with different nargs, must propagate the delta
(forward or backward) - requires non-trivial change
to data structure.
@
text
@d94 9
d125 6
a130 2
    this->argsize = argno * 2;
    if(this->argsize < 10) this->argsize = 10; // minimum size
d171 31
d216 1
d223 1
d225 7
a231 10
  // absorb from targs into this->args
  for(int i = 0; i < tnargs; ++i){
    if(this->args[i]){
      if(targs[i]){
        this->args[i]->followECR().absorb(targs[i]->followECR());
      } //- else nothing to absorb
    } else {
      this->args[i] = targs[i];
    }
  }
a232 10

  //-- absorb return
  if(this->ret){
    if(ar->ret){
      this->ret->followECR().absorb(ar->ret->followECR());
    } //- else nothing to absorb
  } else {
    this->ret = ar->ret;
  }
  ar->ret = 0;
d304 8
a311 9
    if(ecr.argret){
      if(ecr.argret == this->argret){
        ecr.argret->refcount--;
        ecr.argret = 0;
      } else if(this->argret){
        ECRargRet * eargret = ecr.detachArgRet();
        this->argret->absorb(eargret); //- eargret is cleared by absorb
        if(!eargret->refcount)
          delete eargret;
d313 1
a313 1
        this->argret = ecr.argret;
d330 14
d350 1
a350 1
  return *argret;
d353 1
a353 1
ECRargRet * ECR::detachArgRet()
d355 2
a356 2
  if(this->argret){
    ECRargRet * ret = this->argret;
d359 2
a360 2
    return ret;
  } else return 0;
d387 1
a387 1
void ECR::simulateAssign(int argno, ECRargRet& largret, ECRargRet& rargret)
d408 1
a408 1
void ECR::processArgRetFlow(ECRargRet& largret, ECRargRet& rargret)
d416 2
a417 1
    fprintf(stderr, "Different LR nargs (%d,%d) - skipping for now\n", minLRnargs, maxLRnargs);
d451 5
a455 4
    if(lhs.argret == rhs.argret){
      // already share argret; do nothing
    } else if(lhs.argret){
      if(rhs.argret){ // both have argrets (step d.)
d457 1
a457 1
        processArgRetFlow(*lhs.argret, *rhs.argret);
d460 1
d464 1
a464 1
        rhs.collectArgRetFrontier(frontier, *lhs.argret);
d469 2
a470 1
          processArgRetFlow(*lhs.argret, ei.current()->getArgRet());
a472 1
      // or neither has argrets (step c.) - do nothing (defer)
d482 1
a482 1
void ECR::collectArgRetFrontier(ECRset& frontier, ECRargRet& ar)
d488 1
a488 1
  if(!this->argret){ //- copy, and continue search
d495 1
a495 1
  } else if(this->argret != &ar){ //- add to frontier, and stop search
@


1.3
log
@(Added ECRset?)
Wrote OLF points-to analysis, which seems to work (but no
cycle-elimination), with fwdptr mechanism (fast-union find).
@
text
@d94 112
d211 2
d225 1
a225 1
      //            other ECRs (can follow backptr),  as well as edges
d270 15
d298 19
d320 1
a320 1
    this->ptsTo = new ECR();
d338 39
a376 1
void ECR::includesTo(ECR& ecr) // assume this and ecr normalized
d386 42
a427 1
  }
d430 20
a449 1
int ECR::traverseCounter = 0;
@


1.2
log
@Removed fwdptr; rewrote unifyECR to move everything to
single ECR.
@
text
@d6 1
d8 95
a102 1
void ECR::unify(AO& ao)
d106 2
a107 9
      //- unify ao.ecr into this
      // - transfer aolist
      this->aolist.concatenate(ao.ecr->aolist);
      // - transfer ptsFrom,ptsTo
      this->ptsFrom.merge(ao.ecr->ptsFrom);
      this->ptsTo.merge(ao.ecr->ptsTo);
      // - transfer inclFrom,inclTo
      this->inclFrom.merge(ao.ecr->inclFrom);
      this->inclTo.merge(ao.ecr->inclTo);
d109 5
a113 2
      // - delete old ECR
      delete ao.ecr;
d115 1
a116 1
    ao.ecr = this;
d123 7
a129 1
    (new ECR())->unify(ao);
d133 26
d162 54
a215 3
    getECR(ao2).unify(ao1);
  else
    getECR(ao1).unify(ao2);
d218 1
a218 1
void ECR::pointsTo(ECR& ecr)
d220 3
a222 2
  TCedge * edge = ptsTo.insert(ecr, *this, TCedge::ePtsTo);
  if(edge) ecr.ptsFrom.insert_no_check(*edge);
d229 3
a231 5

  fprintf(outf, "POINTS TO: ");
  TCedgeIterator ei(ptsTo);
  while(ei.iterate())
    fprintf(outf, " ECR[%08x]", &ei.current()->getTo());
@


1.1
log
@Initial revision
@
text
@d7 1
a7 1
void ECR::link(AO& ao)
d11 12
a22 4
      //- unlink ao.ecr
      ao.ecr->aolist.remove(ao);
      if(ao.ecr->aolist.isEmpty())
        delete ao.ecr;
d31 2
a32 10
  if(!ao.ecr){
    (new ECR())->link(ao);
  } else {
    //- follow forward pointer
    ECR * tail = ao.ecr;
    while(tail->fwdptr)
      tail = tail->fwdptr;
    if(ao.ecr != tail)
      tail->link(ao);
  }
d39 1
a39 1
    getECR(ao2).link(ao1);
d41 1
a41 1
    getECR(ao1).link(ao2);
d46 1
a46 1
  TCedge * edge = ptsTo.insert(*this, ecr, TCedge::ePtsTo);
d54 6
@
