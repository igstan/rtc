head	1.76;
access;
symbols;
locks; strict;
comment	@// @;


1.76
date	2004.07.03.22.40.00;	author suan;	state Exp;
branches;
next	1.75;

1.75
date	2004.06.29.20.02.32;	author suan;	state Exp;
branches;
next	1.74;

1.74
date	2004.06.24.18.48.58;	author suan;	state Exp;
branches;
next	1.73;

1.73
date	2004.06.23.17.16.49;	author suan;	state Exp;
branches;
next	1.72;

1.72
date	2004.06.23.14.57.00;	author suan;	state Exp;
branches;
next	1.71;

1.71
date	2004.05.11.19.44.15;	author suan;	state Exp;
branches;
next	1.70;

1.70
date	2004.05.09.18.42.38;	author suan;	state Exp;
branches;
next	1.69;

1.69
date	2004.05.07.21.21.52;	author suan;	state Exp;
branches;
next	1.68;

1.68
date	2004.05.07.19.52.39;	author suan;	state Exp;
branches;
next	1.67;

1.67
date	2004.04.29.18.03.54;	author suan;	state Exp;
branches;
next	1.66;

1.66
date	2004.04.21.15.14.15;	author suan;	state Exp;
branches;
next	1.65;

1.65
date	2004.04.15.17.49.30;	author suan;	state Exp;
branches;
next	1.64;

1.64
date	2004.04.14.16.12.19;	author suan;	state Exp;
branches;
next	1.63;

1.63
date	2004.04.08.18.48.44;	author suan;	state Exp;
branches;
next	1.62;

1.62
date	2004.04.08.18.42.32;	author suan;	state Exp;
branches;
next	1.61;

1.61
date	2004.04.06.00.03.55;	author suan;	state Exp;
branches;
next	1.60;

1.60
date	2004.04.05.18.16.29;	author suan;	state Exp;
branches;
next	1.59;

1.59
date	2004.04.02.03.09.18;	author suan;	state Exp;
branches;
next	1.58;

1.58
date	2004.04.02.02.16.47;	author suan;	state Exp;
branches;
next	1.57;

1.57
date	2004.04.02.01.37.43;	author suan;	state Exp;
branches;
next	1.56;

1.56
date	2004.03.29.20.29.06;	author suan;	state Exp;
branches;
next	1.55;

1.55
date	2004.03.29.02.24.42;	author suan;	state Exp;
branches;
next	1.54;

1.54
date	2004.03.18.21.21.28;	author suan;	state Exp;
branches;
next	1.53;

1.53
date	2004.02.25.22.48.00;	author suan;	state Exp;
branches;
next	1.52;

1.52
date	2004.02.21.23.47.23;	author suan;	state Exp;
branches;
next	1.51;

1.51
date	2004.02.21.23.25.21;	author suan;	state Exp;
branches;
next	1.50;

1.50
date	2004.02.20.16.56.39;	author suan;	state Exp;
branches;
next	1.49;

1.49
date	2004.02.18.23.10.55;	author suan;	state Exp;
branches;
next	1.48;

1.48
date	2004.02.18.22.33.22;	author suan;	state Exp;
branches;
next	1.47;

1.47
date	2003.12.16.22.57.18;	author suan;	state Exp;
branches;
next	1.46;

1.46
date	2003.11.13.20.04.29;	author suan;	state Exp;
branches;
next	1.45;

1.45
date	2003.11.12.00.10.31;	author suan;	state Exp;
branches;
next	1.44;

1.44
date	2003.11.07.20.39.42;	author suan;	state Exp;
branches;
next	1.43;

1.43
date	2003.06.18.20.08.46;	author suan;	state Exp;
branches;
next	1.42;

1.42
date	2003.06.18.19.07.07;	author suan;	state Exp;
branches;
next	1.41;

1.41
date	2003.02.25.20.04.46;	author suan;	state Exp;
branches;
next	1.40;

1.40
date	2003.02.14.20.55.04;	author suan;	state Exp;
branches;
next	1.39;

1.39
date	2002.11.15.17.49.43;	author suan;	state Exp;
branches;
next	1.38;

1.38
date	2002.11.13.01.42.39;	author suan;	state Exp;
branches;
next	1.37;

1.37
date	2002.11.07.00.40.47;	author suan;	state Exp;
branches;
next	1.36;

1.36
date	2002.11.06.20.03.20;	author suan;	state Exp;
branches;
next	1.35;

1.35
date	2002.10.30.20.47.39;	author suan;	state Exp;
branches;
next	1.34;

1.34
date	2002.10.28.22.02.27;	author suan;	state Exp;
branches;
next	1.33;

1.33
date	2002.10.23.20.26.57;	author suan;	state Exp;
branches;
next	1.32;

1.32
date	2002.10.21.18.23.51;	author suan;	state Exp;
branches;
next	1.31;

1.31
date	2002.10.17.15.51.44;	author suan;	state Exp;
branches;
next	1.30;

1.30
date	2002.10.16.15.57.07;	author suan;	state Exp;
branches;
next	1.29;

1.29
date	2002.09.18.15.35.20;	author suan;	state Exp;
branches;
next	1.28;

1.28
date	2002.08.28.22.57.35;	author suan;	state Exp;
branches;
next	1.27;

1.27
date	2002.08.19.14.22.25;	author suan;	state Exp;
branches;
next	1.26;

1.26
date	2002.08.18.16.15.21;	author suan;	state Exp;
branches;
next	1.25;

1.25
date	2002.08.16.16.57.31;	author suan;	state Exp;
branches;
next	1.24;

1.24
date	2002.08.15.21.16.25;	author suan;	state Exp;
branches;
next	1.23;

1.23
date	2002.08.15.14.53.04;	author suan;	state Exp;
branches;
next	1.22;

1.22
date	2002.08.15.14.34.17;	author suan;	state Exp;
branches;
next	1.21;

1.21
date	2002.08.13.22.45.11;	author suan;	state Exp;
branches;
next	1.20;

1.20
date	2002.07.30.19.48.50;	author suan;	state Exp;
branches;
next	1.19;

1.19
date	2002.07.30.18.16.24;	author suan;	state Exp;
branches;
next	1.18;

1.18
date	2002.07.29.16.18.09;	author suan;	state Exp;
branches;
next	1.17;

1.17
date	2002.07.29.13.36.42;	author suan;	state Exp;
branches;
next	1.16;

1.16
date	2002.07.28.21.37.24;	author suan;	state Exp;
branches;
next	1.15;

1.15
date	2002.05.23.22.44.44;	author suan;	state Exp;
branches;
next	1.14;

1.14
date	2002.04.24.22.15.12;	author suan;	state Exp;
branches;
next	1.13;

1.13
date	2002.04.19.23.54.05;	author suan;	state Exp;
branches;
next	1.12;

1.12
date	2002.04.19.16.45.01;	author suan;	state Exp;
branches;
next	1.11;

1.11
date	2002.04.18.17.06.19;	author suan;	state Exp;
branches;
next	1.10;

1.10
date	2002.04.18.15.55.32;	author suan;	state Exp;
branches;
next	1.9;

1.9
date	2002.04.16.22.43.51;	author suan;	state Exp;
branches;
next	1.8;

1.8
date	2002.04.16.20.57.21;	author suan;	state Exp;
branches;
next	1.7;

1.7
date	2002.04.16.20.06.53;	author suan;	state Exp;
branches;
next	1.6;

1.6
date	2002.04.11.20.34.41;	author suan;	state Exp;
branches;
next	1.5;

1.5
date	2002.04.11.04.21.43;	author suan;	state Exp;
branches;
next	1.4;

1.4
date	2002.04.10.16.19.04;	author suan;	state Exp;
branches;
next	1.3;

1.3
date	2002.04.10.15.42.04;	author suan;	state Exp;
branches;
next	1.2;

1.2
date	2002.04.09.22.11.03;	author suan;	state Exp;
branches;
next	1.1;

1.1
date	2002.04.09.19.24.35;	author suan;	state Exp;
branches;
next	;


desc
@Initial draft, not complete; all code in one file.
@


1.76
log
@Commented out "VULNSTAT" output, which generated
too much output when analyzing "mesa".
@
text
@#include <ctype.h>
#include <stdio.h>
#include <stdlib.h> // for strtoul, exit

#include "ao.h"
#include "flags.h"
#include "ecr.h"

//------------------------------------------------------
//- AOlist

AOlist::~AOlist()
{
  node * n = head;
  while(n){
    node * del = n;
    n = n->next;
    delete &del->ao;
    delete del;
  }
}

void AOlist::debug_dump(FILE * os)
{
  fprintf(os, "---AOlist:\n");
  for(node * n = head; n; n = n->next){
    fprintf(os, "\t");
    n->ao.debug_dump(os);
    fprintf(os, "\n");
  }
  fprintf(os, "---End AOlist:\n");
}

void AOlist::foreachAO(void (*fp)(AO& o))
{
  for(node * n = head; n; n = n->next)
    fp(n->ao);
}

void AOlist::traverseAOs(void (*fp)(AO& o))
{
  for(node * n = head; n; n = n->next)
    n->ao.traverseAOs(fp);
}

//------------------------------------------------------
//-ExposedStatus

const ExposedStatus ExposedStatus::All(esAll);
const ExposedStatus ExposedStatus::Some(esSome);
const ExposedStatus ExposedStatus::None(esNone);
const ExposedStatus ExposedStatus::NA(esNA);

char ExposedStatus::exposedCode()
{
  switch(status){
    case esAll:   return 'A';
    case esSome:  return 'S';
    case esNone:  return 'N';
    case esNA:    return 'N';
  }
  return 'X'; //- error
}

void ExposedStatus::combine(ExposedStatus es)
{
  switch(this->status){
    case esAll:
      switch(es.status){
        case esSome:
        case esNone: this->status = esSome;
                     break;
        case esAll:
        case esNA:   break;
      } break;
    case esNone:
      switch(es.status){
        case esAll:
        case esSome: this->status = esSome;
                     break;
        case esNone:
        case esNA:   break;
      } break;
    case esNA:
      this->status = es.status;
      break;
    case esSome:
      break;
  }
}

//------------------------------------------------------
//- AO

void AO::traverseAOs(void (*fp)(AO& o))
{
  fp(*this);
  aolist.traverseAOs(fp);
}

/* NOTE: This function potentially creates and frees many
         edges; could not cache and recycle nodes because
         C++ doesn't allow copies into the reference members
         of TCassignEdge. Oh well...
 */
TCassignEdge * AO::assignTo(AO& tgt, TCtype& ty)
{
  tgt.isAssignedAO = true;
  TCassignEdge * newe = new TCassignEdge(tgt, *this, ty);
  if(this->assignsTo.Insert(newe)){
    tgt.assignsFrom.Insert(newe);
    return newe;
  } else {
    delete newe;
    return 0;
  }
}

//- Does this AO represent a direct array access?
//  Include only "loc" AOs:
//   - a[i], a[i][j], s.a[i], s[i].a[j]
//  But not: s->a[i], (*p)[i].
bool AO::isDirectArrayAccess()
{
  //- root case: <loc: ty = array>
  //- struct/union case: (S|U <direct-array>) : ty = array>
  if(this->getStaticType()
	&& this->getStaticType()->getKind() == TCtype::tcArray){
    if(this->isLoc()){
      return true;
    }
    if(this->getKind() == aoSDot){
      return ((AOSDot *)this)->getParent().isDirectArrayAccess();
    }
    if(this->getKind() == aoUDot){
      return ((AOUDot *)this)->getParent().isDirectArrayAccess();
    }
  }
  //- general case: D O A <direct-array>
  if(this->getKind() == AO::aoStar){
    AO& ao2 = ((AOStar *)this)->getTarget();
    if(ao2.getKind() == AO::aoOp){
      AO& ao3 = ((AOOp &)ao2).getTarget();
      if(ao3.getKind() == AO::aoAddrOf){
        AO& ao4 = ((AOAddrOf &)ao3).getTarget();
        return ao4.isDirectArrayAccess();
      }
    }
  }
  return false;
}

//--------
// Check to see if this AO points to anything exposed
// Arguments are actually return values!
ExposedStatus AO::pointsToExposed(bool limit_malloc, bool do_touched, bool do_vuln)
{
  if(ecr){
    ECR& e = ecr->followECR();
    if(e.ptsTo){
      ECR::traverseCounter++;
      return e.getPointsTo().inclToExposed(limit_malloc, do_touched, do_vuln);
    } //- else, no points-to, leave alone
  } //- else, no ecr, leave alone
  return ExposedStatus::NA; //- SY: or should it be esNone?
}

//- for struct and union types, as well as arrays of struct/union types,
//  instantiate all AOSDot/AOUDot aos!
//~ Note: must duplicate tylist, because get_or_create_AOSDot may consume it.
//        This may also lead to leaks!
void AO::instantiateStructUnionMembers()
{
  TCtype * sty = this->getStaticType();
  if(sty){
    while(sty->getKind() == TCtype::tcArray){
      sty = &((TCnumType *)sty)->getBaseType();
    }
    if(sty->getKind() == TCtype::tcStruct){
      suco_llist<TCtype *> * tylist = &((TCstructUnionType *)sty)->getTypeList();
      while(!tylist->IsEmpty()){
        //-- now, lookup AOSDot
        AO& sao = this->get_or_create_AOSDot(*tylist, false); //- cannot deleteTyList: if found, can delete list, but not constituent types!
        sao.instantiateStructUnionMembers();
        //-- create copy of tylist, minus last element
        suco_iterator<TCtype *> tli(*tylist);
        tylist = new suco_llist<TCtype *>;
        tli.Iterate();
        TCtype * ty = 0;
        while(1){
          ty = tli.Current();
          if(tli.Iterate())
            tylist->Append(ty);
          else break;
        }
      }
      //- cleanup
      if(tylist != &((TCstructUnionType *)sty)->getTypeList())
        delete tylist; // should be empty
    }
    if(sty->getKind() == TCtype::tcUnion){
      suco_iterator<TCtype *> tli(((TCstructUnionType *)sty)->getTypeList());
      while(tli.Iterate()){
        AO& uao = this->get_or_create_AOUDot(*tli.Current(), false); //- cannot deleteTy
        uao.instantiateStructUnionMembers();
      }
    }
  }
}

void AO::setStaticType(TCtype& ty) //- must consume ty
{
  if(!staticType){
    staticType = &ty;
    if(flag_instantiate_structunion)
      this->instantiateStructUnionMembers(); //- should only be called for Loc or ArgRet objects
  } else {
    if(!staticType->equiv(ty)){
//-TODO: try to select "stronger" type?
//	 Actually, need help from front end to differentiate
//	 between explicit decls and implicits or externs.
    //-For now, NOP: just arbitrarily stick with first-encountered instance
/*******************************************/
/**/if( (this->getKind() != aoFunction) &&
/**/	(this->getKind() != aoArg) &&
/**/	(this->getKind() != aoReturn) ){
/**/fprintf(stderr, "\nWARNING(AO::setStaticType): mismatched static types for ");
/**/this->dump_descr(stderr);
/**/fprintf(stderr, "\n  was: ");
/**/this->staticType->debug_dump(stderr);
/**/fprintf(stderr, "  now: ");
/**/ty.debug_dump(stderr);
/**/fprintf(stderr, "\n");
/**/}
/*******************************************/
      TCtype::deleteTy(ty); //- must consume ty
    } else {
      TCtype::deleteTy(ty); //- must consume ty
    }
  }
}

//- sets "last argno" and "is varg?"
//  NOTE: largno is the ellipsis position for vararg,
//        and one past the last for non-varg functions.
//  ~ instantiate all arg aos up to largno!
void AOFunction::setAttributes(int larg_no, bool is_varg)
{
  this->largno = larg_no;
  this->isvarg = is_varg;
  for(int i = 1; i <= this->largno; ++i)
    this->get_or_create_AOArg(i);
}

void AOMalloc::meetMallocStaticType(TCtype * ty, unsigned int size)
{
  if(this->mtype && this->mtype->getKind() == TCtype::tcVoid) //- tcVoid means "bottom": do nothing
    return;
  if(ty && size){ //- known type/size
    //- normalize ty/size pair
    while(ty->getKind() == TCtype::tcArray){
      size *= ((TCnumType *)ty)->getSize();
      ty = &((TCnumType *)ty)->getBaseType();
    }
    if(!this->mtype){ //- null means "uninitialized"; tcVoid means "bottom"
      this->mtype = ty;
      this->msize = size;
/**/if(flag_verbose){
/**/fprintf(stderr, "NOTE(meetMallocStaticType): setting mtype/msize for ao = ");
/**/this->write_string_rep(stderr, true);
/**/fprintf(stderr, "   mtype = ");
/**/this->mtype->write_string_rep(stderr);
/**/fprintf(stderr, "   msize = %d\n", this->msize);
/**/}
      return;
    }
    if(this->mtype->equiv(*ty)){
      if(size < this->msize){
/**/fprintf(stderr, "NOTE(meetMallocStaticType): changing msize for ao = ");
/**/this->write_string_rep(stderr, true);
/**/fprintf(stderr, "   mtype = ");
/**/this->mtype->write_string_rep(stderr);
/**/fprintf(stderr, "   msize = %d -> %d\n", this->msize, size);
        this->msize = size;
      } //- else OK: same or greater size
      return;
    } else {
/**/fprintf(stderr, "WARNING(meetMallocStaticType): type mismatch; ao = ");
/**/this->write_string_rep(stderr, true);
/**/fprintf(stderr, "   oldty = ");
/**/mtype->write_string_rep(stderr);
/**/fprintf(stderr, "   newty = ");
/**/ty->write_string_rep(stderr);
/**/fprintf(stderr, "   newsize = %d\n", size);
      this->mtype = &TCtype::tcVoidType;
      this->msize = 0;
    }
  } else { //- unknown type/size
    if(this->mtype){
/**/fprintf(stderr, "NOTE(meetMallocStaticType): meet with void; ao = ");
/**/this->write_string_rep(stderr, true);
/**/fprintf(stderr, "   oldty = ");
/**/this->mtype->write_string_rep(stderr);
/**/fprintf(stderr, "   oldsize = %d\n", this->msize);
    }
    this->mtype = &TCtype::tcVoidType;
    this->msize = 0;
  }
}

void AO::setRequiredType(TCtype& ty)
{
  //-- For now, for struct/union objects, set to top
  //   Later: perhaps set types for aggregate components?
  if(ty.getKind() == TCtype::tcStruct || ty.getKind() == TCtype::tcUnion)
    reqdType = TClatType::tclTop;
  else if(ty.getKind() == TCtype::tcVoid) //- treat void as Top (only occurs for fn return nodes)
    reqdType = TClatType::tclTop;
  else
    reqdType = TClatType::Join(reqdType, TClatType::getLatKindFor(ty));
}

void AO::setVerifyPtrType(TCtype& ty) //- must consume ty
{
  if(!verifyPtrType){
    verifyPtrType = &ty;
  } else {
    if(!verifyPtrType->equiv(ty)){
      TCtype::deleteTy(ty); // cleanup
      TCtype::deleteTy(*verifyPtrType); //- cleanup also old vpty!
      verifyPtrType = &TCtype::tcVoidType; //-- set to "largest" type!?!
    } else {
      TCtype::deleteTy(ty); // cleanup
    }
  }
}

void AO::debug_dump(FILE * os)
{
  dump_descr(os);
  if(getTScode()) fprintf(os, "-tsl:%c-", getTScode());
  if(getTSCcode()) fprintf(os, "-tsc:%c-", getTSCcode());
  if(ecr){
    ECR& e = ecr->followECR();
    fprintf(os, "[ECR:%08x/poss-type:", (unsigned int)&e);
    e.possType().debug_dump(os);
    fprintf(os, "]");
  } else {
    fprintf(os, "[ECR:0]");
  }
  fprintf(os, "[reqd-type:");
  TClatType::Debug_dump(reqdType, os);
  fprintf(os, "]");
  if(staticType){
    fprintf(os, "[static-type:");
    staticType->debug_dump(os);
    fprintf(os, "]");
  }
}

//- sets tsl to UNSAFE, then
//  - propagate along assign edges
//  - propagate to all SDot and UDot children
//  - propagate to all Star children
//  - propagate to all Ext children
void AO::setTS_UNSAFE()
{
  if(tsl == TS_UNSAFE || isVal()) //- skip if done or if is value-AO
    return;
  tsl = TS_UNSAFE;

  //- propagate along assignment edges
  //  - note: if-condition above will prevent infinite cycling
  suco_iterator<TCassignEdge *> ei(this->getOutgoingAssignEdges());
  while(ei.Iterate())
    ei.Current()->getTo().setTS_UNSAFE();

  //- propagate to SDot, UDot, Star, and Ext children
  //  - note: no cycles to worry about
  for(AOlist::node * n = aolist.head; n; n = n->next){
    switch(n->ao.getKind()){
      case aoSDot:
      case aoUDot:
      case aoStar:
      case aoExt:
	n->ao.setTS_UNSAFE();
	break;
      default:
	;
    }
  }
}

void AO::setTSC(ts_categ c)
{
  if(c < tsc) tsc = c;
}

FILE * AO::aoWriteStream = 0;

void AO::writeTSlevel(AO& ao)
{
  char c = ao.getTScode();
  if(c && aoWriteStream) {
    fprintf(aoWriteStream, "~ %c %d ", c, ao.getECR().getEcrNo());
    ao.write_string_rep(aoWriteStream, flag_readable_output);
    fprintf(aoWriteStream, "\n");
  }
}

void AO::writeTScateg(AO& ao)
{
  char c = ao.getTSCcode();
  if(c && aoWriteStream) {
    fprintf(aoWriteStream, "~ %c %d ", c, ao.getECR().getEcrNo());

    //--if exposed, write exposed type?
//TODO

    ao.write_string_rep(aoWriteStream, flag_readable_output);
    fprintf(aoWriteStream, "\n");
  }
}

void AO::writeUntouchedExposed(AO& ao)
{
  if(aoWriteStream &&
	(ao.getTSC() == TSC_EXPOSED)){
    ECR& ecr = ao.getECR();
    if(!ecr.touched){
      fprintf(aoWriteStream, "_ %c ", ecr.touched?'T':'U');
      ao.write_string_rep(aoWriteStream, flag_readable_output);
      fprintf(aoWriteStream, "\n");
    }
  }
}

void AO::writeVulnerable(AO& ao)
{
  if(ao.isLoc() && ao.isVulnerableLoc()){
    fprintf(aoWriteStream, "V l ");
    ao.write_string_rep(aoWriteStream, flag_readable_output);
    fprintf(aoWriteStream, "\n");
  }
  if(ao.isRef() && ao.getECR().is_vuln_deref){
    fprintf(aoWriteStream, "V d ");
    ao.write_string_rep(aoWriteStream, flag_readable_output);
    fprintf(aoWriteStream, "\n");
  }
}

void AO::writeECR(AO& ao)
{
  if(aoWriteStream) {
    fprintf(aoWriteStream, "ECR for ");
    ao.debug_dump(aoWriteStream);
    fprintf(aoWriteStream, " : ");
    ao.getECR().debug_dump(aoWriteStream);
    fprintf(aoWriteStream, "\n");
  }
}

void AO::write_list_string_rep(FILE * os, suco_llist<AO *>& list, bool readable)
{
  suco_iterator<AO *> si(list);
  while(si.Iterate()){
    fprintf(os, ", ");
    si.Current()->write_string_rep(os, readable);
  }
  fprintf(os, ". ");
}

void AO::write_string_rep(FILE * os, bool readable)
{
  fprintf(os, "Z "); //- error: invalid object
}

//-NOTE: this function should be called only after
// pt-analysis is over and ECRs have been "finalized".
// Prior to that, use ECR::getECR().
ECR& AO::getECR()
{
  if(!this->ecr){
    fprintf(stderr, "FATAL ERROR(getECR): ao has no ECR!\n\t");
    this->dump_descr(stderr);
    fprintf(stderr, "\n");
    exit(1);
  }
  return *this->ecr;
}

void AO::assignEcrNosAndWriteToFile(AO& ao)
{
  if(ao.ecr)
    ao.getECR().getEcrNo(aoWriteStream);
}

char AO::getTScode()
{
  switch(tsl){
    case TS_SAFE:    return 'S';
    case TS_TRACKED: return 'T';
    case TS_UNSAFE:  return 'U';
    default:         return 0;
  }
}

AO::ts_categ AO::getSetTSC(suco_set<AO *>& set)
{
  ts_categ ret = TSC_SAFE;
  suco_iterator<AO *> si(set);
  while(si.Iterate()){
    ts_categ tsc = si.Current()->getTSC();
    if(tsc < ret) ret = tsc;
  }
  return ret;
}

char AO::getTSCcode()
{
  switch(tsc){
    case TSC_POSS_INVALID:	return 'P';
    case TSC_BADLY_TYPED:	return 'B';
    case TSC_INFLUENTIAL:	return 'I';
    case TSC_EXPOSED:		return 'E';
    case TSC_SAFE:		return 'S';
    default:		return 0;
  }
}

AO * AO::stringToAO(char * str, char ** nptr, IDmap& aidmap, IDmap& pidmap, AOlist& valueAOs)
{
  char * c = str;
  while(isspace(*c)) c++;
  switch(*c){
    case 'A': {
	AO * o = stringToAO(c+1, nptr, aidmap, pidmap, valueAOs);
	if(!o) return (fprintf(stderr, "Malformed addr-of object\n"), (AO*)0);
	else return &o->get_AOAddrOf();
      }
    case 'D': {
	AO * o = stringToAO(c+1, nptr, aidmap, pidmap, valueAOs);
	if(!o) return (fprintf(stderr, "Malformed deref object\n"), (AO*)0);
	else return &o->get_AOStar();
      }
    case 'E': {
	AO * o = stringToAO(c+1, &c, aidmap, pidmap, valueAOs);
	if(!o) return (fprintf(stderr, "Malformed extension object\n"), (AO*)0);
	TCtype * tty = TCtype::stringToTy(c,&c);
	TCtype * fty = TCtype::stringToTy(c,nptr);
	if(tty && fty) return &o->get_AOExt(*tty,*fty);
	else {
/**/fprintf(stderr, "LEAK(stringToAO): tty=");
/**/if(tty) tty->write_string_rep(stderr); else fprintf(stderr, "NULL");
/**/fprintf(stderr, " fty=");
/**/if(fty) fty->write_string_rep(stderr); else fprintf(stderr, "NULL");
/**/fprintf(stderr, "\n");
	  return 0;
	}
      }
    case 'F': {
	unsigned int argno = strtoul(c+1, &c, 10);
	AO * o = stringToAO(c, nptr, aidmap, pidmap, valueAOs);
	if(!o) return (fprintf(stderr, "Malformed function-arg object\n"), (AO*)0);
	return &o->get_or_create_AOArg(argno);
      }
    case 'I': {
	unsigned int pidno = strtoul(c+1, nptr, 10);
	ID * pid = pidmap.lookup(pidno);
	if(pid) return &pid->get_AOId();
	else return (fprintf(stderr, "Invalid Pid (%d) for identifier object\n", pidno), (AO*)0);
      }
    case 'L': {
	unsigned int aidno = strtoul(c+1, nptr, 10);
	ID * aid = aidmap.lookup(aidno);
	if(aid) return &aid->get_AOStringLit();
	else return (fprintf(stderr, "Invalid Aid (%d) for string literal\n", aidno), (AO*)0);
      }
    case 'M': {
	unsigned int aidno = strtoul(c+1, nptr, 10);
	ID * aid = aidmap.lookup(aidno);
	if(aid) return &aid->get_AOMalloc();
	else return (fprintf(stderr, "Invalid Aid (%d) for malloc object\n", aidno), (AO*)0);
      }
    case 'O': {
	AO * o = stringToAO(c+1, &c, aidmap, pidmap, valueAOs);
	if(!o) return (fprintf(stderr, "Malformed op-object\n"), (AO*)0);
	TCtype * ty = TCtype::stringToTy(c,nptr);
	if(ty) return &o->get_AOOp(*ty);
	else return 0;
      }
    case 'R': {
	AO * o = stringToAO(c+1, nptr, aidmap, pidmap, valueAOs);
	if(!o) return (fprintf(stderr, "Malformed function-return object\n"), (AO*)0);
	else return &o->get_AOReturn();
      }
    case 'S': {
	AO * o = stringToAO(c+1, &c, aidmap, pidmap, valueAOs);
	if(!o) return (fprintf(stderr, "Malformed struct-dot object\n"), (AO*)0);
	suco_llist<TCtype *>& tylist = TCtype::stringToTyList(c,nptr);
	return &o->get_or_create_AOSDot(tylist); //- needs to consume tylist
      }
    case 'U': {
	AO * o = stringToAO(c+1, &c, aidmap, pidmap, valueAOs);
	if(!o) return (fprintf(stderr, "Malformed union-dot object\n"), (AO*)0);
	TCtype * ty = TCtype::stringToTy(c,nptr);
	if(ty) return &o->get_or_create_AOUDot(*ty); //- needs to consume ty
	else return 0;
      }
    case 'V': {
	TCtype * ty = TCtype::stringToTy(c+1,nptr);
	if(ty) return &valueAOs.get_AOValue(*ty);
	else return (fprintf(stderr, "Malformed Value object\n"), (AO*)0);
      }
    case 'X': {
	AO * o = stringToAO(c+1, nptr, aidmap, pidmap, valueAOs);
	if(!o) return (fprintf(stderr, "Malformed function object\n"), (AO*)0);
	else return &o->get_AOFunction();
      }
//    case '$':
    default : return (fprintf(stderr, "Invalid object identifier (%c)\n", *c), (AO*)0);
  }
}

suco_llist<AO *>& AO::stringToAOlist(bool do_set, char * str, char ** nptr,
				IDmap& aidmap, IDmap& pidmap, AOlist& valueAOs)
{
  suco_llist<AO *>& ret =
		(do_set)?(*new suco_set<AO *>)
			:(*new suco_llist<AO *>);
  char * c = str;
  while(isspace(*c)) c++;
  while(*c == ','){
    AO * ao = stringToAO(c+1, &c, aidmap, pidmap, valueAOs);
    if(ao){
      if(do_set) ((suco_set<AO *>&)ret).Insert(ao);
      else ret.Append(ao);
    } else break;
    while(isspace(*c)) c++;
  }
  if(*c == '.') *nptr = c+1;
  else {
    fprintf(stderr, "Error encountered while reading AOlist.\n");
    *nptr = c;
  }
  return ret;
}

void AO::markVulnerableLocAndPropagate(const char * vuln_fn_name)
{
  if(this->isLoc() && !this->is_vuln_loc){
    this->is_vuln_loc = true;
    this->getECR().markVulnerableDerefAndPropagate();

    //- informational output
//    if(vuln_fn_name){
//      fprintf(stderr, "VULNSTAT(%s): ", vuln_fn_name);
//      this->write_string_rep(stderr, true);
//      fprintf(stderr, "\n");
//    }
  }
}

//- - - - - - - - - - - - - - - - - - - - - -

AOlist::node ** AO::findAO(AOlist::node ** np, aoKind k)
{
  for(; *np; np = &(*np)->next)
    if((*np)->ao.getKind() == k)
      break;
  return np;
}

AO& AOlist::get_AOValue(TCtype &t) //- deletes t if found
{
  node ** np = &head;
  for(; *np; np = &(*np)->next)
    if(((AOValue&)(*np)->ao).getTy().equals(t)){
      TCtype::deleteTy(t);
      return (*np)->ao;
    }
  *np = new node(*new AOValue(t));
  return (*np)->ao;
}

//- - - - - - - - - - - - - - - - - - - - - -

AO * AO::find(aoKind k)
{
  AOlist::node ** np = findAO(&aolist.head, k);
  if(*np) return &(*np)->ao;
  else return 0;
}

AO& AO::get_AOAddrOf()
{
  AOlist::node ** np = findAO(&aolist.head, aoAddrOf);
  if(!*np) *np = new AOlist::node(*new AOAddrOf(*this));
  return (*np)->ao;
}

AO& AO::get_AOFunction()
{
  AOlist::node ** np = findAO(&aolist.head, aoFunction);
  if(!*np) *np = new AOlist::node(*new AOFunction(*this));
  return (*np)->ao;
}

AO& AO::get_AOStar()
{
  AOlist::node ** np = findAO(&aolist.head, aoStar);
  if(!*np) *np = new AOlist::node(*new AOStar(*this));
  return (*np)->ao;
}

AO& AO::get_AOExt(TCtype& t, TCtype& f) //- deletes t,f if found
{
  AOlist::node ** np = findAO(&aolist.head, aoExt);
  while(*np){
    if(((AOExt&)(*np)->ao).getTty().equals(t)
	&& ((AOExt&)(*np)->ao).getFty().equals(f)){
      TCtype::deleteTy(t);
      TCtype::deleteTy(f);
      return (*np)->ao;
    }
    np = findAO(&(*np)->next, aoExt);
  }
  *np = new AOlist::node(*new AOExt(*this, t, f));
  return (*np)->ao;
}

AO& AO::get_AOOp(TCtype &t) //- deletes t if found
{
  AOlist::node ** np = findAO(&aolist.head, aoOp);
  while(*np){
    if(((AOOp&)(*np)->ao).getTy().equals(t)){
      TCtype::deleteTy(t);
      return (*np)->ao;
    }
    np = findAO(&(*np)->next, aoOp);
  }
  *np = new AOlist::node(*new AOOp(*this, t));
  return (*np)->ao;
}

AO& AO::get_AOReturn()
{
  AOlist::node ** np = findAO(&aolist.head, aoReturn);
  if(!*np) *np = new AOlist::node(*new AOReturn(*this));
  return (*np)->ao;
}

AO * AO::get_AOSDot(suco_llist<TCtype *>& l)
{
  AOlist::node * np = *findAO(&aolist.head, aoSDot);
  while(np){
    if(TCtype::listEquiv(((AOSDot&)np->ao).getTyList(), l)){
      return &np->ao;
    }
    np = *findAO(&np->next, aoSDot);
  }
  return 0;
}

AO * AO::get_AOUDot(TCtype &t)
{
  AOlist::node * np = *findAO(&aolist.head, aoUDot);
  while(np){
    if(((AOUDot&)np->ao).getTy().equiv(t)){
      return &np->ao;
    }
    np = *findAO(&np->next, aoUDot);
  }
  return 0;
}

AO * AO::get_AOArg(int n)
{
  AOlist::node ** np = findAO(&aolist.head, aoArg);
  while(*np){
    if(((AOArg&)(*np)->ao).argNo() == n)
      return &(*np)->ao;
    np = findAO(&(*np)->next, aoArg);
  }
  return 0;
}


AO& AO::get_or_create_AOSDot(suco_llist<TCtype *>& l, bool delty) //- deletes l if found
{
  AOlist::node ** np = findAO(&aolist.head, aoSDot);
  while(*np){
    if(TCtype::listEquiv(((AOSDot&)(*np)->ao).getTyList(), l)){
      if(delty) TCtype::deleteTyList(l);
      return (*np)->ao;
    }
    np = findAO(&(*np)->next, aoSDot);
  }
  AO& new_ao = *new AOSDot(*this, l);
  *np = new AOlist::node(new_ao);
  return (*np)->ao;
}

AO& AO::get_or_create_AOUDot(TCtype &t, bool delty) //- deletes t if found
{
  AOlist::node ** np = findAO(&aolist.head, aoUDot);
  while(*np){
    if(((AOUDot&)(*np)->ao).getTy().equiv(t)){
      if(delty) TCtype::deleteTy(t);
      return (*np)->ao;
    }
    np = findAO(&(*np)->next, aoUDot);
  }
  AO& new_ao = *new AOUDot(*this, t);
  *np = new AOlist::node(new_ao);
  return (*np)->ao;
}

AO& AO::get_or_create_AOArg(int n)
{
  AOlist::node ** np = findAO(&aolist.head, aoArg);
  while(*np){
    if(((AOArg&)(*np)->ao).argNo() == n)
      return (*np)->ao;
    np = findAO(&(*np)->next, aoArg);
  }
  *np = new AOlist::node(*new AOArg(*this, n));
  return (*np)->ao;
}

TCtype * AOReturn::getStaticType()
{
  if(AO::getStaticType()){
    return AO::getStaticType();
  } else {
    TCtype * fnty = this->getParent().getStaticType();
    if(fnty && fnty->getKind() == TCtype::tcFunction){
      return &((TCfunctionType *)fnty)->getReturnType();
    }
  }
  return 0;
}

//- - - - - - - - - - - - - - - - - - - - - -

void AOAddrOf::dump_descr(FILE * os)
{
  fprintf(os, "AOAddrOf(");
  ao.dump_descr(os);
  fprintf(os,")");
}

void AOFunction::dump_descr(FILE * os)
{
  fprintf(os, "AOFunction(");
  ao.dump_descr(os);
  fprintf(os,")");
}

void AOStar::dump_descr(FILE * os)
{
  fprintf(os, "AOStar(");
  ao.dump_descr(os);
  fprintf(os,")");
}

void AOExt::dump_descr(FILE * os)
{
  fprintf(os, "AOExt(");
  ao.dump_descr(os);
  fprintf(os,")[");
  tty.debug_dump(os);
  fprintf(os,"<-");
  fty.debug_dump(os);
  fprintf(os,"]");
}

void AOArg::dump_descr(FILE * os)
{
  fprintf(os, "AOArg[%d](", no);
  ao.dump_descr(os);
  fprintf(os,")");
}

void AOId::dump_descr(FILE * os)
{
  fprintf(os, "AOId(%d=[%s])", pid.getkey(), pid.getname());
}

void AOStringLit::dump_descr(FILE * os)
{
  fprintf(os, "AOStringLit(%d=[%s])", aid.getkey(), aid.getname());
}

void AOMalloc::dump_descr(FILE * os)
{
  fprintf(os, "AOMalloc(%d=[%s])", aid.getkey(), aid.getname());
}

void AOOp::dump_descr(FILE * os)
{
  fprintf(os, "AOOp(");
  ao.dump_descr(os);
  fprintf(os,")[");
  ty.debug_dump(os);
  fprintf(os,"]");
}

void AOReturn::dump_descr(FILE * os)
{
  fprintf(os, "AOReturn(");
  ao.dump_descr(os);
  fprintf(os,")");
}

void AOSDot::dump_descr(FILE * os)
{
  fprintf(os, "AOSDot(");
  ao.dump_descr(os);
  fprintf(os,")[");
  TCtype::debug_dump_list(tylist, os);
  fprintf(os,"]");
}

void AOUDot::dump_descr(FILE * os)
{
  fprintf(os, "AOUDot(");
  ao.dump_descr(os);
  fprintf(os,")[");
  ty.debug_dump(os);
  fprintf(os,"]");
}

void AOValue::dump_descr(FILE * os)
{
  fprintf(os, "AOValue[");
  ty.debug_dump(os);
  fprintf(os,"]");
}

//- - - - - - - - - - - - - - - - - - - - - -

void AOAddrOf::write_string_rep(FILE * os, bool readable)
{
  fprintf(os, "A ");
  ao.write_string_rep(os, readable);
}

void AOFunction::write_string_rep(FILE * os, bool readable)
{
  fprintf(os, "X ");
  ao.write_string_rep(os, readable);
}

void AOStar::write_string_rep(FILE * os, bool readable)
{
  fprintf(os, "D ");
  ao.write_string_rep(os, readable);
}

void AOExt::write_string_rep(FILE * os, bool readable)
{
  fprintf(os, "E ");
  ao.write_string_rep(os, readable);
  tty.write_string_rep(os);
  fty.write_string_rep(os);
}

void AOArg::write_string_rep(FILE * os, bool readable)
{
  fprintf(os, "F %d ", no);
  ao.write_string_rep(os, readable);
}

void AOId::write_string_rep(FILE * os, bool readable)
{
  if(readable){
    fprintf(os, "I[%s]:", pid.getname());
    if(getStaticType()){
      getStaticType()->write_string_rep(os);
    } else fprintf(os, "? ");
  } else {
    fprintf(os, "I %d ", pid.getkey());
  }
}

void AOStringLit::write_string_rep(FILE * os, bool readable)
{
  if(readable){
    fprintf(os, "L <%s> ", aid.getname());
    if(getStaticType()){
      fprintf(os, "[ty: ");
      getStaticType()->write_string_rep(os);
      fprintf(os, "] ");
    }
  } else {
    fprintf(os, "L %d ", aid.getkey());
  }
}

void AOMalloc::write_string_rep(FILE * os, bool readable)
{
  if(readable){
    fprintf(os, "M <%s> ", aid.getname());
    if(getStaticType()){
      fprintf(os, "[ty: ");
      getStaticType()->write_string_rep(os);
      fprintf(os, "] ");
    }
  } else {
    fprintf(os, "M %d ", aid.getkey());
  }
}

void AOOp::write_string_rep(FILE * os, bool readable)
{
  fprintf(os, "O ");
  ao.write_string_rep(os, readable);
  ty.write_string_rep(os);
}

void AOReturn::write_string_rep(FILE * os, bool readable)
{
  fprintf(os, "R ");
  ao.write_string_rep(os, readable);
}

void AOSDot::write_string_rep(FILE * os, bool readable)
{
  fprintf(os, "S ");
  ao.write_string_rep(os, readable);
  TCtype::write_list_string_rep(tylist, os);
  fprintf(os,"; ");
}

void AOUDot::write_string_rep(FILE * os, bool readable)
{
  fprintf(os, "U ");
  ao.write_string_rep(os, readable);
  ty.write_string_rep(os);
}

void AOValue::write_string_rep(FILE * os, bool readable)
{
  fprintf(os, "V ");
  ty.write_string_rep(os);
}

//------------------------------------------------------
@


1.75
log
@ADDED evaluation of each library function call to determine
if its target (where relevant) is exposed -- this will mainly
be used in -vulnw mode to remove instrumentation when a
function's target is exposed (needed to avoid false positive).
Eventually, it may also be used in -ptr/ptrw mode to remove
instrumentation when a library function's target is not
exposed -- though currently this never happens because of
context-insensitive analysis and overly-conservative models.
SUPPLEMENTAL CHANGES to achieve the above:
 1. Created ExposedStatus class in ao.cpp/ao.h (was previously
    an enum in AO class)
 2. Changed PExprcall::isDirectCall() to return the ID of the
    direct call, rather than just a bool.
 3. Exported "flag_readwrite" to become a global -- it's about
    time (I'd been misguidedly trying to avoid this for far
    too long, creating a bigger mess instead)
@
text
@d656 5
a660 5
    if(vuln_fn_name){
      fprintf(stderr, "VULNSTAT(%s): ", vuln_fn_name);
      this->write_string_rep(stderr, true);
      fprintf(stderr, "\n");
    }
@


1.74
log
@Changed vuln output to write_string_rep instead of
dump_descr (latter was _WAY_ too verbose)
@
text
@d47 46
a152 11
char AO::exposedCode(exposed_status es)
{
  switch(es){
    case esAll:   return 'A';
    case esSome:  return 'S';
    case esNone:  return 'N';
    case esNA:    return 'N';
  }
  return 'X';
}

d156 1
a156 1
AO::exposed_status AO::pointsToExposed(bool limit_malloc, bool do_touched, bool do_vuln)
d165 1
a165 1
  return esNA; //- SY: or should it be esNone?
@


1.73
log
@Added "/V" output (freearg status for vuln mode).
Entailed hackishly modifying ECR::inclToExposed().
@
text
@d623 1
a623 1
      this->dump_descr(stderr);
@


1.72
log
@MAJOR ADDITION: added -vuln mode computations to output
1. vulnerable locations (function pointers and first
   arguments to exec,system,longjmp,...)
2. vulnerable dereferences (any Ref ao that may point
   to a vulnerable location)
@
text
@d121 1
a121 1
AO::exposed_status AO::pointsToExposed(bool limit_malloc, bool do_touched)
d127 1
a127 1
      return e.getPointsTo().inclToExposed(limit_malloc, do_touched);
@


1.71
log
@Modified write_string_rep/readable format to de-highlight
type.
@
text
@d403 14
d612 15
@


1.70
log
@Added assignsFrom member, as needed to compute relevant aos.
@
text
@d914 1
a914 1
    fprintf(os, "I <%s> ", pid.getname());
a915 1
      fprintf(os, "[ty: ");
d917 1
a917 2
      fprintf(os, "] ");
    }
@


1.69
log
@FIXED VARARG HANDLING:
- to be compliant with new "finalizeECR" phase change
  model, I had to change AO::get_AOArg to possibly
  return null, and create new AO::get_or_create_AOArg
  for early use to construct AOArg objects as needed.
- the above change required more careful handling
  (in ran.cpp) of function call argument passing:
  specifically, at callsite fp(i,j,n) where fp
  points to foo(i), there will be only two AOArg
  objects created for foo (F X I foo i and l where
  l is "last argno/largno"), so we will do:
  - strong assign for actuals up to largno:
    F X I foo i <=strong= actual(i)
    F X I foo l <=strong= actual(j)
  - weak assign for actuals beyond that point:
    F X I foo l <=weak= actual(n)
  Note that this nicely handles varargs, where
  the ellipsis maps to largno.
@
text
@d64 2
a65 1
  if(assignsTo.Insert(newe)){
d339 1
a339 1
  suco_iterator<TCassignEdge *> ei(assignsTo);
@


1.68
log
@Changed AO/ECR relationship: added AO::getECR() function
that is to be called after pt-analysis finalization of
ECRs -- so, PRIOR to finalization, must use ECR::getECR()
(as is now done in pta.cpp), but AFTER, must only use
AO::getECR() which outputs a fatal error message if ECR
not found.
@
text
@d207 12
d515 1
a515 1
	return &o->get_AOArg(argno);
a666 12
AO& AO::get_AOArg(int n)
{
  AOlist::node ** np = findAO(&aolist.head, aoArg);
  while(*np){
    if(((AOArg&)(*np)->ao).argNo() == n)
      return (*np)->ao;
    np = findAO(&(*np)->next, aoArg);
  }
  *np = new AOlist::node(*new AOArg(*this, n));
  return (*np)->ao;
}

d712 12
d751 12
@


1.67
log
@Minor diagnostic adjustments.
@
text
@d3 1
a3 1
#include <stdlib.h> // for strtoul
d357 1
a357 1
    fprintf(aoWriteStream, "~ %c %d ", c, ao.getEcrNo());
d367 1
a367 1
    fprintf(aoWriteStream, "~ %c %d ", c, ao.getEcrNo());
d381 1
a381 1
    ECR& ecr = ECR::getECR(ao);
d396 1
a396 1
    ECR::getECR(ao).debug_dump(aoWriteStream);
d416 15
a430 1
void AO::assignEcrNos(AO& ao)
d433 1
a433 1
    ECR::getECR(ao).getEcrNo(aoWriteStream);
a466 8
}

int AO::getEcrNo()
{
  if(ecr){
    ECR& e = ECR::getECR(*this);
    return e.getEcrNo();
  } else return 0;
@


1.66
log
@Fixed memory leak in setStaticType and setVerifyPtrType.
@
text
@d484 8
a491 1
	else return 0;
d533 1
a533 1
	return &o->get_or_create_AOSDot(tylist); //-need to destruct tylist, if not used
d539 1
a539 1
	if(ty) return &o->get_or_create_AOUDot(*ty);
@


1.65
log
@Removed some diagnostic output; verbose-guarded others;
k-limited yet others.
@
text
@d175 1
a175 1
void AO::setStaticType(TCtype& ty)
d181 2
a182 1
  } else if(!staticType->equiv(ty)){
d187 1
d199 5
d275 1
a275 1
void AO::setVerifyPtrType(TCtype& ty)
d277 10
a286 3
  if(!verifyPtrType) verifyPtrType = &ty;
  else if(!verifyPtrType->equiv(ty)){
    verifyPtrType = &TCtype::tcVoidType; //-- set to "largest" type!?!
@


1.64
log
@Added [-no]-inst-fields option to turn off
instantiation of all struct/union member AOs
at declaration point.
Originally did this to circumvent explosion in
mesa which has some huge structures -- but as
I think about it, leaving this feature off by
default should still get correct results!?!
@
text
@d213 1
d219 1
@


1.63
log
@Fixed bug in previous fix.
@
text
@d179 2
a180 1
    this->instantiateStructUnionMembers(); //- should only be called for Loc or ArgRet objects
@


1.62
log
@Fixed diagnostic output messages for AO::meetMallocStaticType().
@
text
@d241 1
d247 1
@


1.61
log
@Added Malloc arg-evaluation mechanism:

- RAN: added evalSizeOfExpr() and evalMallocSize();
- AOMalloc: added mtype/msize members, and meetMallocStaticType()
  function to set those at each MallocDecl node;
- Interval::setTgt now checks for AOMalloc, and uses its
  mtype/msize members to set tgt_ty/tgt_numelts;
- Interval addedisNullTgted() helper;
@
text
@d201 2
d241 1
a241 2
    if(this->mtype && this->mtype->getKind() != TCtype::tcVoid){
/**/fprintf(stderr, "ERROR(meetMallocStaticType): meet with void; ao = ");
a245 1
    }
@


1.60
log
@Semi-bug fix: remember that function return node is
represented by R F I <fn> not R I <fn>, which was
not the case, so I've fixed it throughout (occurs
mainly in handleReturnStmt() in the various analyses).

Also, added AOReturn::getStaticType() as a separate
function to look up the underlying function's return
type if staticType is not set;
added TCfunctionType::getReturnType() accessor to
assist.
@
text
@d199 52
@


1.59
log
@Quick bug fix: Append instead of Insert in
instantiateStructUnionMembers().
@
text
@d658 13
@


1.58
log
@Changed the whole AO::get_AO[SU]Dot mechanism -- now
split into two sets of functions:
 - get_or_create_AO[SU]Dot() is AO-protected, and is
   called to get, or create if not found, and follows
   the old semantics of get_AO[SU]Dot (deleting the
   type if found, etc).
 - get_AO[SU]Dot() not returns a pointer, and returns
   null if not found.

So now, interval calls the public version which may
return null; cascadingly, Interval::adjustStructOffset
no longer consumes tylist -- the consumption is now
taken care of by the RAN callsites.
@
text
@a148 1

d157 1
a157 1
            tylist->Insert(ty);
@


1.57
log
@Changed behavior of AO::setStaticType() so that if the
type is a struct or union or array of (array of) struct
or union, then instantiate all constituent AOSDot/AOUDot
members, as they will all be used for struct assignments
(in RAN analysis, at least).
Entailed addition of instantiateStructUnionMembers helper
function.

Also, modified get_AOSDot() and get_AOUDot() to take a
flag indicating whether the type/typelist passed in as
argument should be deleted on failure.
@
text
@d134 1
a134 1
//~ Note: must duplicate tylist, because get_AOSDot may consume it.
d147 1
a147 1
        AO& sao = this->get_AOSDot(*tylist, false); //- cannot deleteTyList: sometimes can only delete the list, not its constituent types!
d169 1
a169 1
        AO& uao = this->get_AOUDot(*tli.Current(), false);
d456 1
a456 1
	return &o->get_AOSDot(tylist); //-need to destruct tylist, if not used
d462 1
a462 1
	if(ty) return &o->get_AOUDot(*ty);
d605 25
a629 1
AO& AO::get_AOSDot(suco_llist<TCtype *>& l, bool delty) //- deletes l if found
a640 5
  //-- NOTE: if this has ECR, then assign new_ao to same ECR
  //   (needed? by range analysis, where new members may be instantiated after the pt-analysis)
  if(this->ecr){
    ECR::unifyECRs(*this,new_ao); //- NOTE: MAY NOT BE A SAFE PLACE TO CALL unifyECR!!
  }
d644 1
a644 1
AO& AO::get_AOUDot(TCtype &t, bool delty) //- deletes t if found
a655 5
  //-- NOTE: if this has ECR, then assign new_ao to same ECR
  //   (needed? by range analysis, where new members may be instantiated after the pt-analysis)
  if(this->ecr){
    ECR::unifyECRs(*this,new_ao); //- NOTE: MAY NOT BE A SAFE PLACE TO CALL unifyECR!!
  }
@


1.56
log
@Added mechanism to report static RAN-count of
direct-array accesses (all, and in-bounds only).
Entailed adding AO::isDirectArrayAccess() helper
funciton; a couple of counting helpers in
RANcFactHandler, and a place to store the
results in TCAstate.
@
text
@d132 44
d178 4
a181 2
  if(!staticType) staticType = &ty;
  else if(!staticType->equiv(ty)){
d605 1
a605 1
AO& AO::get_AOSDot(suco_llist<TCtype *>& l) //- deletes l if found
d610 1
a610 1
      TCtype::deleteTyList(l);
d625 1
a625 1
AO& AO::get_AOUDot(TCtype &t) //- deletes t if found
d630 1
a630 1
      TCtype::deleteTy(t);
@


1.55
log
@Collecting RAN stats (all-vps, finite-vps, half-finite-vps, inbounds-vps,
known-preds):
 - RAN replaced checkInBounds() with getDerefRangeFor()
 - added reportKnownPredicate() helper to RAN[c]factHandler
 - added list accumulators to RANcFactHandler
 - added count holders to TCAstate

Interval::isTop() - now returns true of min > max!
(was returning only if min = +inf, max = -inf!)

Interval: added "modulo" to compute %.

AO::get_AOUDot/get_AOSDot() - unify ecr if called after pt-analysis.
@
text
@d72 34
@


1.54
log
@Changed AO::write_string_rep and write_list_string_rep
to take a "readable" flag.
So now, flag_readable_output only affects the parts intended
for machine-reading by sml; the other auxiliary output
(e.g. via debug_dump, or for longjmp targets) will be
always readable.
@
text
@d535 7
a541 1
  *np = new AOlist::node(*new AOSDot(*this, l));
d555 7
a561 1
  *np = new AOlist::node(*new AOUDot(*this, t));
@


1.53
log
@Previously, setStaticType had a funny behavior of setting
to tcZero when the types clash.
Now, it (unsoundly) sticks with the first occurrence;
and reports a warning if it's not a function or arg
or return AO.
TODO: sml needs to differentiate between explicit decls
and implicits/externs.
@
text
@d208 1
a208 1
    ao.write_string_rep(aoWriteStream);
d222 1
a222 1
    ao.write_string_rep(aoWriteStream);
d234 1
a234 1
      ao.write_string_rep(aoWriteStream);
d251 1
a251 1
void AO::write_list_string_rep(FILE * os, suco_llist<AO *>& list)
d256 1
a256 1
    si.Current()->write_string_rep(os);
d261 1
a261 1
void AO::write_string_rep(FILE * os)
d652 1
a652 1
void AOAddrOf::write_string_rep(FILE * os)
d655 1
a655 1
  ao.write_string_rep(os);
d658 1
a658 1
void AOFunction::write_string_rep(FILE * os)
d661 1
a661 1
  ao.write_string_rep(os);
d664 1
a664 1
void AOStar::write_string_rep(FILE * os)
d667 1
a667 1
  ao.write_string_rep(os);
d670 1
a670 1
void AOExt::write_string_rep(FILE * os)
d673 1
a673 1
  ao.write_string_rep(os);
d678 1
a678 1
void AOArg::write_string_rep(FILE * os)
d681 1
a681 1
  ao.write_string_rep(os);
d684 1
a684 1
void AOId::write_string_rep(FILE * os)
d686 1
a686 1
  if(flag_readable_output){
d698 1
a698 1
void AOStringLit::write_string_rep(FILE * os)
d700 1
a700 1
  if(flag_readable_output){
d712 1
a712 1
void AOMalloc::write_string_rep(FILE * os)
d714 1
a714 1
  if(flag_readable_output){
d726 1
a726 1
void AOOp::write_string_rep(FILE * os)
d729 1
a729 1
  ao.write_string_rep(os);
d733 1
a733 1
void AOReturn::write_string_rep(FILE * os)
d736 1
a736 1
  ao.write_string_rep(os);
d739 1
a739 1
void AOSDot::write_string_rep(FILE * os)
d742 1
a742 1
  ao.write_string_rep(os);
d747 1
a747 1
void AOUDot::write_string_rep(FILE * os)
d750 1
a750 1
  ao.write_string_rep(os);
d754 1
a754 1
void AOValue::write_string_rep(FILE * os)
@


1.52
log
@Added deleteTyList() destructor function, which deleteTy()s
each component TCtype before destructing itself.
Note that unlike deleteTy(), the lack of protected
destructor for suco_llist<TCtype *> means the type system
cannot require the use of this function.
@
text
@d102 15
a116 1
    staticType = &TCtype::tcZeroType; //-- set to TOP!?!
@


1.51
log
@Semimajor change: eliminated TCtypeList class; replaced
with suco_llist<TCtype *>.
The only semantic change is that destruction is not
recursive, so a lot of leakage is likely.
(Next change: devise a single-representative storage?
)
@
text
@d516 1
a516 1
      delete &l;
d525 1
a525 1
AO& AO::get_AOUDot(TCtype &t) //- deletes l if found
@


1.50
log
@Major Change: ExpDescr estr augmented Sub(B)
and plus/minus to include elty; further,
remapped plus/minus to new representations:

  Sub:   B(e1,e2)   -> B(e1,e2,elty)
  Binop: o+(e1,e2)  -> p+(e1,e2,elty)
         o-(e1,e2)  -> p-(e1,e2,elty)
         O+=(e1,e2) -> p#(e1,e2,elty)
         O-=(e1,e2) -> p=(e1,e2,elty)
  Unop:  U+<(e)     -> U+<(e,elty)
         U+>(e)     -> U+>(e,elty)
         U-<(e)     -> U-<(e,elty)
         U->(e)     -> U->(e,elty)

For plain (non-pointer) arithmetic, elty = tcVoid.

NOT YET DONE: change body of Interval.plus/minus
to account for elty.

Auxiliary change: Interval::deleteTy now takes
a reference rather than a pointer.
@
text
@d361 1
a361 1
	TCtypeList &tylist = TCtypeList::stringToTyList(c,nptr);
d511 1
a511 1
AO& AO::get_AOSDot(TCtypeList &l) //- deletes l if found
d515 1
a515 1
    if(((AOSDot&)(*np)->ao).getTyList().equiv(l)){
d616 1
a616 1
  tylist.debug_dump(os);
d729 1
a729 1
  tylist.write_string_rep(os);
@


1.49
log
@Deleted obsolete function lvalType()
-- can't remember now what it was used for.
@
text
@d425 1
a425 1
      TCtype::deleteTy(&t);
d468 2
a469 2
      TCtype::deleteTy(&t);
      TCtype::deleteTy(&f);
d495 1
a495 1
      TCtype::deleteTy(&t);
d530 1
a530 1
      TCtype::deleteTy(&t);
@


1.48
log
@REMOVED:
 - eltype/numelts components of aoMalloc -- new implementation
        now uses setStaticType mechanism to convey this information,
        which is a  better solution that this previous unclean
        approach
   - note that as a result, Interval::setTgt() is now greatly
        simplified, since all objects (from array aoIds to
        aoMallocs to aoStringLits can now be treated uniformly
        by just getting info from the staticType).
FIXED:
 - in CFG::read, I previously had a filter to make sure the
        globnodes (initializer nodes) are either mStaticDecl
        or mAssign; but with change to initializer behavior
        that PARALLEL-izes aggregate initializations, this
        constraint no longer makes sense; in fact I just
        removed the filter altogether, so that globnodes can
        now contain _any_ kind of PgmExpr.
@
text
@a71 42
TCtype& AO::lvalType()
{
  switch(getKind()){
    case aoId:
    case aoFunction:
    case aoReturn:
    case aoArg:
      if(staticType) return *staticType;
      else return TCtype::tcVoidType;

    case aoMalloc:
      return TCtype::tcVoidType;

    case aoStringLit:
      return TCtype::tcCharType;

    case aoSDot:
      if(staticType){
        //AOSDot& sao = *((AOSDot *)this);
//- TODO: verify staticType is Struct and compatible w/ sdot tylist
        return TCtype::tcVoidType;
      } else {
        return TCtype::tcVoidType;
      }

    case aoUDot:
      if(staticType){
        //AOUDot& uao = *((AOUDot *)this);
//- union lower in type lattice than individuals?
//- TODO: verify staticType is union...
        return *staticType;
      } else {
        return TCtype::tcVoidType;
      }

    case aoStar:
      return TCtype::tcVoidType;
    default:
      return TCtype::tcVoidType;
  }
}

@


1.47
log
@1. Changed AOMalloc representation to include <eltype, numelts>
   (previously had single <size> field)
2. Changed Interval to store <eltype, numelts> rather than AO
   as "target" field: potentially allows for "smarter" range
   analysis per Susan's suggestion.
(Added runtime flag -ran-[no-]malloc to turn on/off handling
 of malloc objects, now on by default)
TODO: account for elty in Interval::plus/minus (added signature,
      but not yet implemented)
@
text
@d634 1
a634 7
  fprintf(os, "AOMalloc(%d=[%s]", aid.getkey(), aid.getname());
  if(eltype){
    fprintf(os, ",eltype=");
    eltype->debug_dump(os);
    fprintf(os, ",numelts=%d)", numelts);
  }
  fprintf(os, ")");
d714 1
a714 1
  if(flag_readable_output)
d716 6
a721 1
  else
d723 1
d728 1
a728 1
  if(flag_readable_output)
d730 6
a735 1
  else
d737 1
d743 5
a747 5
    fprintf(os, "M <%s>", aid.getname());
    if(eltype){
      fprintf(os, " (eltype=");
      eltype->write_string_rep(os);
      fprintf(os, ",numelts=%d)", numelts);
@


1.46
log
@Augmented malloc declaration to include size component, which is a result
of trying to compute a constant size from the expression.
NOTE: there's some trouble with determining the value of sizeof, so for now
**sizeof expressions are evaluated to the value -1** as an indicator for
diagnostic purposes.  IOW, the malloc-size value currently generated SHOULD
NOT BE USED DIRECTLY (should be safe anyways, as long as we're conscious
that a negative size means something is amiss).

The size is currently stored in AOMalloc objects, but not yet used.
@
text
@d634 7
a640 1
  fprintf(os, "AOMalloc(%d=[%s],size=%d)", aid.getkey(), aid.getname(), size);
d736 8
a743 3
  if(flag_readable_output)
    fprintf(os, "M <%s> (size=%d)", aid.getname(), size);
  else
d745 1
@


1.45
log
@1. Adjustment to "_" (untouched exposed aos) behavior: reports only
   one status, rather than a separate status for ptr/ptrw as was done
   before.  This is because the tsl analysis is already dependent on
   ptr/ptrw-ness, so it makes no sense to report both when doing one
   particular analysis.
   Involved change to ECR class definition (used to have two booleans
   touched_ptr/touched_ptrw; now just one).

2. Updated "/" (freearg) to account for untouched-ness: by adding
   a flag to AO::pointsToExposed/ECR::inclToExposed saying whether
   or not to check the touched flag.
@
text
@d634 1
a634 1
  fprintf(os, "AOMalloc(%d=[%s])", aid.getkey(), aid.getname());
d731 1
a731 1
    fprintf(os, "M <%s> ", aid.getname());
@


1.44
log
@1. Added code to find untouched exposed locations (so they
   can be unexposed/untracked):
   - in ECR, added members touched_ptr, touched_ptrw
   - in RANc(FactHandler), for each Verify, touch the
     affected ECRs
   - at the end, traverse all AOs, and for each EXPOSED
     ao that's untouched, output a "_ [T|U] [T|U] <O>"
     line (T=touched, U=untouched; 1st=ptr, 2nd=ptrw).
   - (sml code has concurrently been modified to read
     those lines and treat <O> as SAFE when untouched)
2. Behavioral change: -cde-incl and -cde-pt are now
   on by default!
@
text
@d128 1
a128 1
AO::exposed_status AO::pointsToExposed(bool limit_malloc)
d134 1
a134 1
      return e.getPointsTo().inclToExposed(limit_malloc);
d260 2
a261 3
    if((!ecr.touched_ptr) || (!ecr.touched_ptrw)){
      fprintf(aoWriteStream, "_ %c %c ", ecr.touched_ptr?'T':'U',
					 ecr.touched_ptrw?'T':'U');
@


1.43
log
@Gave the code the -Wall treatment: adjusted things to
get rid of warnings:
 - reordered initializers to match declaration order
 - made some destructors virtual (note that for many
   classes with no explicit destructors, I did not
   add explicit virtual destructors, so -Wall warnings
   remain)
 - made some signed/unsigned casts
 - made some pointer/unsigned int casts for printfs
 - filled in unaccounted-for cases in switch statements
@
text
@d255 14
@


1.42
log
@Small bug fix: added default return value to AO::pointsToExposed().
@
text
@d90 1
a90 1
        AOSDot& sao = *((AOSDot *)this);
d99 1
a99 1
        AOUDot& uao = *((AOUDot *)this);
d175 1
a175 1
    fprintf(os, "[ECR:%08x/poss-type:", &e);
@


1.41
log
@Added -cde-incl and -cde-pt flags -- only the latter
has been implemented: in ECR::includesTo, check for
cycle, and collapse these ECRs; also, remove redundant
inclTo/inclFrom edges as a result of the collapse.
Also, the output for -pta mode has been modified to
be more a summary, to allow better comparison between differnet
versions.
@
text
@d137 1
@


1.40
log
@Changed affloc from a set to a list -- this is because
of the change in estr representation, with IDs represented
by a placeholder "V" (no more "V(#)"), and the affloc list
storing the aoIds in "V" left-to-right order!
Note -- made some hack-ish adjustments to some ao functions
to avoid repetition by multiplexing between set and list
mode -- kinda ugly, though!
@
text
@a229 7
bool AO::writeAO(AO& ao)
{
  ao.debug_dump(aoWriteStream);
  fprintf(aoWriteStream, "\n");
  return true; //- true ensures full ECR traversal
}

@


1.39
log
@Reorganized global flags, stat-collection and output;
moved TCcollectStats to diag.cpp/h, renamed to TCstats,
and absorbed what used to be in diag.cpp/h.
Global flags have been moved to flags.h, (they're defined
in tca.cpp, for now).
Removed the -stat flag: the "stat" output is now always
dumped, to the output file rather than stderr.
Added -mbu# flag, though haven't done anything with the
different mbu levels yet.
@
text
@d272 1
a272 1
void AO::write_set_string_rep(FILE * os, suco_set<AO *>& set)
d274 1
a274 1
  suco_iterator<AO *> si(set);
d421 2
a422 2
suco_set<AO *>& AO::stringToAOset(char * str, char ** nptr,
                                IDmap& aidmap, IDmap& pidmap, AOlist& valueAOs)
d424 3
a426 1
  suco_set<AO *>& ret = *new suco_set<AO *>;
d431 4
a434 2
    if(ao) ret.Insert(ao);
    else break;
@


1.38
log
@CFG: wrote MBUfacts test for intersection between a MBUfact
and an AOset's alias set (done using ECR::traverseAliases).
Cascaded changes to AO/ECR include:
1. AO::ts_categ is now explicitly enumerated to allow >=
   comparison
2. ECR::traverseAliases now takes bool functions, and
   returns a bool, true if all applications return true,
   and false if *any* application returns false (and also
   halts traversal -- this is an optimization for the
   intersection check added: once an intersection is found,
   no further traversal is needed).
@
text
@d6 1
a6 1
#include "diag.h"
@


1.37
log
@Reduced scope of AOlist class: this is only to be used
specially within the AO tree to look up AOs.
All other occurrences (in ecr, cfg, etc) have been converted
to use suco_set<AO *>.
Should be no change in behavior.
@
text
@d230 1
a230 1
void AO::writeAO(AO& ao)
d234 1
d301 11
@


1.36
log
@Augmented cfg DFfacts with references to AOs;
the respective read functions call AO::stringToAOs,
which requires the pidmap and aidmap arguments from tca,
so a new class InputState was created (in tca.h) to
pass these around conveniently.
Also, added another helper function AO::stringToAOlist
to read in lists of AOs, separated by ',', terminated by
'.'.
@
text
@d18 1
a18 1
    if(delete_ao) delete &del->ao;
a22 29
void AOlist::insert(AO& ao)
{
  node ** np;
  for(np = &head; *np; np = &(*np)->next)
    if(&(*np)->ao == &ao)
      return;
  *np = new node(ao);
}

void AOlist::remove(AO& ao)
{
  node ** np;
  for(np = &head; *np; np = &(*np)->next)
    if(&(*np)->ao == &ao){
      node * del = *np;
      *np = (*np)->next;
      delete del;
      return;
    }
}

void AOlist::concatenate(AOlist& list)
{
  node ** tail;
  for(tail = &head; *tail; tail = &(*tail)->next);
  *tail = list.head;
  list.head = 0; //- just to avoid multiple references
}

a33 9
void AOlist::write_string_rep(FILE * os)
{
  for(node * n = head; n; n = n->next){
    fprintf(os, ", ");
    n->ao.write_string_rep(os);
  }
  fprintf(os, ". ");
}

a46 15
//- AOlistIterator

bool AOlistIterator::iterate()
{
  if(initial) initial = false;
  else if(nptr) nptr = nptr->next;
  return (nptr != 0);
}

AO * AOlistIterator::current()
{
  return nptr?(&nptr->ao):(AO*)0;
}

//------------------------------------------------------
d138 1
a138 12
/*
void AO::pointsToExposed(exposed_status &es_allaos, exposed_status &es_malloc)
{
  if(ecr){
    ECR& e = ecr->followECR();
    if(e.ptsTo){
      ECR::traverseCounter++;
      e.getPointsTo().inclToExposed(es_allaos, es_malloc);
    } //- else, no points-to, leave alone
  } //- else, no ecr, leave alone
}
*/
d271 10
d409 2
a410 2
AOlist& AO::stringToAOlist(char * str, char ** nptr,
				IDmap& aidmap, IDmap& pidmap, AOlist& valueAOs)
d412 1
a412 1
  AOlist& ret = *new AOlist;
d417 1
a417 1
    if(ao) ret.insert(*ao);
@


1.35
log
@Added freearg handling: for each assignment to the first
argument of free, check to see if the argument points to
none, some, or all exposed objects -- with current implementation
it is sufficient to check the exposed flag of the corresponding
ECR objects (but must still follow inclTo edges).
Note -- attributes for two policies are computed, one considering
all AOs, another considering only Malloc AOs. The latter is unsafe
(but "usually safe", one would hope), but likely more efficient.
Output is "/ A M O" where A is the status for all AOs, M for malloc
AOs only, and O the AO in question.
@
text
@d63 9
d461 20
a480 1
  return 0;
@


1.34
log
@Removed aoArray object.
@
text
@d158 36
@


1.33
log
@Added mechanism to collect stats about safe/unsafe tracked/untracked
pointer/fnptr/ptrs-in-structs/locations; involved various new additions
(including 'f' defined-function directive from instr-ast.sml)
@
text
@a119 1
    case aoArray:
a412 5
    case 'Y': {
	AO * o = stringToAO(c+1, nptr, aidmap, pidmap, valueAOs);
	if(!o) return (fprintf(stderr, "Malformed array object\n"), (AO*)0);
	else return &o->get_AOArray();
      }
a456 7
AO& AO::get_AOArray()
{
  AOlist::node ** np = findAO(&aolist.head, aoArray);
  if(!*np) *np = new AOlist::node(*new AOArray(*this));
  return (*np)->ao;
}

a556 7
void AOArray::dump_descr(FILE * os)
{
  fprintf(os, "AOArray(");
  ao.dump_descr(os);
  fprintf(os,")");
}

a649 6
  ao.write_string_rep(os);
}

void AOArray::write_string_rep(FILE * os)
{
  fprintf(os, "Y ");
@


1.32
log
@Wrote -ptrw version, which only propagates exposed and
influential from assigned-to invalid AOs.
@
text
@d449 7
a481 7
}

AO * AO::find_AOStar()
{
  AOlist::node ** np = findAO(&aolist.head, aoStar);
  if(*np) return &(*np)->ao;
  else return 0;
@


1.31
log
@Added vargno handling:
Each AO now has a vargno argument, which if nonzero indicates
a vararg function. This is set by the new "v" directive from
tc-assign. When an AO has a non-zero vargno, we merge the ECRs
of all argret nodes from vargno up to maxnargs.
NOTE: may want to reimplement better: make vargno an argument
of only aoFunction...
@
text
@d106 1
@


1.30
log
@debug_dump now also outputs TSL/TSC
@
text
@d364 1
a364 1
	else return (fprintf(stderr, "Invalid Pid for identifier object\n"), (AO*)0);
d370 1
a370 1
	else return (fprintf(stderr, "Invalid Aid for string literal\n"), (AO*)0);
d376 1
a376 1
	else return (fprintf(stderr, "Invalid Aid for malloc object\n"), (AO*)0);
@


1.29
log
@Major Revision: include ECR number and incl-to edges in output.
@
text
@d189 2
@


1.28
log
@Fixed minor "-readable" bug, which was outputing
strlit and malloc object names as $d rather than %s.
@
text
@d257 1
a257 1
    fprintf(aoWriteStream, "~ %c ", c);
d267 1
a267 1
    fprintf(aoWriteStream, "~ %c ", c);
d293 6
d319 8
@


1.27
log
@Added Type-safety Category assignment.
(major change).
Appears working, tested on gcc, verified on small examples,
not thoroughly verified.
Also, added -readable flag.
@
text
@d699 1
a699 1
    fprintf(os, "L <%d> ", aid.getname());
d707 1
a707 1
    fprintf(os, "M <%d> ", aid.getname());
@


1.26
log
@Fixed oversight in applyAssignConstraint -- was not propagating down
inclusion edges.
Added STAT debug output, etc.
@
text
@d6 1
a92 33
//- sets tsl to UNSAFE, then
//  - propagate along assign edges
//  - propagate to all SDot and UDot children
//  - propagate to all Star children
//  - propagate to all Ext children
void AO::setTS_UNSAFE()
{
  if(tsl == TS_UNSAFE || isVal()) //- skip if done or if is value-AO
    return;
  tsl = TS_UNSAFE;

  //- propagate along assignment edges
  //  - note: if-condition above will prevent infinite cycling
  suco_iterator<TCassignEdge *> ei(assignsTo);
  while(ei.Iterate())
    ei.Current()->getTo().setTS_UNSAFE();

  //- propagate to SDot, UDot, Star, and Ext children
  //  - note: no cycles to worry about
  for(AOlist::node * n = aolist.head; n; n = n->next){
    switch(n->ao.getKind()){
      case aoSDot:
      case aoUDot:
      case aoStar:
      case aoExt:
	n->ao.setTS_UNSAFE();
	break;
      default:
	;
    }
  }
}

d207 38
d263 14
d303 12
d690 4
a693 1
  fprintf(os, "I %d ", pid.getkey());
d698 4
a701 1
  fprintf(os, "L %d ", aid.getkey());
d706 4
a709 1
  fprintf(os, "M %d ", aid.getkey());
@


1.25
log
@Added setting of required-types:
 - file interface now delivers two kinds of assignment edges:
   "true" ('=') and "pseudo" ('-'), the latter for function
   and array object assignments as well as void return assignments.
 - added to AO reqdType member, which is just an enum;
   modified TClatType meet/join functions to work directly on
   enums;
The setting of required types is done:
 1. on file input, for each typed-true-assignment and verify-tag
 2. during arg/ret assignment adding
Finally, AO's debug_dump function has been modified to supply
more diagnostic information; this entailed the renaming of
the virtual portion of the function to dump_descr.
@
text
@d207 1
a207 1
    reqdType = TClatType::Join(reqdType, TClatType::getKind(ty));
d221 9
a229 1
  fprintf(os, "[ECR:%08x][reqd-type:", (ecr)?(&ecr->followECR()):0);
@


1.24
log
@Added routine to mark dereference nodes.
@
text
@d198 1
a198 1
void AO::setVerifyTagType(TCtype& ty)
d200 8
a207 4
  if(!verifyTagType) verifyTagType = &ty;
  else if(!verifyTagType->equiv(ty)){
    verifyTagType = &TCtype::tcZeroType; //-- set to TOP!?!
  }
d220 9
a228 1
  fprintf(os, "AO::debug_dump");
d506 1
a506 1
void AOAddrOf::debug_dump(FILE * os)
d509 1
a509 1
  ao.debug_dump(os);
d513 1
a513 1
void AOArray::debug_dump(FILE * os)
d516 1
a516 1
  ao.debug_dump(os);
d520 1
a520 1
void AOFunction::debug_dump(FILE * os)
d523 1
a523 1
  ao.debug_dump(os);
d527 1
a527 1
void AOStar::debug_dump(FILE * os)
d530 1
a530 1
  ao.debug_dump(os);
d534 1
a534 1
void AOExt::debug_dump(FILE * os)
d537 1
a537 1
  ao.debug_dump(os);
d545 1
a545 1
void AOArg::debug_dump(FILE * os)
d548 1
a548 1
  ao.debug_dump(os);
d552 1
a552 1
void AOId::debug_dump(FILE * os)
d557 1
a557 1
void AOStringLit::debug_dump(FILE * os)
d562 1
a562 1
void AOMalloc::debug_dump(FILE * os)
d567 1
a567 1
void AOOp::debug_dump(FILE * os)
d570 1
a570 1
  ao.debug_dump(os);
d576 1
a576 1
void AOReturn::debug_dump(FILE * os)
d579 1
a579 1
  ao.debug_dump(os);
d583 1
a583 1
void AOSDot::debug_dump(FILE * os)
d586 1
a586 1
  ao.debug_dump(os);
d592 1
a592 1
void AOUDot::debug_dump(FILE * os)
d595 1
a595 1
  ao.debug_dump(os);
d601 1
a601 1
void AOValue::debug_dump(FILE * os)
@


1.23
log
@Renamed TCassignEdge::edgeCompare to TCassignEdge::compare;
@
text
@d408 7
@


1.22
log
@ELIMINATED TCassignEdgeList, TCassignEdgeSet, and TCassignEdgeIterator;
replaced by SUCO equivalents;
entailed writing a new edge compare function.
@
text
@d131 5
@


1.21
log
@Added AOlistIterator class, though currently not (yet) used.
Also added accessor getStaticType().
@
text
@d105 3
a107 3
  TCassignEdgeIterator ei(assignsTo);
  while(ei.iterate())
    ei.current()->getTo().setTS_UNSAFE();
d133 7
a139 1
  return assignsTo.insert(tgt, *this, ty);
@


1.20
log
@Added skeleton for lvalType(), with initial seeding rules
in tca.cpp, and ECR debug_dump to include rttype.
Must rethink strategy for solving constraints before
proceeding
@
text
@d75 15
@


1.19
log
@Added staticType (+).
@
text
@d121 43
@


1.18
log
@Changed verifyPtr from a boolean flag to a type.
@
text
@d121 8
@


1.17
log
@Updated Ext object to take two types.
@
text
@d124 10
a133 3
  else if(verifyTagType != &ty){
//-- must do deep compare?
    verifyTagType = &TCtype::tcVoidType; //-- set to BOTTOM??
@


1.16
log
@Incorporated new format that includes typed-assignments
(: <T> <O>) and verifyTag/verifyPtr (} <T> <O>, ] <O>).
@
text
@d197 3
a199 2
	TCtype * ty = TCtype::stringToTy(c,nptr);
	if(ty) return &o->get_AOExt(*ty);
d324 1
a324 1
AO& AO::get_AOExt(TCtype &t) //- deletes t if found
d328 2
a329 1
    if(((AOExt&)(*np)->ao).getTy().equals(t)){
d331 1
d336 1
a336 1
  *np = new AOlist::node(*new AOExt(*this, t));
d436 3
a438 1
  ty.debug_dump(os);
d535 2
a536 1
  ty.write_string_rep(os);
@


1.15
log
@Added AOFunction object.
@
text
@d116 1
a116 1
TCassignEdge * AO::assignTo(AO& tgt)
d118 10
a127 1
  return assignsTo.insert(tgt, *this);
@


1.14
log
@Fixed setTS_UNSAFE to propagate UNSAFE to all
SDot, UDot, Star, and Ext children.
@
text
@d246 5
d300 7
d405 7
d502 6
@


1.13
log
@Changed setTS_UNSAFE to propagate along assign edges.
@
text
@d77 5
a81 1
//- sets tsl to UNSAFE, and propagate along assign edges
d88 3
a90 1
  TCassignEdgeIterator ei(assignsTo); //- propagate
d93 15
@


1.12
log
@Added traverser foreachAO and static output function writeAO.
@
text
@d77 12
@


1.11
log
@Added concatenate function.
@
text
@d62 6
d94 6
@


1.10
log
@Added ECR; extended functionality of AOlist (for ECR use)
@
text
@d43 8
@


1.9
log
@Added assignEdgeSet to AOs, and mechanism to insert into
the set without duplication.
Next: use this info to propagate UNSAFE from addr-taken
nodes.
@
text
@d6 1
d17 1
a17 1
    delete &del->ao;
d22 21
d79 1
a79 1
FILE * AO::writeTSstream = 0;
d84 15
a98 4
  if(c && writeTSstream) {
    fprintf(writeTSstream, "~ %c ", c);
    ao.write_string_rep(writeTSstream);
    fprintf(writeTSstream, "\n");
@


1.8
log
@Added type-safety level to AO; improved analysis output
function to tag address-taken objects as UNSAFE, and later
output them; the old function (writeAddrofTSlevels) is now
obsolete and should be removed.
@
text
@d32 1
a32 1
void AOlist::traverse(void (*fp)(AO& o))
d35 1
a35 1
    n->ao.traverse(fp);
d41 1
a41 1
void AO::traverse(void (*fp)(AO& o))
d44 6
a49 1
  aolist.traverse(fp);
@


1.7
log
@Added mechanism to store AOs in an AOlist in each AO.
Included mechanism for traversing all AOs, and debug output
functions.
Fairly complete, but not thoroughly tested (especially TypeList
destructors?)
@
text
@d52 12
d67 10
@


1.6
log
@Added aoArray object.
@
text
@d8 31
d41 6
d57 1
a57 1
AO * AO::stringToAO(char * str, char ** nptr, IDmap& aidmap, IDmap& pidmap)
d63 1
a63 1
	AO * o = stringToAO(c+1, nptr, aidmap, pidmap);
d65 1
a65 1
	else return new AOAddrOf(*o);
d68 1
a68 1
	AO * o = stringToAO(c+1, nptr, aidmap, pidmap);
d70 1
a70 1
	else return new AOStar(*o);
d73 1
a73 1
	AO * o = stringToAO(c+1, &c, aidmap, pidmap);
d76 1
a76 1
	if(ty) return new AOExt(*o, *ty);
d81 1
a81 1
	AO * o = stringToAO(c, nptr, aidmap, pidmap);
d83 1
a83 1
	return new AOArg(*o, argno);
d88 1
a88 1
	if(pid) return new AOId(*pid);
d94 1
a94 1
	if(aid) return new AOStringLit(*aid);
d100 1
a100 1
	if(aid) return new AOMalloc(*aid);
d104 1
a104 1
	AO * o = stringToAO(c+1, &c, aidmap, pidmap);
d107 1
a107 1
	if(ty) return new AOOp(*o, *ty);
d111 1
a111 1
	AO * o = stringToAO(c+1, nptr, aidmap, pidmap);
d113 1
a113 1
	else return new AOReturn(*o);
d116 1
a116 1
	AO * o = stringToAO(c+1, &c, aidmap, pidmap);
d119 1
a119 1
	return new AOSDot(*o, tylist);
d122 1
a122 1
	AO * o = stringToAO(c+1, &c, aidmap, pidmap);
d125 1
a125 1
	if(ty) return new AOUDot(*o, *ty);
d130 1
a130 1
	if(ty) return new AOValue(*ty);
d134 1
a134 1
	AO * o = stringToAO(c+1, nptr, aidmap, pidmap);
d136 1
a136 1
	else return new AOArray(*o);
d142 120
@


1.5
log
@Added write_string_rep to output intermediate file format.
@
text
@d96 5
d116 7
d207 6
@


1.4
log
@ao.cpp has been split into four pairs of files:
ao, id, tca, and ty (.cpp and .h)
@
text
@d15 5
d129 1
a129 1
  fprintf(os, "AOArg(");
d188 76
@


1.3
log
@Wrote, but did not test, destructors for TCtype/TCtypeList.
Next - file will be split!
@
text
@a2 1
#include <string.h>
d5 1
a5 376
//------------------------------------------------------

class AO;

class ID {
  public:
    friend class IDlist;
    int getkey() { return key; }
    const char * getname() { return name; }
  private:
    ID();
    ID(char * n);
    ~ID();
    int key;
    char * name;
    AO * ao;
};

//------------------------------------------------------

ID::ID(char * n)
:key(0), name(0), ao(0)
{
  name = new char[strlen(n)+1];
  strcpy(name,n);
}

ID::~ID()
{
  if(name) delete [] name;
}

//------------------------------------------------------

class IDmap {
  public:
    IDmap(unsigned int size = 1024);
    ~IDmap();
    void debug_dump(FILE * os);
    void map(unsigned int key, ID& id);
    ID * lookup(unsigned int key);

  private:
    void grow(unsigned int upto);
    ID ** table;
    unsigned int size;
};

//------------------------------------------------------

IDmap::IDmap(unsigned int s)
: size(s), table(new (ID*)[s])
{
  for(int i = 0; i < s; ++i) // zero-initialize
    table[i] = 0;
}

IDmap::~IDmap()
{
  delete [] table;
}

void IDmap::debug_dump(FILE * os)
{
  for(int i = 0; i < size; ++i)
    if(table[i])
      fprintf(os, "map(%d):[%s]\n", i, table[i]->getname());
}

void IDmap::map(unsigned int key, ID& id)
{
  if(key >= size) grow(key + 10);
  table[key] = &id;
}

ID * IDmap::lookup(unsigned int key)
{
  if(key >= size) return 0;
  else return table[key];
}

void IDmap::grow(unsigned int upto)
{
  int newsize;
  for(newsize = size; newsize <= upto; newsize *= 2);

  ID ** oldtab = table;
  table = new (ID*)[newsize];

  int i;
  for(i = 0; i < size; ++i) table[i] = oldtab[i];
  for(; i < newsize; ++i) table[i] = 0;

  size = newsize;
  delete [] oldtab;
}

//------------------------------------------------------
class TCtypeList;
class TCtype {
  public:
    enum tcKind {
	 tcVoid, tcInt, tcChar, tcShort, tcLong, tcLongLong,
	 tcFloat, tcDouble, tcLongDouble, tcPointer,
	 tcStruct, tcUnion, tcArray,
	 tcBitField, tcFunction
	};
    static TCtype * stringToTy(char * str, char ** nptr);
    static void deleteTy(TCtype * ty);
    const char * kindString();
    virtual void debug_dump(FILE * os);

    static TCtype tcVoidType;
    static TCtype tcIntType;
    static TCtype tcCharType;
    static TCtype tcShortType;
    static TCtype tcLongType;
    static TCtype tcLongLongType;
    static TCtype tcFloatType;
    static TCtype tcDoubleType;
    static TCtype tcLongDoubleType;

  protected:
    TCtype(enum tcKind k) : kind(k) {}
    virtual bool cleanup() const { return false; } // indicates if class needs to be destroyed
    virtual ~TCtype() {}
  private:
    TCtype();
    enum tcKind kind;
};

TCtype TCtype::tcVoidType = TCtype(tcVoid);
TCtype TCtype::tcIntType = TCtype(tcInt);
TCtype TCtype::tcCharType = TCtype(tcChar);
TCtype TCtype::tcShortType = TCtype(tcShort);
TCtype TCtype::tcLongType = TCtype(tcLong);
TCtype TCtype::tcLongLongType = TCtype(tcLongLong);
TCtype TCtype::tcFloatType = TCtype(tcFloat);
TCtype TCtype::tcDoubleType = TCtype(tcDouble);
TCtype TCtype::tcLongDoubleType = TCtype(tcLongDouble);

//------------------------------------------------------

class TCtypeList {
  public:
    static TCtypeList& stringToTyList(char * str, char ** nptr);
    void debug_dump(FILE * os);
    ~TCtypeList();
  private:
    TCtypeList();
    class node {
      public:
        node(TCtype &t, node * n = 0) : ty(t), next(n) {}
        TCtype& ty;
        node * next;
      private:
        node();
    };
    TCtypeList(node * l): head(l) {}
    node * head;
};

//------------------------------------------------------

TCtypeList::~TCtypeList()
{
fprintf(stderr, "DESTRUCTOR\n");
  node * nptr = head;
  while(nptr){
    node * del = nptr;
    nptr = nptr->next;
    TCtype::deleteTy(&del->ty);
    delete del;
  }
}

//------------------------------------------------------

class TCstructUnionType : public TCtype {
  public:
    friend class TCtype;
    void debug_dump(FILE * os);
  private:
    TCstructUnionType();
    ~TCstructUnionType() { delete &tylist; }
    bool cleanup() const { return true; }
    TCstructUnionType(enum tcKind k, TCtypeList& l) : TCtype(k), tylist(l) {}
    TCtypeList& tylist;
};

class TCfunctionType : public TCtype {
  public:
    friend class TCtype;
    void debug_dump(FILE * os);
  private:
    TCfunctionType();
    ~TCfunctionType() { deleteTy(&rty); delete &tylist; }
    TCfunctionType(TCtype &t, TCtypeList& l) : TCtype(tcFunction), rty(t), tylist(l) {}
    bool cleanup() const { return true; }
    TCtype &rty;
    TCtypeList& tylist;
};

class TCpointerType : public TCtype {
  public:
    friend class TCtype;
    void debug_dump(FILE * os);
  private:
    TCpointerType();
    ~TCpointerType() { deleteTy(&ty); }
    bool cleanup() const { return true; }
    TCpointerType(TCtype * t = 0) : TCtype(tcPointer), ty(t?(*t):tcVoidType) {}
    TCtype &ty;
};

class TCnumType : public TCtype {
  public:
    friend class TCtype;
    void debug_dump(FILE * os);
  private:
    TCnumType();
    ~TCnumType() { deleteTy(&ty); }
    bool cleanup() const { return true; }
    TCnumType(enum tcKind k, unsigned int i, TCtype &t) : TCtype(k), size(i), ty(t) {}
    unsigned int size;
    TCtype &ty;
};

//------------------------------------------------------
const char * TCtype::kindString()
{
  switch(kind){
    case tcVoid: return "tcVoid";
    case tcInt: return "tcInt";
    case tcChar: return "tcChar";
    case tcShort: return "tcShort";
    case tcLong: return "tcLong";
    case tcLongLong: return "tcLongLong";
    case tcFloat: return "tcFloat";
    case tcDouble: return "tcDouble";
    case tcLongDouble: return "tcLongDouble";
    case tcPointer: return "tcPointer";
    case tcStruct: return "tcStruct";
    case tcUnion: return "tcUnion";
    case tcArray: return "tcArray";
    case tcBitField: return "tcBitField";
    case tcFunction: return "tcFunction";
    default: return "ERROR";
  }
}

void TCtype::debug_dump(FILE * os)
{
  fprintf(os, kindString());
}

void TCstructUnionType::debug_dump(FILE * os)
{
  fprintf(os, "%s(", kindString());
  tylist.debug_dump(os);
  fprintf(os, ")");
}

void TCfunctionType::debug_dump(FILE * os)
{
  fprintf(os, "%s[", kindString());
  rty.debug_dump(os);
  fprintf(os, "](");
  tylist.debug_dump(os);
  fprintf(os, ")");
}

void TCpointerType::debug_dump(FILE * os)
{
  fprintf(os, "%s[", kindString());
  ty.debug_dump(os);
  fprintf(os, "]");
}

void TCnumType::debug_dump(FILE * os)
{
  fprintf(os, "%s[", kindString());
  ty.debug_dump(os);
  fprintf(os, "](%d)",size);
}

void TCtypeList::debug_dump(FILE * os)
{
  for(node * n = head; n; n = n->next){
    if(n != head) fprintf(os, ",");
    n->ty.debug_dump(os);
  }
}

TCtypeList& TCtypeList::stringToTyList(char * str, char ** nptr)
{
  node * list = 0;
  node ** tail = &list;
  char * c = str;
  while(isspace(*c)) c++;
  while(*c && *c != ';'){
    TCtype * ty = TCtype::stringToTy(c,&c);
    if(!ty){ //- error
      fprintf(stderr, "Malformed type list (%s)\n", c);
      *nptr = c;
      return * new TCtypeList(list);
    }
    *tail = new node(*ty);
    tail = &(*tail)->next;
    while(isspace(*c)) c++;
  }
  *nptr = c+1;
  return * new TCtypeList(list);
}

TCtype * TCtype::stringToTy(char * str, char ** nptr)
{
  char * c = str;
  while(isspace(*c)) c++;
  *nptr = c+1;
  switch(*c){
    case 'a': {
        unsigned int size = strtoul(c+1, &c, 10);
	TCtype * bty = stringToTy(c, nptr);
	if(!bty){
	  fprintf(stderr, "Malformed array type\n");
          return 0;
	}
	return new TCnumType(tcArray, size, *bty);
      }
    case 'b': {
        unsigned int size = strtoul(c+1, &c, 10);
	TCtype * bty = stringToTy(c, nptr);
	if(!bty){
	  fprintf(stderr, "Malformed bitfield type\n");
          return 0;
	}
	return new TCnumType(tcBitField, size, *bty);
      }
    case 'c': return &tcCharType;
    case 'd': return &tcDoubleType;
    case 'e': return &tcLongDoubleType;
    case 'f': return &tcFloatType;
    case 'g': return &tcLongLongType;
    case 'h': return &tcShortType;
    case 'i': return &tcIntType;
    case 'l': return &tcLongType;
    case 'p': return new TCpointerType(0);
    case 's':{
        TCtypeList& tylist = TCtypeList::stringToTyList(c+1, nptr);
	return new TCstructUnionType(tcStruct, tylist);
      }
    case 'u':{
        TCtypeList& tylist = TCtypeList::stringToTyList(c+1, nptr);
	return new TCstructUnionType(tcUnion, tylist);
      }
    case 'v': return new TCtype(tcVoid);
    case 'x': {
	TCtype * ty = stringToTy(c+1, &c);
	if(!ty){
	  fprintf(stderr, "Malformed function type\n");
          ty = new TCtype(tcInt);
	}
        TCtypeList& tylist = TCtypeList::stringToTyList(c, nptr);
	return new TCfunctionType(*ty, tylist);
      }
    default :
      fprintf(stderr, "Invalid type identifier [%c] (%s)\n", *c, c);
      return 0; // invalid type
  }
}

void TCtype::deleteTy(TCtype * ty)
{
  if(ty->cleanup()) delete ty;
}
d8 1
a8 28

class AO {
  public:
    enum aoKind {
	 aoId, aoMalloc, aoSDot, aoUDot,
	 aoReturn, aoArg, aoStar, aoValue,
	 aoStringLit, aoOp, aoExt, aoAddrOf
	};

    static AO * stringToAO(char * str, char ** nptr, IDmap& aidmap, IDmap& pidmap);
    virtual void debug_dump(FILE * os);

  protected:
    AO(enum aoKind k) : kind(k) {}

  private:
    AO();
    enum aoKind kind;
/*
    class node {
      public:
      private:
        AO& ao;
        node * next;
    };
    node * aolist;
*/
};
a14 201
//- - - - - - - - - - - - - - - - - - - - - -
class AOAddrOf : public AO
{
  public:  AOAddrOf(AO &o) : AO(aoAddrOf), ao(o) {}
	   void debug_dump(FILE * os);
  private: AOAddrOf();
	   AO &ao;
};

void AOAddrOf::debug_dump(FILE * os)
{
  fprintf(os, "AOAddrOf(");
  ao.debug_dump(os);
  fprintf(os,")");
}

//- - - - - - - - - - - - - - - - - - - - - -
class AOStar : public AO
{
  public:  AOStar(AO &o) : AO(aoStar), ao(o) {}
	   void debug_dump(FILE * os);
  private: AOStar();
	   AO &ao;
};

void AOStar::debug_dump(FILE * os)
{
  fprintf(os, "AOStar(");
  ao.debug_dump(os);
  fprintf(os,")");
}

//- - - - - - - - - - - - - - - - - - - - - -
class AOExt : public AO
{
  public:  AOExt(AO &a, TCtype &t) : AO(aoExt), ao(a), ty(t) {}
	   void debug_dump(FILE * os);
  private: AOExt();
	   AO &ao;
	   TCtype &ty;
};

void AOExt::debug_dump(FILE * os)
{
  fprintf(os, "AOExt(");
  ao.debug_dump(os);
  fprintf(os,")[");
  ty.debug_dump(os);
  fprintf(os,"]");
}

//- - - - - - - - - - - - - - - - - - - - - -
class AOArg : public AO
{
  public:  AOArg(AO &o, int n) : AO(aoArg), ao(o), no(n) {}
	   void debug_dump(FILE * os);
  private: AOArg();
	   int no;
	   AO &ao;
};

void AOArg::debug_dump(FILE * os)
{
  fprintf(os, "AOArg(");
  ao.debug_dump(os);
  fprintf(os,")");
}

//- - - - - - - - - - - - - - - - - - - - - -
class AOId : public AO
{
  public:  AOId(ID &p) : AO(aoId), pid(p) {}
	   void debug_dump(FILE * os);
  private: AOId();
	   ID &pid;
};

void AOId::debug_dump(FILE * os)
{
  fprintf(os, "AOId(%d=[%s])", pid.getkey(), pid.getname());
}

//- - - - - - - - - - - - - - - - - - - - - -
class AOStringLit : public AO
{
  public:  AOStringLit(ID &a) : AO(aoStringLit), aid(a) {}
	   void debug_dump(FILE * os);
  private: AOStringLit();
	   ID &aid;
};

void AOStringLit::debug_dump(FILE * os)
{
  fprintf(os, "AOStringLit(%d=[%s])", aid.getkey(), aid.getname());
}

//- - - - - - - - - - - - - - - - - - - - - -
class AOMalloc : public AO
{
  public:  AOMalloc(ID &a) : AO(aoMalloc), aid(a) {}
	   void debug_dump(FILE * os);
  private: AOMalloc();
	   ID &aid;
};

void AOMalloc::debug_dump(FILE * os)
{
  fprintf(os, "AOMalloc(%d=[%s])", aid.getkey(), aid.getname());
}

//- - - - - - - - - - - - - - - - - - - - - -
class AOOp : public AO
{
  public:  AOOp(AO &a, TCtype &t) : AO(aoOp), ao(a), ty(t) {}
	   void debug_dump(FILE * os);
  private: AOOp();
	   AO &ao;
	   TCtype &ty;
};

void AOOp::debug_dump(FILE * os)
{
  fprintf(os, "AOOp(");
  ao.debug_dump(os);
  fprintf(os,")[");
  ty.debug_dump(os);
  fprintf(os,"]");
}

//- - - - - - - - - - - - - - - - - - - - - -
class AOReturn : public AO
{
  public:  AOReturn(AO &o) : AO(aoReturn), ao(o) {}
	   void debug_dump(FILE * os);
  private: AOReturn();
	   AO &ao;
};

void AOReturn::debug_dump(FILE * os)
{
  fprintf(os, "AOReturn(");
  ao.debug_dump(os);
  fprintf(os,")");
}

//- - - - - - - - - - - - - - - - - - - - - -
class AOSDot : public AO
{
  public:  AOSDot(AO &a, TCtypeList &l) : AO(aoSDot), ao(a), tylist(l) {}
	   void debug_dump(FILE * os);
  private: AOSDot();
	   AO &ao;
	   TCtypeList &tylist;
};

void AOSDot::debug_dump(FILE * os)
{
  fprintf(os, "AOSDot(");
  ao.debug_dump(os);
  fprintf(os,")[");
  tylist.debug_dump(os);
  fprintf(os,"]");
}

//- - - - - - - - - - - - - - - - - - - - - -
class AOUDot : public AO
{
  public:  AOUDot(AO &a, TCtype &t) : AO(aoUDot), ao(a), ty(t) {}
	   void debug_dump(FILE * os);
  private: AOUDot();
	   AO &ao;
	   TCtype &ty;
};

void AOUDot::debug_dump(FILE * os)
{
  fprintf(os, "AOUDot(");
  ao.debug_dump(os);
  fprintf(os,")[");
  ty.debug_dump(os);
  fprintf(os,"]");
}

//- - - - - - - - - - - - - - - - - - - - - -
class AOValue : public AO
{
  public:  AOValue(TCtype &t) : AO(aoValue), ty(t) {}
	   void debug_dump(FILE * os);
  private: AOValue();
	   TCtype &ty;
};

void AOValue::debug_dump(FILE * os)
{
  fprintf(os, "AOValue[");
  ty.debug_dump(os);
  fprintf(os,"]");
}

//------------------------------------------------------

d97 1
a97 1
//------------------------------------------------------
d99 6
a104 17
class IDlist {
  public:
    IDlist(unsigned int size = 1023);
    ~IDlist();
    void debug_dump(FILE * os);
    ID& getID(char * str);
  private:
    unsigned int hash(char * str);
    class node {
      public:
        node(ID& i, node * n):id(i), next(n){}
        ID& id;
        node * next;
    };
    node ** table;
    unsigned int size;
};
d106 1
a106 3
//------------------------------------------------------
IDlist::IDlist(unsigned int s)
:size(s), table(new (node*)[s])
d108 3
a110 2
  for(int i = 0; i < size; ++i) // zero-initialize
    table[i] = 0;
d113 1
a113 1
IDlist::~IDlist()
d115 5
a119 10
  for(int i = 0; i < size; ++i){
    node * nptr = table[i];
    while(nptr){
      node * del = nptr;
      nptr = nptr->next;
      delete &del->id;
      delete del;
    }
  }
  delete [] table;
d122 1
a122 1
void IDlist::debug_dump(FILE * os)
d124 3
a126 3
  for(int i = 0; i < size; ++i)
    for(node * nptr = table[i]; nptr; nptr = nptr->next)
      fprintf(os, "ID(%d):[%s]\n", nptr->id.getkey(), nptr->id.getname());
d129 1
a129 1
ID& IDlist::getID(char * str)
d131 1
a131 11
  node ** nptr;
  for(nptr = &table[hash(str)];
      *nptr;
      nptr = &(*nptr)->next){
    int cmp = strcmp(str, (*nptr)->id.name);
    if(cmp == 0) return (*nptr)->id;
    else if(cmp < 0) break;
  }
  ID * newid = new ID(str);
  *nptr = new node(*newid, *nptr);
  return *newid;
d134 1
a134 1
unsigned int IDlist::hash(char * str)
d136 1
a136 4
  unsigned int h = 0;
  for(char * c = str; *c; ++c)
    h = 5*h + *c;
  return h % size;
d139 4
a142 1
//------------------------------------------------------
d144 8
a151 6
class TCAstate {
  public:
    void processFile(char *);
  private:
    IDlist aidtab, pidtab;
};
d153 6
a158 1
//------------------------------------------------------
d160 8
a167 1
#define BUF_SIZE 1024
d169 1
a169 1
void TCAstate::processFile(char * filename)
d171 5
a175 76
  FILE * inf = fopen(filename, "r");
  if(inf){
    fprintf(stderr, "--- processing %s ---\n", filename);
    char buf[BUF_SIZE];

    IDmap aidmap, pidmap;

    AO * aotgt = 0;

    fgets(buf, BUF_SIZE, inf);
    while(!feof(inf)){
/**/  fprintf(stderr, " doing : %s", buf);
      switch(*buf){
        case ':': { //- assign target
            char * cp = &buf[2];
            aotgt = AO::stringToAO(cp, &cp, aidmap, pidmap);
/**/        if(aotgt){
/**/		fprintf(stderr, "ASTGT: ");
/**/		aotgt->debug_dump(stderr);
/**/		fprintf(stderr, "\n");
/**/	    }
          } break;
        case '=': { //- assign source
            char * cp = &buf[2];
            AO * aosrc = AO::stringToAO(cp, &cp, aidmap, pidmap);
/**/        if(aosrc){
/**/		fprintf(stderr, "  SRC: ");
/**/		aosrc->debug_dump(stderr);
/**/		fprintf(stderr, "\n");
/**/	    }
          } break;
        case '@@': { //- aid entry
            char * cp = &buf[2];
            unsigned int aidno = strtoul(cp, &cp, 10);
            //- skip leading and trailing spaces
            while(isspace(*cp)) cp++;
            char * ep = cp + strlen(cp) - 1;
            while(isspace(*ep)) ep--;
            *(ep+1) = 0;
            //- get id, insert into aidmap
            ID& aid = aidtab.getID(cp);
            aidmap.map(aidno, aid);
          } break;
        case '%': { //- pid entry
            char * cp = &buf[2];
            unsigned int pidno = strtoul(cp, &cp, 10);
            //- skip leading and trailing spaces
            while(isspace(*cp)) cp++;
            char * ep = cp + strlen(cp) - 1;
            while(isspace(*ep)) ep--;
            *(ep+1) = 0;
            //- get id, insert into pidmap
            ID& pid = pidtab.getID(cp);
            pidmap.map(pidno, pid);
          } break;
        case '$': //- ao alias -- not yet implemented
        case '~': //- type-safety level -- ignore (for now?)
        case '#': //- comment
        default : //- treat as comment
	  ;
      }
      fgets(buf, BUF_SIZE, inf);
    }
    fclose(inf);
    fprintf(stderr, "------ done processing %s\n", filename);
/**/fprintf(stderr, "AIDTAB:\n");
/**/aidtab.debug_dump(stderr);
/**/fprintf(stderr, "AIDMAP:\n");
/**/aidmap.debug_dump(stderr);
/**/fprintf(stderr, "PIDTAB:\n");
/**/pidtab.debug_dump(stderr);
/**/fprintf(stderr, "PIDMAP:\n");
/**/pidmap.debug_dump(stderr);
  } else {
    fprintf(stderr, "Error opening file %s\n", filename);
  }
d178 1
a178 3
//------------------------------------------------------

int main(int argc, char * argv[])
d180 4
a183 2
  if(argc <= 1)
    return fprintf(stderr, "Usage: %s files\n", argv[0]);
d185 1
a185 7
  TCAstate state;

  for(int i = 1; i < argc; ++i)
    state.processFile(argv[i]);

  return 0;
}
@


1.2
log
@Wrote TCtype and TCtypelist as well as all remaining AO subtypes.
Todo: write destructors for TCtype and TCtypelist;
then mechanism to store AOs in an AOlist.
@
text
@d114 1
d130 2
d147 2
d153 1
d168 16
d190 2
d202 1
d204 1
d215 2
d227 2
d376 5
@


1.1
log
@Initial revision
@
text
@d104 245
d372 3
a374 2
        class node * next;
    } * aolist;
d384 68
d456 2
a457 1
  private: ID &pid;
d466 14
d484 2
a485 1
  private: ID &aid;
d494 20
a513 1
class AOStar : public AO
d515 1
a515 1
  public:  AOStar(AO &o) : AO(aoStar), ao(o) {}
d517 2
a518 1
  private: AO &ao;
d521 1
a521 1
void AOStar::debug_dump(FILE * os)
d523 1
a523 1
  fprintf(os, "AOStar(");
d528 54
d589 5
a593 1
//    case 'A':
d595 16
a610 3
        AO * o = stringToAO(c+1, nptr, aidmap, pidmap);
        if(o) return new AOStar(*o);
        else return 0;
a611 2
//    case 'E':
//    case 'F':
d613 1
a613 1
        unsigned int pidno = strtoul(c+1, nptr, 10);
d615 8
a622 2
        if(pid) return new AOId(*pid);
        else return 0; /* error */
a623 1
//    case 'L':
d625 1
a625 1
        unsigned int aidno = strtoul(c+1, nptr, 10);
d627 32
a658 2
        if(aid) return new AOMalloc(*aid);
        else return 0;
a659 5
//    case 'O':
//    case 'R':
//    case 'S':
//    case 'U':
//    case 'V':
d661 1
a661 1
    default : return 0; // invalid object
d678 1
a678 1
        node(ID& i, class node * n):id(i), next(n){}
d680 1
a680 1
        class node * next;
d770 1
a770 1
/**/		fprintf(stderr, "ASTGT:");
d776 7
@
