head	1.48;
access;
symbols;
locks; strict;
comment	@ * @;


1.48
date	2004.06.29.20.02.32;	author suan;	state Exp;
branches;
next	1.47;

1.47
date	2004.06.23.17.16.49;	author suan;	state Exp;
branches;
next	1.46;

1.46
date	2004.06.23.14.57.00;	author suan;	state Exp;
branches;
next	1.45;

1.45
date	2004.05.25.14.02.29;	author suan;	state Exp;
branches;
next	1.44;

1.44
date	2004.05.12.18.53.04;	author suan;	state Exp;
branches;
next	1.43;

1.43
date	2004.05.11.15.01.15;	author suan;	state Exp;
branches;
next	1.42;

1.42
date	2004.05.07.23.30.14;	author suan;	state Exp;
branches;
next	1.41;

1.41
date	2004.05.07.18.54.14;	author suan;	state Exp;
branches;
next	1.40;

1.40
date	2004.05.06.23.42.03;	author suan;	state Exp;
branches;
next	1.39;

1.39
date	2004.05.02.18.50.18;	author suan;	state Exp;
branches;
next	1.38;

1.38
date	2004.04.29.18.44.41;	author suan;	state Exp;
branches;
next	1.37;

1.37
date	2004.03.18.19.33.42;	author suan;	state Exp;
branches;
next	1.36;

1.36
date	2004.02.18.16.06.52;	author suan;	state Exp;
branches;
next	1.35;

1.35
date	2003.11.14.22.47.57;	author suan;	state Exp;
branches;
next	1.34;

1.34
date	2003.11.12.00.10.31;	author suan;	state Exp;
branches;
next	1.33;

1.33
date	2003.11.07.20.39.42;	author suan;	state Exp;
branches;
next	1.32;

1.32
date	2003.11.06.20.56.46;	author suan;	state Exp;
branches;
next	1.31;

1.31
date	2003.11.05.21.26.08;	author suan;	state Exp;
branches;
next	1.30;

1.30
date	2003.06.18.20.08.46;	author suan;	state Exp;
branches;
next	1.29;

1.29
date	2003.06.11.23.05.24;	author suan;	state Exp;
branches;
next	1.28;

1.28
date	2003.02.25.21.50.19;	author suan;	state Exp;
branches;
next	1.27;

1.27
date	2003.02.25.20.04.46;	author suan;	state Exp;
branches;
next	1.26;

1.26
date	2003.02.25.16.41.45;	author suan;	state Exp;
branches;
next	1.25;

1.25
date	2003.02.21.17.40.11;	author suan;	state Exp;
branches;
next	1.24;

1.24
date	2002.11.15.22.07.32;	author suan;	state Exp;
branches;
next	1.23;

1.23
date	2002.11.14.16.47.36;	author suan;	state Exp;
branches;
next	1.22;

1.22
date	2002.11.13.01.42.39;	author suan;	state Exp;
branches;
next	1.21;

1.21
date	2002.11.07.00.40.47;	author suan;	state Exp;
branches;
next	1.20;

1.20
date	2002.10.30.20.47.39;	author suan;	state Exp;
branches;
next	1.19;

1.19
date	2002.10.23.20.26.57;	author suan;	state Exp;
branches;
next	1.18;

1.18
date	2002.09.18.15.35.20;	author suan;	state Exp;
branches;
next	1.17;

1.17
date	2002.08.19.14.22.25;	author suan;	state Exp;
branches;
next	1.16;

1.16
date	2002.08.18.22.13.53;	author suan;	state Exp;
branches;
next	1.15;

1.15
date	2002.08.16.21.56.08;	author suan;	state Exp;
branches;
next	1.14;

1.14
date	2002.08.16.20.28.52;	author suan;	state Exp;
branches;
next	1.13;

1.13
date	2002.08.15.23.39.23;	author suan;	state Exp;
branches;
next	1.12;

1.12
date	2002.08.15.21.16.25;	author suan;	state Exp;
branches;
next	1.11;

1.11
date	2002.08.14.23.03.01;	author suan;	state Exp;
branches;
next	1.10;

1.10
date	2002.08.14.19.31.03;	author suan;	state Exp;
branches;
next	1.9;

1.9
date	2002.08.12.21.59.52;	author suan;	state Exp;
branches;
next	1.8;

1.8
date	2002.08.10.21.26.24;	author suan;	state Exp;
branches;
next	1.7;

1.7
date	2002.07.29.21.29.44;	author suan;	state Exp;
branches;
next	1.6;

1.6
date	2002.07.25.15.48.48;	author suan;	state Exp;
branches;
next	1.5;

1.5
date	2002.05.26.05.43.21;	author suan;	state Exp;
branches;
next	1.4;

1.4
date	2002.05.25.18.58.05;	author suan;	state Exp;
branches;
next	1.3;

1.3
date	2002.04.19.16.45.01;	author suan;	state Exp;
branches;
next	1.2;

1.2
date	2002.04.18.17.06.19;	author suan;	state Exp;
branches;
next	1.1;

1.1
date	2002.04.18.15.55.32;	author suan;	state Exp;
branches;
next	;


desc
@ECR (Equivalent-Class Representative) for performing pointer
analysis.
@


1.48
log
@ADDED evaluation of each library function call to determine
if its target (where relevant) is exposed -- this will mainly
be used in -vulnw mode to remove instrumentation when a
function's target is exposed (needed to avoid false positive).
Eventually, it may also be used in -ptr/ptrw mode to remove
instrumentation when a library function's target is not
exposed -- though currently this never happens because of
context-insensitive analysis and overly-conservative models.
SUPPLEMENTAL CHANGES to achieve the above:
 1. Created ExposedStatus class in ao.cpp/ao.h (was previously
    an enum in AO class)
 2. Changed PExprcall::isDirectCall() to return the ID of the
    direct call, rather than just a bool.
 3. Exported "flag_readwrite" to become a global -- it's about
    time (I'd been misguidedly trying to avoid this for far
    too long, creating a bigger mess instead)
@
text
@#ifndef TC_ECR_H /* { */
#define TC_ECR_H

#include <stdio.h>

#include "ao.h"
#include "edge.h"
#include "suco.h"

//------------------------------------------------------

class ECRargRet
{ //-TODO: add mechanism to garbage collect (currently, leaked)
  public:
    friend class ECR;
    ECRargRet(ECR& mp): main_parent(&mp), fwdptr(0),
			ret(0), args(0), argsize(0), nargs(max_nargs)
			{}

    void addArg(int argno, ECR& ecr); // remember, argno is one-based
    void addRet(ECR& ecr);

    ECR& getMainParent();

    static void findMaxNargs(AO& ao);
    static int getMaxNargs() { return max_nargs; }

    ECR * get_arg(int argno) const; // remember, argno is one-based
    ECR * get_ret() const { return ret; }

    int getArgSize() const { return argsize; }

  private:
    ECRargRet();

    ECRargRet& followFwdPtr();

    ECR *& getArgPtr(int argno); // remember, argno is one-based
    ECR& getArg(int argno); // remember, argno is one-based
    ECR& getRet();

    void fixECRs(); // called by ECR::fixECR()

    void absorbArgRet(int argno, ECR ** args, ECR * ret); // remember, argno is one-based
    void absorb(ECRargRet * ar);

    static int max_nargs;

    ECR * main_parent;

    ECRargRet * fwdptr;

    ECR * ret;
    ECR ** args;
    int argsize;
    int nargs;
    int refcount;
};

//------------------------------------------------------

class ECR
{
  public:
    friend class AO;
    friend class ECRargRet;
    friend class TCAstate; //-- give access to traverseCounter, exposed, touched

    static ECR& new_ECR();

    void debug_dump(FILE * outf);
    static void debug_dump_list(suco_llist<ECR *>& elist, FILE * outf);

    static void debug_traceInclude(ECR& e);

    suco_set<AO *>& getAOset() { return aoset; }

    ECR& getPointsTo();

    void pointsTo(ECR& ecr);
    void includesTo(ECR& ecr);

    //- follows inclusion edges, while true; if false, stop and return false
    bool traverseAliases(bool (*aofp)(AO& o), bool (*ecrfp)(ECR& e) = 0);
    static bool traverseSetAliases(suco_set<ECR *>& eset, bool (*aofp)(AO& o), bool (*ecrfp)(ECR& e) = 0);

    void collectAliasECRs(suco_set<ECR *>& eset, bool affecting = false);
    void collectInclFromECRs(suco_set<ECR *>& eset); //- called by TCAstate::collectRelevantLocs

    static void filterLocArgRet(suco_set<ECR *>& eset);

    suco_set<ECR *>& getAliasECRs();	// WARNING: this function caches its lookup result,
					// so it should only be called after the points-to graph
					// has quiesced, which is to say after completion of
					// all points-to analysis phases.  In the meantime,
					// use collectAliasECRs.

    void markInvalid(bool propDeref); // marks invalid, and propagate
    bool isInvalid() const { return invalid; }

    ECR& followECR();

    //- functions to manipulate ECRs in AOs
    static void fixECR(AO& ao);
    static ECR& getECR(AO& ao);
    static void unifyECRs(AO& ao1, AO& ao2);

    ECRargRet& getArgRet();

    ECRargRet * argRet(); //- follows forward pointer; returns null if none

    TClatType& possType() { return poss_type; }
    TClatType& writeType() { return write_type; }

    bool poss_type_incl_visited; //- used by TCAstate::initPossTypeConstraintsInclusion
    suco_set<ECR *>& inclToECRs() { return inclTo; }

    void propagateInfluential();
    void propagateExposed();

    void touchExposedAndPropagate();

    void markVulnerableDerefAndPropagate();

    int getEcrNo(FILE * outf = 0); //- if outf, then output inclTo edges if unassigned

  private:
    ECR() : poss_type_incl_visited(false),
	    aoset(),
	    fwdptr(0),
	    ptsFrom(),
	    ptsTo(0),
	    inclFrom(),
	    inclTo(),
	    alias_ecrset(0),
	    argret(0),
	    invalid(false),
	    poss_type(TClatType::tclTop),
	    write_type(TClatType::tclTop),
	    influential(false),
	    exposed(false),
	    touched(false),
	    is_vuln_deref(false),
	    ecrno(0),
	    traverseTag(traverseCounter)
	    {
		poss_type.constrainLE(write_type);
	    }

    //---------------
    //-- PTA members
    suco_set<AO *> aoset;
    ECR * fwdptr;
    suco_set<ECR *> ptsFrom;
    ECR * ptsTo;
    suco_set<ECR *> inclFrom;
    suco_set<ECR *> inclTo;

    suco_set<ECR *> * alias_ecrset;	//- cache of this ECR's alias set

    ECRargRet * argret;

    //--------------------
    //-- post-PTA members
    bool invalid; //- indicates if ECR represents "invalid dereference"

    TClatType poss_type;
    TClatType write_type; //- extra node to make constraint solving more efficient

    bool influential; //- used to propagate influential/exposedness
    bool exposed;     //  (one forward, one backward, along incl edges)

    bool touched;	//- used by range analysis (and other flow-sensitive analyses?)
			//  to indicate an exposed location is referenced
    bool is_vuln_deref; //- identify vulnerable dereferences

    int ecrno; //- unique ID# for this ecr, assigned late, before output

    //-------------------------
    //-- miscellaneous members
    //- used to mark visited ECRs while traversing
    //  - used in: followInclEdges (from traverseAliases,traverseSetAliases)
    //		   findInclToCycle (from includesTo)	** I _think_ findInclToCycle and findPtsToCycle
    //		   findPtsToCycle (from pointsTo)	** don't clash, but am not sure
    //		   collectArgRetFrontier (from includesTo)
    //		   inclToExposed (from AO::pointsToExposed)
    //             finalizeECR/garbageCollect (from TCAstate::supplementalPTanalysis)
    //  - must make sure there are no clashes!
    static int traverseCounter;
    int traverseTag;

    void finalizeECR();
    static void finalizeECRset(suco_set<ECR *>& eset);
    static void garbageCollect(); //- called by TCAstate (friend)

    static suco_llist<ECR *> ecr_pool; //- for garbage collection

    //-- private functions
    ECRargRet * detachArgRet(); //- also adjusts ref count

    void collectArgRetFrontier(suco_set<ECR *>& frontier, ECRargRet& ar);
    static void simulateAssign(int argno, ECRargRet& largret, ECRargRet& rargret); // remember, argno is one-based
    void processArgRetFlow(ECRargRet& largret, ECRargRet& rargret);

    bool findPtsToCycle(ECR& dest, suco_llist<ECR *>& cyEcrs);
    bool findInclToCycle(ECR& dest, suco_llist<ECR *>& cyEcrs);

    ExposedStatus inclToExposed(bool limit_malloc, bool do_touched, bool do_vuln); // called by AO::pointsToExposed

    void linkAO(AO&);
    void absorb(ECR& ecr);

    //- follows inclusion edges, while true; if either fp returns false, stop and return false
    bool followInclEdges(bool (*fp)(AO& o), bool (*ecrfp)(ECR& e)); //- helper for traverseAliases
};

//------------------------------------------------------

#endif /* } ifdef TC_ECR_H */
@


1.47
log
@Added "/V" output (freearg status for vuln mode).
Entailed hackishly modifying ECR::inclToExposed().
@
text
@d208 1
a208 1
    AO::exposed_status inclToExposed(bool limit_malloc, bool do_touched, bool do_vuln); // called by AO::pointsToExposed
@


1.46
log
@MAJOR ADDITION: added -vuln mode computations to output
1. vulnerable locations (function pointers and first
   arguments to exec,system,longjmp,...)
2. vulnerable dereferences (any Ref ao that may point
   to a vulnerable location)
@
text
@d208 1
a208 1
    AO::exposed_status inclToExposed(bool limit_malloc, bool do_touched); // called by AO::pointsToExposed
@


1.45
log
@Added helper function ECR::debug_dump_list().
@
text
@d123 2
d143 1
d175 1
@


1.44
log
@Fixed efficiency bug: in ECR::collectAliasECRs, the
"has_locs" filter mechanism was removing non-loc ECRs
from the list too early, so the same sub-graph would've
been traversed multple times.
Now, loc-filtering is done separately, by a new function
ECR::filterLocArgRet().
@
text
@d72 1
@


1.43
log
@MAJOR UPDATE: towards relevant aos.
THIS VERSION RELIES ON ExpDescr's aoset TO CAPTURE
ALL DEPENDENCE INFORMATION, WHICH IS NOT THE CASE.
@
text
@d86 1
a86 1
    void collectAliasECRs(suco_set<ECR *>& eset, bool limit_loc = true, bool affecting = false);
d88 2
@


1.42
log
@More work towards filtering relevant AOs:
 - Added flag -relevant-aos
 - AO added "dfa_relevant" bit for each AO
 - ECR added "collectInclFromECRs() helper that's
   needed when collecting relevant aos
 - TCA added a bunch of helpers:
   - markRelevantLocs() which calls
     1. clearRelevantTags() on each AO, to clear
        the dfa_relevant tags
     2. markStartingPoints(), which walks the
        assignment edges (in the CFG!) to populate
        the initial set of aos (based on readwrite
        flag and whether we want to mark safe AOs
        (for MBU) or unsafe ones (for RAN)).
     3. propagate along (flow-insensitive) assign
        edges.
@
text
@d86 1
a86 1
    void collectAliasECRs(suco_set<ECR *>& eset);
@


1.41
log
@Added routines to "finalize" ecrset after pt-analysis:
- added new factory method to keep the set of all
  allocated ECRs, to allow garbage collection when
  "finalizing";
- finalizers are called in tca.cpp:supplementalPTanalysis.
In tca.cpp: started adding code to compute filter set
for ptr-MBU analysis -- current version is very slow.
@
text
@d87 1
@


1.40
log
@Added function fixECR() to finalize points-to graph
ECR mappings.
@
text
@d13 1
a13 1
{
d16 3
a18 3
    ECRargRet(ECR& mp): main_parent(mp), fwdptr(0),
			ret(0), args(0), argsize(0), nargs(max_nargs),
			refcount(0) {}
d23 1
a23 1
    ECR& getMainParent() const { return main_parent; }
d36 2
d42 2
d49 1
a49 1
    ECR& main_parent;
d69 1
a69 21
    ECR() : poss_type_incl_visited(false),
	    aoset(),
	    fwdptr(0),
	    backptr(),
	    ptsFrom(),
	    ptsTo(0),
	    inclFrom(),
	    inclTo(),
	    alias_ecrset(0),
	    argret(0),
	    invalid(false),
	    poss_type(TClatType::tclTop),
	    write_type(TClatType::tclTop),
	    influential(false),
	    exposed(false),
	    touched(false),
	    ecrno(0),
	    traverseTag(traverseCounter)
	    {
		poss_type.constrainLE(write_type);
	    }
d122 21
a146 1
    suco_set<ECR *> backptr; //- needed for garbage-collection only?
d179 1
a180 1
    //TODO: use also to detect pointsTo cycles
d183 6
@


1.39
log
@Eliminated ECR::ecrsToLocAOs() -- functionality migrated
to ECRlocSet::addToAOset().
@
text
@d116 1
@


1.38
log
@Renamed ECR::setToNonLocAOset() to ECR::ecrsToLocAOs().
(Old name was a misnomer!)
@
text
@a101 2
    static void ecrsToLocAOs(suco_set<ECR *>& ecrset, suco_set<AO *>& aoset);

@


1.37
log
@Added comment output to diagnose tracked-ness of
longjmp buffers.
@
text
@d102 1
a102 1
    static void setToNonLocAOset(suco_set<ECR *>& ecrset, suco_set<AO *>& aoset);
@


1.36
log
@CHANGE 1: wrote ECR::getAliasECRs(), which collects and
  caches an ecrset of alias ECRs.
  This function replaces the functionality of
  collectAliasECRs(), but should only be called after
  the points-to graph is finalized.
CHANGE 2: changed RAN and REDp to account for MayFree
  set (CFGfunction::getGFreeHeap()).
  For RAN, this affected: filterCallsiteFact,
  intraProcHandleCall, and handleFreeCall (previously
  empty).
  For RED, this affected only REDp::intraProcHandleCall.
  For CFGfunction: added gfreeheap_ecrs/getGFreeHeapEcrs()
  to cache the freeheap ecrset for use in the above
  phases.
@
text
@d63 1
a63 1
    friend class TCAstate; //-- give access to traverseCounter
@


1.35
log
@DONE implementing backedge filter stuff:
 - introduced new helper ECR::setToNonLocAOset
   (also used by earlier code for IMOD/IREF collection)
 - "borrowed" use of CFGfunction stuff that's used for
   IMOD/IREF collection.
 - Appears to work.
@
text
@d73 1
d106 6
d148 2
@


1.34
log
@1. Adjustment to "_" (untouched exposed aos) behavior: reports only
   one status, rather than a separate status for ptr/ptrw as was done
   before.  This is because the tsl analysis is already dependent on
   ptr/ptrw-ness, so it makes no sense to report both when doing one
   particular analysis.
   Involved change to ECR class definition (used to have two booleans
   touched_ptr/touched_ptrw; now just one).

2. Updated "/" (freearg) to account for untouched-ness: by adding
   a flag to AO::pointsToExposed/ECR::inclToExposed saying whether
   or not to check the touched flag.
@
text
@d101 2
@


1.33
log
@1. Added code to find untouched exposed locations (so they
   can be unexposed/untracked):
   - in ECR, added members touched_ptr, touched_ptrw
   - in RANc(FactHandler), for each Verify, touch the
     affected ECRs
   - at the end, traverse all AOs, and for each EXPOSED
     ao that's untouched, output a "_ [T|U] [T|U] <O>"
     line (T=touched, U=untouched; 1st=ptr, 2nd=ptrw).
   - (sml code has concurrently been modified to read
     those lines and treat <O> as SAFE when untouched)
2. Behavioral change: -cde-incl and -cde-pt are now
   on by default!
@
text
@d79 1
a79 2
	    touched_ptr(false),
	    touched_ptrw(false),
d125 1
a125 1
    void touchExposedAndPropagate(bool ptrw);
d152 2
a153 2
    bool touched_ptr;	//- used by range analysis (and other flow-sensitive analyses?)
    bool touched_ptrw;	//  to indicate an exposed location is referenced
d180 1
a180 1
    AO::exposed_status inclToExposed(bool limit_malloc); // called by AO::pointsToExposed
@


1.32
log
@Changed argument to find_Cycle() from suco_set to suco_llist,
so the cycle collapse will consume the nodes linearly rather
than randomly.
@
text
@d79 2
d126 2
d152 3
@


1.31
log
@Added implementation of cycle detection and elimination
of points-to cycles (had previously only implemented
for includes-to cycles).
CAVEAT: it's unclear whether the two algorithms will
clash; am now testing.
@
text
@d171 2
a172 2
    bool findPtsToCycle(ECR& dest, suco_set<ECR *>& cyEcrs);
    bool findInclToCycle(ECR& dest, suco_set<ECR *>& cyEcrs);
@


1.30
log
@Gave the code the -Wall treatment: adjusted things to
get rid of warnings:
 - reordered initializers to match declaration order
 - made some destructors virtual (note that for many
   classes with no explicit destructors, I did not
   add explicit virtual destructors, so -Wall warnings
   remain)
 - made some signed/unsigned casts
 - made some pointer/unsigned int casts for printfs
 - filled in unaccounted-for cases in switch statements
@
text
@d155 2
a156 1
    //		   findInclToCycle (from includesTo)
d171 1
@


1.29
log
@HEAPSTACK UPDATE: enhance -ptr/-ptrw mode to optionally consider
freed-heap and stack locations as "possibly invalid" locations.

Augmented markInvalid to take a flag propDeref, to determine
whether or not to propagate "invalid" down dereference.
True: p invalid => *p invalid - used to mark "virtual"
      invalid locations, like what VALUE_int points to
False: p invalid =/=> *p invalid - used to mark "real"
       locations marked invalid, e.g. stack variable.
@
text
@d45 2
a47 2

    ECR& main_parent;
@


1.28
log
@Wrote different version of TCAstate::addReturnNodeAliases
for -cde-incl to prevent clash with includesTo (which may
result in non-terminating recursion, due to sharing of
ECR::traverseTag). Note: cde seems significantly slower --
not sure if due to the cde or to the change in this function.
@
text
@d102 1
a102 1
    void markInvalid(); // marks invalid, and propagate
@


1.27
log
@Added -cde-incl and -cde-pt flags -- only the latter
has been implemented: in ECR::includesTo, check for
cycle, and collapse these ECRs; also, remove redundant
inclTo/inclFrom edges as a result of the collapse.
Also, the output for -pta mode has been modified to
be more a summary, to allow better comparison between differnet
versions.
@
text
@d154 6
a159 1
//TODO: use these to do cycle detection and elimination: ptsTo and incl loops
@


1.26
log
@Fixed collectAliasECRs, which was incorrect -- it used
the traverseAlias short-circuiting mechanism which would
terminate traversals prematurely.
Rewrote as a single recursive function -- which turns out
to be rather small and simple.
@
text
@d94 1
a94 1
    bool includesTo(ECR& ecr);
d164 2
@


1.25
log
@Updated redundant analysis: strong and weak assignments written;
to do: function calls and result collection.
Entailed following changes:
  PExprAssign::getLHS to return ExpDescr instead of AO set.
  DFA handleWeakAssign's second argument is now ExpDescr rather than AO set.
  ECR: added helper collectAliasECRs (not tested!)
@
text
@a164 4
    //- helpers for collectAliasECRs
    static suco_set<ECR *> * cae_eset;
    static bool cae_add_ecr(ECR& e);

@


1.24
log
@Suco change (major):
 1. Added new file suco_usage.cpp as a hack to instantiate
    the suco code only once, rather than once-per-file as
    before.
 2. Suco now has node-recycling mechanism in place, which
    seems to help with rtca performance.
@
text
@d100 2
d164 4
@


1.23
log
@Augmented traverseSetAliases to also pass AO function
(was previously just commented out, expecting it not
to be needed)
@
text
@a8 1
#include "suco.cpp"
@


1.22
log
@CFG: wrote MBUfacts test for intersection between a MBUfact
and an AOset's alias set (done using ECR::traverseAliases).
Cascaded changes to AO/ECR include:
1. AO::ts_categ is now explicitly enumerated to allow >=
   comparison
2. ECR::traverseAliases now takes bool functions, and
   returns a bool, true if all applications return true,
   and false if *any* application returns false (and also
   halts traversal -- this is an optimization for the
   intersection check added: once an intersection is found,
   no further traversal is needed).
@
text
@d99 1
a99 1
    static bool traverseSetAliases(suco_set<ECR *>& eset, /* bool (*aofp)(AO& o),*/ bool (*ecrfp)(ECR& e) = 0);
@


1.21
log
@Reduced scope of AOlist class: this is only to be used
specially within the AO tree to look up AOs.
All other occurrences (in ecr, cfg, etc) have been converted
to use suco_set<AO *>.
Should be no change in behavior.
@
text
@d97 3
a99 2
    //- follows inclusion edges
    void traverseAliases(void (*aofp)(AO& o), void (*ecrfp)(ECR& e) = 0);
d169 2
a170 1
    void followInclEdges(void (*fp)(AO& o), void (*ecrfp)(ECR& e)); //- helper for traverseAliases
@


1.20
log
@Added freearg handling: for each assignment to the first
argument of free, check to see if the argument points to
none, some, or all exposed objects -- with current implementation
it is sufficient to check the exposed flag of the corresponding
ECR objects (but must still follow inclTo edges).
Note -- attributes for two policies are computed, one considering
all AOs, another considering only Malloc AOs. The latter is unsafe
(but "usually safe", one would hope), but likely more efficient.
Output is "/ A M O" where A is the status for all AOs, M for malloc
AOs only, and O the AO in question.
@
text
@d67 1
a67 1
	    aolist(),
d90 1
a90 1
    AOlist& getAOlist() { return aolist; }
d127 1
a127 1
    AOlist aolist;
@


1.19
log
@Added mechanism to collect stats about safe/unsafe tracked/untracked
pointer/fnptr/ptrs-in-structs/locations; involved various new additions
(including 'f' defined-function directive from instr-ast.sml)
@
text
@d13 2
a14 1
class ECRargRet {
d59 2
a60 1
class ECR {
a102 2
    bool pointsToExposed() { return (ptsTo != 0) && (ptsTo->followECR().exposed); }

d162 2
@


1.18
log
@Major Revision: include ECR number and incl-to edges in output.
@
text
@d101 2
@


1.17
log
@Added Type-safety Category assignment.
(major change).
Appears working, tested on gcc, verified on small examples,
not thoroughly verified.
Also, added -readable flag.
@
text
@d74 2
d78 1
a78 2
	    poss_type(TClatType::tclTop),
	    write_type(TClatType::tclTop),
d120 2
d140 1
a140 1
    TClatType write_type; //- extra node to make constraint solving more efficient?
d144 2
@


1.16
log
@Introduced "write-type" to assist in computation of
poss-type constraints -- performance improves drastically!
Verified results on gcc, ijpeg.
@
text
@d74 2
d98 1
d116 3
d138 3
@


1.15
log
@Finished (but not tested) initialization of poss-type
constraints.
This entailed creation of a root set (encapsulated by
the class TClatRootSet).
Also, to manipulate the traverseCounter, TCAstate is now
a friend of ECR -- I'm not sure I like this arrangement.
@
text
@d75 5
a79 1
	    traverseTag(traverseCounter) {}
d108 1
d131 1
@


1.14
log
@Intermediate checkin: started writing poss-type constraint
generation: added some needed data structures to ECR and
TClatType; initialized AO constraints and wrote helper
to process inclusion edges from a given ECR;
need to finally process assignments.
@
text
@d62 2
@


1.13
log
@Revamped TClatType;
renamed ECR::rtType to poss_type;
rewrote TCAstate functions for initializing poss-types;
also left a skeleton function for generating constraints.
Todo: augment TClatType with constraint graph capabilities,
generate contraints, and solve.
Also, AO needs to have required-type.
@
text
@d62 2
a63 1
    ECR() : aolist(),
d102 3
@


1.12
log
@Added routine to mark dereference nodes.
@
text
@d71 1
a71 1
	    rttype(),
d100 1
a100 1
    TClatType& rtType() { return rttype; }
d119 1
a119 1
    TClatType rttype;
@


1.11
log
@Finished "add arg-ret assignment" functionality;
entailed adding "mainParent" member to ECRargRet, which
refers to the main parent, which is used as the basis
for finding function pointer resolutions -- make sure
mainParent is set correctly -- that is, getArg is only
called in the PTA initialization function.
Also added a couple of static helper functions in tca,
and made a bunch of ECR/ECRargRet accessors public.
@
text
@d69 2
a71 1
	    argret(0),
d88 2
d103 2
d113 6
d121 6
a126 1
    ECRargRet * argret;
d128 1
a133 5

    //- used to mark visited ECRs while traversing
//TODO: use these to do cycle detection and elimination: ptsTo and incl loops
    static int traverseCounter;
    int traverseTag;
@


1.10
log
@Deleted ECRset and ECRsetIterator; replaced with suco set and iterator.
@
text
@d16 3
a18 1
    ECRargRet(): fwdptr(0), ret(0), args(0), argsize(0), nargs(max_nargs), refcount(0) {}
d20 1
a20 1
    void addArg(int argno, ECR& ecr);
d23 2
d28 5
d34 4
a37 2
    ECR *& getArgPtr(int argno);
    ECR& getArg(int argno);
d40 1
a40 1
    void absorbArgRet(int argno, ECR ** args, ECR * ret);
d47 2
d72 1
d77 2
d115 1
a115 1
    static void simulateAssign(int argno, ECRargRet& largret, ECRargRet& rargret);
@


1.9
log
@Expanded traverseAliasese to take two functions, one to traverse AOs,
another for ECRs (used by new debug funcion).
Also, more importantly, FIXED BUG with traversal program: did not
previously followECR, therefore many ECR/AOs were skipped in the
traversal.
@
text
@d8 2
a9 43

//------------------------------------------------------

class ECRset {
  public:
    friend class ECR;
    friend class ECRsetIterator;
    ECRset() : head(0) {}
    ~ECRset();

    bool insert(ECR& e); // returns true if new item, false if already present
    void debug_dump(FILE * os);
    void merge(ECRset& eset);
    void remove(ECR& e);
    bool isEmpty() const { return (head==0); }

  private:
    class node {
      public:
        node(ECR& e, node * n = 0) : ecr(e), next(n) {}
        ECR& ecr;
        node * next;
      private:
        node();
    };
    node * head;
    void insert_no_check(ECR& e);
};

//------------------------------------------------------

class ECRsetIterator {
  public:
    ECRsetIterator(ECRset& s): set(s), nptr(s.head), initial(true) {}
    void reset() { nptr = set.head; initial = true; }
    bool iterate();
    ECR * current();
  private:
    ECRsetIterator();
    ECRset& set;
    ECRset::node * nptr;
    bool initial;
};
d68 1
d71 2
d78 3
d86 2
a87 2
    ECRset backptr; //- needed for garbage-collection only?
    ECRset ptsFrom;
d89 2
a90 2
    ECRset inclFrom;
    ECRset inclTo;
a95 2
    ECRargRet * argRet();

d98 1
a98 1
    void collectArgRetFrontier(ECRset& frontier, ECRargRet& ar);
a106 1
    ECR& followECR();
@


1.8
log
@Added points-to set output option: -pta now dumps points-to sets
(alias groups)...
 - ao: added isRef flag/accessor
 - ecr.cpp/h: modified traversePointsToSet - is now traverseAliases
 - tca.cpp/h: top level callers.
@
text
@d102 2
d109 1
a109 1
    void traverseAliases(void (*fp)(AO& o));
d148 1
a148 1
    void followInclEdges(void (*fp)(AO& o)); //- helper for traverseAliases
@


1.7
log
@Added TClatType, added "rttype" member to ECR.
Now: ready to compute runtime-types.
@
text
@d107 1
a107 1
    void traversePointsToSet(void (*fp)(AO& o));
d146 1
a146 1
    void followInclEdges(void (*fp)(AO& o)); //- helper for traversePointsToSet
@


1.6
log
@renamed fixnargs to maxnargs
@
text
@d97 1
d114 1
d124 2
@


1.5
log
@3) added -fixnargs flag to compute max nargs and use
   that for all argrets. simpler solution...

4) added fwdptr to argret - necessary to ensure
   correctness (?).
   This resulted in a major overhaul - argret::absorb
   must now be wary of clashes with ecr::absorb -
   added recursive trick, etc.
   Currently seems to work, but have not validated results.
   NOTE: this change resulted in a crash that was eliminated
   only after I removed both deletes of argrets. FIND BUG!?!
@
text
@d57 1
a57 1
    ECRargRet(): fwdptr(0), ret(0), args(0), argsize(0), nargs(fix_nargs), refcount(0) {}
d63 1
a63 1
    static int getFixNargs() { return fix_nargs; }
d73 1
a73 1
    static int fix_nargs;
@


1.4
log
@Major change: added ArgRet handling stuff:
defined ECRargRet class, wrote functions
ECR::processArgRetFlow/simulateAssign/collectArgRetFrontier...
Only aspect not handled: after simulating assignment for
argrets with different nargs, must propagate the delta
(forward or backward) - requires non-trivial change
to data structure.
@
text
@d57 1
a57 1
    ECRargRet(): ret(0), args(0), argsize(0), nargs(0), refcount(0) {}
d61 3
a63 1
    void absorb(ECRargRet * ar);
d70 7
d124 2
@


1.3
log
@(Added ECRset?)
Wrote OLF points-to analysis, which seems to work (but no
cycle-elimination), with fwdptr mechanism (fast-union find).
@
text
@d54 23
d80 1
d88 1
d95 1
a95 1
    void includesTo(ECR& ecr);
d103 2
d113 8
@


1.2
log
@Removed fwdptr; rewrote unifyECR to move everything to
single ECR.
@
text
@d11 43
d58 2
d61 1
a61 1
	    ptsTo(),
d63 2
a64 1
	    inclTo() {}
d67 6
a72 2
    void pointsTo(ECR& e);
//    void includesTo(ECR& e);
d80 15
a94 4
    TCedgeSet ptsFrom;
    TCedgeSet ptsTo;
    TCedgeSet inclFrom;
    TCedgeSet inclTo;
d96 1
a96 1
    void unify(AO&);
@


1.1
log
@Initial revision
@
text
@a14 1
	    fwdptr(0),
a29 1
    ECR * fwdptr;
d35 1
a35 1
    void link(AO&);
@
