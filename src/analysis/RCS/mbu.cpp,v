head	1.53;
access;
symbols;
locks; strict;
comment	@// @;


1.53
date	2004.07.19.22.59.54;	author suan;	state Exp;
branches;
next	1.52;

1.52
date	2004.07.16.21.27.34;	author suan;	state Exp;
branches;
next	1.51;

1.51
date	2004.07.16.19.46.35;	author suan;	state Exp;
branches;
next	1.50;

1.50
date	2004.07.16.02.29.08;	author suan;	state Exp;
branches;
next	1.49;

1.49
date	2004.06.15.20.09.55;	author suan;	state Exp;
branches;
next	1.48;

1.48
date	2004.05.20.19.23.27;	author suan;	state Exp;
branches;
next	1.47;

1.47
date	2004.05.18.21.13.45;	author suan;	state Exp;
branches;
next	1.46;

1.46
date	2004.05.17.22.34.44;	author suan;	state Exp;
branches;
next	1.45;

1.45
date	2004.05.07.19.52.39;	author suan;	state Exp;
branches;
next	1.44;

1.44
date	2004.05.02.18.26.36;	author suan;	state Exp;
branches;
next	1.43;

1.43
date	2004.04.14.00.22.35;	author suan;	state Exp;
branches;
next	1.42;

1.42
date	2004.04.07.21.07.14;	author suan;	state Exp;
branches;
next	1.41;

1.41
date	2004.04.07.18.02.03;	author suan;	state Exp;
branches;
next	1.40;

1.40
date	2004.04.07.17.38.56;	author suan;	state Exp;
branches;
next	1.39;

1.39
date	2004.04.05.18.16.29;	author suan;	state Exp;
branches;
next	1.38;

1.38
date	2004.03.18.21.21.28;	author suan;	state Exp;
branches;
next	1.37;

1.37
date	2004.02.24.23.48.16;	author suan;	state Exp;
branches;
next	1.36;

1.36
date	2004.02.24.19.29.20;	author suan;	state Exp;
branches;
next	1.35;

1.35
date	2004.02.17.19.24.20;	author suan;	state Exp;
branches;
next	1.34;

1.34
date	2003.12.11.21.03.59;	author suan;	state Exp;
branches;
next	1.33;

1.33
date	2003.12.11.19.18.20;	author suan;	state Exp;
branches;
next	1.32;

1.32
date	2003.12.11.18.26.35;	author suan;	state Exp;
branches;
next	1.31;

1.31
date	2003.11.13.00.23.51;	author suan;	state Exp;
branches;
next	1.30;

1.30
date	2003.10.08.23.31.07;	author suan;	state Exp;
branches;
next	1.29;

1.29
date	2003.10.08.16.31.43;	author suan;	state Exp;
branches;
next	1.28;

1.28
date	2003.10.01.22.18.32;	author suan;	state Exp;
branches;
next	1.27;

1.27
date	2003.02.22.00.11.49;	author suan;	state Exp;
branches;
next	1.26;

1.26
date	2003.02.21.17.40.11;	author suan;	state Exp;
branches;
next	1.25;

1.25
date	2003.02.14.17.41.44;	author suan;	state Exp;
branches;
next	1.24;

1.24
date	2003.02.13.21.02.04;	author suan;	state Exp;
branches;
next	1.23;

1.23
date	2003.02.13.20.50.17;	author suan;	state Exp;
branches;
next	1.22;

1.22
date	2003.02.13.20.45.06;	author suan;	state Exp;
branches;
next	1.21;

1.21
date	2003.02.12.21.12.14;	author suan;	state Exp;
branches;
next	1.20;

1.20
date	2003.02.04.17.04.14;	author suan;	state Exp;
branches;
next	1.19;

1.19
date	2003.01.20.19.46.55;	author suan;	state Exp;
branches;
next	1.18;

1.18
date	2003.01.20.18.24.37;	author suan;	state Exp;
branches;
next	1.17;

1.17
date	2003.01.17.20.51.21;	author suan;	state Exp;
branches;
next	1.16;

1.16
date	2003.01.17.20.15.48;	author suan;	state Exp;
branches;
next	1.15;

1.15
date	2003.01.16.21.19.32;	author suan;	state Exp;
branches;
next	1.14;

1.14
date	2003.01.16.20.58.10;	author suan;	state Exp;
branches;
next	1.13;

1.13
date	2003.01.16.19.30.49;	author suan;	state Exp;
branches;
next	1.12;

1.12
date	2003.01.16.17.45.59;	author suan;	state Exp;
branches;
next	1.11;

1.11
date	2003.01.15.21.19.39;	author suan;	state Exp;
branches;
next	1.10;

1.10
date	2003.01.14.21.10.06;	author suan;	state Exp;
branches;
next	1.9;

1.9
date	2003.01.10.16.31.00;	author suan;	state Exp;
branches;
next	1.8;

1.8
date	2003.01.09.17.16.56;	author suan;	state Exp;
branches;
next	1.7;

1.7
date	2003.01.07.20.01.38;	author suan;	state Exp;
branches;
next	1.6;

1.6
date	2002.12.24.21.22.32;	author suan;	state Exp;
branches;
next	1.5;

1.5
date	2002.12.23.21.21.14;	author suan;	state Exp;
branches;
next	1.4;

1.4
date	2002.12.21.00.01.06;	author suan;	state Exp;
branches;
next	1.3;

1.3
date	2002.12.20.23.06.38;	author suan;	state Exp;
branches;
next	1.2;

1.2
date	2002.12.20.20.59.32;	author suan;	state Exp;
branches;
next	1.1;

1.1
date	2002.12.20.00.07.02;	author suan;	state Exp;
branches;
next	;


desc
@May-Be-Uninit (MBU) Analysis.
Extends Dataflow Analysis (DFA) class.
@


1.53
log
@Added -mbu-intra-iref flag to collect iref in addition
to gref, and to just use iref for MBU analysis -- hopefully
will lead to smaller facts and faster analysis.
Also: observed that "gmodref_skip_locals" has been set
all along (for ran?), so mbu may not have been correct??
Fixed --- at least partially, for mbu --- I think...
@
text
@#include <stdio.h>
#include <stdlib.h> // for qsort, used in print_debug_stats
#include "ao.h"
#include "ecr.h"
#include "cfg.h"
#include "mbu.h"
#include "flags.h" // for flag_verbose, flag_may_be_uninit
#include "diag.h" // for TCstats

//----------------------------------
// MAY-BE-UNINIT ANALYSIS
//----------------------------------

DFAfact& MBUfact::newClone(bool preserve)
{
  MBUfact& nmf = *new MBUfact;
  nmf.meet(*this, preserve);
  return nmf;
}

//-- set union
// - preserve=false means we are free to tamper with df
// - warnNotLE=true: warn if this has elements not in df
//   --> in this version, this warning is not reported! (except when bottom)
// - returns true if df has elements not in this
bool MBUfact::meet(DFAfact& df, bool preserve, bool warnNotLE)
{
  MBUfact& mf = (MBUfact&) df;

  if(mf.is_bot){ //- meet with bot: set to bot

    bool ret = !this->is_bot;

    this->is_bot = true;
    this->aoset.Clear();

    return ret;

  } else if(this->is_bot) { //- already bot: do nothing

    if(warnNotLE) {
      fprintf(stderr, "Meet: Higher Than Bottom!: ");
      mf.debug_dump(stderr);
    }

    return false;

  } else { //- non-bot meet with non-bot

    int precount = this->length();

    if(preserve){
      this->aoset.Union(mf.aoset);
    } else {
      this->aoset.UnionConsume(mf.aoset);
    }

    int postcount = this->length();

    return (postcount > precount);
  }
}

//-- set intersection
// - preserve=false means we are free to tamper with df
void MBUfact::join(DFAfact& df, bool preserve)
{
  MBUfact& mf = (MBUfact&) df;

  if(mf.is_bot) { //- join with bot: do nothing

    //- nop

  } else if(this->is_bot) { //- this is bot: set to mf

    this->is_bot = false;
    this->aoset.Clear(); //-- redundant
    this->meet(mf, preserve);

  } else { //- join non-bot with non-bot

    this->aoset.Intersect(mf.aoset);

  }
}

void MBUfact::debug_dump(FILE * outf, bool brief)
{
  if(is_bot){
    fprintf(outf, "bot\n");
  } else if(brief){
    fprintf(outf, " %d aos\n", this->length());
  } else {

    fprintf(outf, "\n");

    suco_iterator<AO *> aoi(aoset);
    while(aoi.Iterate()){
      fprintf(outf, "\t[ ");
      aoi.Current()->write_string_rep(outf, true);
      fprintf(outf, " ]\n");
    }
  }
}

//----------------------------------

//-- static helpers for addRelevantAliasLocs
MBUfact * MBUfact::aual_fact = 0;
bool MBUfact::add_locs_to_aual_fact(AO& ao)
{
  if(MBUfact::aual_fact && ao.isLoc() && ao.dfa_relevant)
    aual_fact->insertComponentAOs(ao);
  return true;
}

//-- traverse aliases of aoset, add safe and exposed locs
//   to this.
void MBUfact::addRelevantAliasLocs(suco_set<AO *>& laoset)
{
  //-- collect aoset's ecrset
  suco_set<ECR *> ecrset;
  suco_iterator<AO *> aoi(laoset);
  while(aoi.Iterate())
    ecrset.Insert(&aoi.Current()->getECR());

  //-- set aual_fact
  MBUfact::aual_fact = this;

  //-- do traversal
  ECR::traverseSetAliases(ecrset, MBUfact::add_locs_to_aual_fact);
}

//-- static helpers for intersectsAliases --
suco_set<ECR *> MBUfact::ia_ecrset;

bool MBUfact::is_ia_ecrset(ECR& ecr)
{
  return !MBUfact::ia_ecrset.Contains(&ecr);
}

suco_set<ECR *> MBUfact::cfr_ecrset;

bool MBUfact::collectFnReturns(AO& ao)
{
  if(ao.getKind() == AO::aoFunction){
    AO& ret = ((AOFunction &)ao).getTarget().get_AOReturn();
    MBUfact::cfr_ecrset.Insert(&ret.getECR());
  }
  return true;
}

//-- check to see if this intersects with the alias set of aoset.
//   We'll do this by collecting this' ecrset, and do a traversal
//   of aoset's ecrs to see if they reach any of this' ecrset.
// - OPTIMIZATION: can skip ecrs for value AOs
bool MBUfact::intersectsAliases(suco_set<AO *>& raoset)
{
  //-- collect this's aos' ecrset
  MBUfact::ia_ecrset.Clear();
  suco_iterator<AO *> taoi(this->aoset);
  while(taoi.Iterate()){
    MBUfact::ia_ecrset.Insert(&taoi.Current()->getECR());
  }

  //-- collect raoset's ecrset -- exclude values! (optimization)
  //				- and special handling for return nodes
  MBUfact::cfr_ecrset.Clear();
  suco_iterator<AO *> raoi(raoset);
  while(raoi.Iterate()){
    AO& rao = *raoi.Current();
    if(!rao.isVal()){
      MBUfact::cfr_ecrset.Insert(&rao.getECR());
    }
  }

  //-- do traversal
  return !ECR::traverseSetAliases(MBUfact::cfr_ecrset, 0, MBUfact::is_ia_ecrset);
}

MBUfact * MBUfact::nsao_mbf = 0;

void MBUfact::collectNonStructAO(AO& ao)
{
  if(ao.isLocArgRet() && ao.getStaticType()
	&& ao.getStaticType()->getKind() != TCtype::tcStruct
	&& ao.getStaticType()->getKind() != TCtype::tcUnion){
    MBUfact::nsao_mbf->aoset.Insert(&ao);
  }
}

void MBUfact::removeAO(AO& ao)
{
  if(ao.isLocArgRet()){
    MBUfact::nsao_mbf->aoset.Remove(&ao);
  }
}

//- (if AO is a struct/union) insert scalar components of AO
//  - optimize: unless root ao is a malloc, then it's pointless
void MBUfact::insertComponentAOs(AO& ao)
{
  if(ao.isLocArgRet() && (ao.getEnclosingStruct().getKind() != AO::aoMalloc)
	&& ao.getStaticType()
	&& (ao.getStaticType()->getKind() == TCtype::tcStruct
	   || ao.getStaticType()->getKind() == TCtype::tcUnion)){
    MBUfact::nsao_mbf = this;
    ao.traverseAOs(MBUfact::collectNonStructAO);
    MBUfact::nsao_mbf = 0;
  } else {
    this->aoset.Insert(&ao);
  }
}

//- (if AO is a struct/union) remove scalar components of AO
void MBUfact::removeComponentAOs(AO& ao)
{
//TODO: if ao is a struct, remove its component scalars
  if(ao.isLocArgRet() && ao.getStaticType() &&
	(ao.getStaticType()->getKind() == TCtype::tcStruct
	|| ao.getStaticType()->getKind() == TCtype::tcUnion)){
    MBUfact::nsao_mbf = this;
    ao.traverseAOs(MBUfact::removeAO);
    MBUfact::nsao_mbf = 0;
  } else {
    this->aoset.Remove(&ao);
  }
}

//----------------------------
// MBUfactHandler

MBUfactHandler MBUfactHandler::handler;

void MBUfactHandler::filterCallsiteFacts(PExprCall& dc, DFAfact& df, DFAfact& df_local)
{
  MBUfact& mbf = (MBUfact&) df;
  MBUfact& mbf_local = (MBUfact&) df_local;

  //- 1. move all facts to mbf_local
  mbf_local.meet(mbf, false);

  //- 2. filter GREF elements back into mbf
//TODO: filter also MayFreed pointers?
  suco_iterator<CFGfunction *> tfi(dc.getTargetFns());
  while(tfi.Iterate()){
    suco_iterator<AO *> aoi(mbf_local.aoset);
    while(aoi.Iterate()){
      AO * tao = aoi.Current();
      if(tfi.Current()->getGREF().Contains(*tao)){
        aoi.DeleteCurrent();
        mbf.aoset.Insert(tao);
      }
    }
  }

  //- 3. specially handle call arguments
//  for(int i = 1; dc.getArg(i); ++i)
//    mbf_local.filterInto(dc.getArg(i)->getDesc().getAOs(), mbf);
//TODO: migrate to interProcHandleCallArgs below
}

void MBUfactHandler::interProcHandleCallArgs(DFAfact& df, PExprCall& dc)
{
//TODO-- replace "specially handle call arguments" code above?
}

void MBUfactHandler::interProcHandleRetvalAssign(DFAfact& df, PExprCall& dc)
{
//TODO
}

DFAfact& MBUfactHandler::lookupNodeFact(CFGnode& cn, CFGnode * tfSucc)
{
  return cn.getMBUfact();
}

DFAfact& MBUfactHandler::lookupNodeFact(PExprCall& dc)
{
  return dc.getMBUfact();
}

DFAfact& MBUfactHandler::lookupNodeFact(PExprParallel& dp)
{
  return dp.getMBUfact();
}

bool MBUfactHandler::handleStrongAssign(DFAfact& df, AO& lhs, ExpDescr& rhs,
				 PgmExpr * dnode, PgmStmt * cnode, PExprArg * arg)
{
  MBUfact& mf = (MBUfact&) df;
  if(lhs.dfa_relevant){
    if(flag_may_be_uninit < 4 && mf.intersectsAliases(rhs.getAOs())){
      mf.insertComponentAOs(lhs);
    } else {
      mf.removeComponentAOs(lhs);
    }
    return false;
  } else return true; //- useless
}

bool MBUfactHandler::handleWeakAssign(DFAfact& df, ExpDescr& lhs, ExpDescr& rhs, PExprAssign& dnode)
{
  MBUfact& mf = (MBUfact&) df;
  if(flag_may_be_uninit < 4){
    if(AO::getSetTSC(lhs.getAOs()) >= AO::TSC_EXPOSED){
      if(mf.intersectsAliases(rhs.getAOs())){
        mf.addRelevantAliasLocs(lhs.getAOs());
      } //-- else cannot kill anything
      return false;
    } else return true; //- useless
  } else return true;
}

bool MBUfactHandler::handleFormal(DFAfact& df, PExprDecl& dd, CFGfunction& parfn, bool interproc)
{
  if(interproc){ //- interprocedural
    MBUfact& mf = (MBUfact&) df;
    if(flag_may_be_uninit < 3){
      if(dd.getAO().dfa_relevant){ //- skip if not safe (optimize)
        suco_iterator<PExprCall *> csi(parfn.getCallSites());
        while(csi.Iterate()){
          PExprArg * arg = csi.Current()->getArg(dd.getArgNo());
          if(arg){
            //-- process "weak" assignment [dd.ao] = argaos
            if(mf.intersectsAliases(arg->getDesc().getAOs())){
              mf.insertComponentAOs(dd.getAO());
            }
          } else { //-- this arg not included in callsite: set to uninit!?
                   // - note: may want to ignore -- assume PTA imprecision?
            mf.insertComponentAOs(dd.getAO());
          }
        }
        return false;
      } else return true; //- useless
    } else return true;
  } else { //- if intraprocedural, treat as declaration
    return handleDecl(df, dd);
  }
}

bool MBUfactHandler::handleReturnStmt(DFAfact& df, PgmStmt& retnode, ExpDescr * retedesc, bool interproc)
{
  bool is_useless = true;
  if(interproc){ //- interprocedural
    CFGfunction& parfn = retnode.getParentFunction();
    if(flag_may_be_uninit < 2 && retedesc){
      is_useless &= handleStrongAssign(df, parfn.getId().get_AOFunction().get_AOReturn(), *retedesc, 0, &retnode);
    }
    //-- filter out local vars, only if non-recursive
//TODO: think about this
    if(!parfn.getRecursionId()){
      is_useless = false;
      MBUfact& mf = (MBUfact&) df;
      suco_iterator<AOId *> lvi(parfn.getLocalVars());
      while(lvi.Iterate())
        mf.removeComponentAOs(*lvi.Current());
    }
  }
  return is_useless;
}

bool MBUfactHandler::handleDecl(DFAfact& df, PExprDecl& dd)
{
    
  MBUfact& mf = (MBUfact&) df;
  if((!dd.isZeroed()) &&
	(dd.isLocal() || dd.isMalloc()
	 || (flag_may_be_uninit < 3 && dd.isFormal()))){
    AO& ao = dd.getAO();
    if(ao.dfa_relevant){
      mf.insertComponentAOs(ao);
    }
    return false;
  } else return true; //- useless
}

bool MBUfactHandler::handleVerify(DFAfact& df, PExprVerify& dv)
{
  if(flag_vtfix){
    if(dv.getVtKind() == PExprVerify::vtTag){
      MBUfact& mf = (MBUfact&) df;
      AO * ao = dv.getDesc().getSingletonLoc();
      if(ao && ao->dfa_relevant){
        mf.removeComponentAOs(*ao);
      }
      return false; //- not useless
    }
  }
  return true; //- useless
}

void MBUfactHandler::interProcFilterEntryFact(DFAfact& df, CFGnode& cn) 
{
//NOP for now
}

//- for intra-procedural analysis: initialize fact df for entry node cn
//  - MBU: fact will be IMOD or GREF set, depending on flag_compute_iref
//    (i.e., conservatively assume all IREF/GREF variables may be uninitialized)
//  - NOTE: in IREF mode, it is unsafe at a callsite to correctly check
//    a called function's GREF against the current fact, which may yield
//    significantly-improved results --- doesn't seem to happen in practice.
//    See intraProcHandleCall().
void MBUfactHandler::intraProcInitializeEntryFact(DFAfact& df, CFGnode& cn)
{
  MBUfact& mf = (MBUfact&) df;

  if(flag_compute_iref){
    cn.getParentFunction().getIREF().addToAOset(mf.aoset);
  } else {
    cn.getParentFunction().getGREF().addToAOset(mf.aoset);
  }
  if(flag_gmodref_skip_locals){
    mf.aoset.Union((suco_set<AO *>&)cn.getParentFunction().getLocalVars());
  }

  //-optimization: keep only "relevant" aos:
  suco_iterator<AO *> aoi(mf.aoset);
  while(aoi.Iterate()){
    AO& ao = *aoi.Current();
    if(!ao.dfa_relevant
	|| ((flag_may_be_uninit == 4) && (ao.getEnclosingStruct().isZeroed())) //- if not handling assignments, filter out zeroed aos
	|| (ao.getStaticType()
	    && (ao.getStaticType()->getKind() == TCtype::tcStruct
		|| ao.getStaticType()->getKind() == TCtype::tcUnion))){
//TODO: filter out structs
      aoi.DeleteCurrent();
    }
  }
}

//- for each target function: 
//  - if target GREF doesn't intersect DF, then add nothing
//    (count how frequently this occurs!)
//  - else (common case?) add target GMOD to DF (filtered by local GREF)
//- also: add target's retnode (TODO)
void MBUfactHandler::intraProcHandleCall(DFAfact& df, PExprCall& dc)
{
  MBUfact& mf = (MBUfact&) df;

  if(flag_may_be_uninit < 4){ //- skip if not handling assignments

    suco_iterator<CFGfunction *> fni(dc.getTargetFns());
    while(fni.Iterate()){
      if(flag_compute_iref){ //- iref mode: don't try to "optimize"
        if(dc.getParentNode()){
	  dc.getParentNode()->getParentFunction().getIREF().writeIntersectingAOs(fni.Current()->getGMOD(), mf.aoset);
        }
      } else { //- gref mode: if fact and gmod don't intersect, can skip (don't think this happens ever!)
        if(fni.Current()->getGREF().Intersects(mf.aoset)){
          fni.Current()->getGMOD().addToAOset(mf.aoset);
//TODO: add struct fields? / filter out structs?
        } else if(flag_verbose) {
          //-- function doesn't access anything in mf - add nothing, but report
          fprintf(stderr, "NOTE: intra-proc skipped call to %s (MF size = %d, GREF size = ??)\n",
			fni.Current()->getId().getPid().getname(),
			mf.aoset.Length());
        }
      }
    }

    //- add { R D dc.Faos }  (actually, picking just one representative should be enough?
    suco_iterator<AO *> faoi(dc.getFaos());
    while(faoi.Iterate())
      mf.insertComponentAOs(faoi.Current()->get_AOStar().get_AOReturn());
  }
}

//----------------------------------
// MBUc1

//-- helpers for handleVerify/collectFact
MBUfact * MBUc1factHandler::cf_mf = 0;
RDAfact * MBUc1factHandler::cf_res = 0;

//-- helper for handleVerify
bool MBUc1factHandler::collectFact(AO& ao)
{
  // assert cf_mf?
  if(MBUc1factHandler::cf_mf->contains(ao)){
    MBUc1factHandler::cf_res->addFact(ao);
  }
  return true;
}

bool MBUc1factHandler::handleVerify(DFAfact& df, PExprVerify& dv)
{
  MBUfact& mf = (MBUfact&) df;

  //- diagnostic data
  {
    int mfsize = mf.length();
    TCstats::mbuc_verify_visit_factsizes += mfsize;
    if(TCstats::mbuc_verify_visit_max_factsize < mfsize)
       TCstats::mbuc_verify_visit_max_factsize = mfsize;
    TCstats::mbuc_verify_visits++;
  }

  switch(dv.getVtKind()){
    case PExprVerify::vtTag:
    case PExprVerify::vtRhs: {
        if(mf.intersectsAliases(dv.getAOs())){
          //-- include in results
          // - A. each AO in dv (so their aliases can be marked exposed)
          // - B. each AO in mf that intersects with dv's AOs (so their delta will be examined)

          // - A. collect dv's AOs
          suco_iterator<AO *> aoi(dv.getAOs());
          while(aoi.Iterate()){
            AO& ao = *aoi.Current();
            if(ao.dfa_relevant && ao.getTSC() >= AO::TSC_EXPOSED){
              this->results.addFact(ao, &dv);
            }
          }

          // - B. collect AOs in mf that intersect with dv's AOs
          //  - B1. collect dv ECRs
          suco_set<ECR *> dv_ecrs;
          suco_iterator<AO *> dvaoi(dv.getAOs());
          while(dvaoi.Iterate()){
            AO& dvao = *dvaoi.Current();
            if(!dvao.isVal()){
              dv_ecrs.Insert(&dvao.getECR());
            }
          }

          //  - B2. traverse dv ECRs; helper collectFact will do the work
          MBUc1factHandler::cf_mf = &mf;
          MBUc1factHandler::cf_res = &this->results;
          ECR::traverseSetAliases(dv_ecrs, MBUc1factHandler::collectFact);
        }
      } break;
    case PExprVerify::vtNone:
    default:
      break;
  }

//  MBUfactHandler::handler.handleVerify(mf, dv); // NOP anyways

  return false; //- not useless
}

//----------------------------------
// MBUc2

bool MBUc2factHandler::handleStrongAssign(DFAfact& df, AO& lhs, ExpDescr& rhs,
                            PgmExpr * dnode, PgmStmt * cnode, PExprArg * arg)
{
  bool inpre = ((MBUfact&)df).contains(lhs);
  MBUfactHandler::handler.handleStrongAssign(df, lhs, rhs, dnode, cnode, arg);
  bool inpost = ((MBUfact&)df).contains(lhs);
  if((inpre || inpost) && this->results.hasKey(lhs)){
    this->results.addFact(lhs, dnode, cnode, arg);
  }
  return false; //- not useless
}

//- case 1: rhs may-be-uninit
//		*p = rhs	// F = F U aliases(*p)
//	    -> must instrument
//- case 2: rhs not uninit
//		*p = rhs	// F = F
//	    -> if (aliases(*p)|results) intersects F
//	       then instrument
bool MBUc2factHandler::handleWeakAssign(DFAfact& df, ExpDescr& lhs, ExpDescr& rhs, PExprAssign& dnode)
{ 
  MBUfact& mf = (MBUfact&)df;
  int numpre = mf.length();
  MBUfactHandler::handler.handleWeakAssign(df, lhs, rhs, dnode); 
  int numpost = mf.length();
  if(numpre != numpost || mf.intersectsAliases(lhs.getAOs())){ //TODO: should further filter by this->results!
    suco_iterator<AO *> laoi(lhs.getAOs());
    while(laoi.Iterate()){
      AO& lao = *laoi.Current();
      if(!lao.isVal() && (lao.getTSC() >= AO::TSC_EXPOSED)){
        this->results.addFact(lao, &dnode);
      }
    }
  }
  return false; //- not useless
}

bool MBUc2factHandler::handleFormal(DFAfact& df, PExprDecl& dd, CFGfunction& parfn, bool interproc)
{
  MBUfactHandler::handler.handleFormal(df, dd, parfn, interproc);
  if(((MBUfact&)df).contains(dd.getAO()) && this->results.hasKey(dd.getAO())){
    this->results.addFact(dd.getAO(), &dd, 0, 0);
    suco_iterator<PExprCall *> csi(parfn.getCallSites());
    while(csi.Iterate()){
      PExprArg * arg = csi.Current()->getArg(dd.getArgNo());
      if(arg) this->results.addFact(dd.getAO(), 0, 0, arg);
    }
  }
  return false; //- not useless
}

bool MBUc2factHandler::handleReturnStmt(DFAfact& df, PgmStmt& retnode, ExpDescr * retedesc, bool interproc)
{
  MBUfactHandler::handler.handleReturnStmt(df, retnode, retedesc, interproc);
  AO& fnret_ao = retnode.getParentFunction().getId().get_AOFunction().get_AOReturn();
  if(((MBUfact&)df).contains(fnret_ao) && this->results.hasKey(fnret_ao)){
    this->results.addFact(fnret_ao, 0, &retnode, 0);
  }
  return false;
}

//- with delta approach, all non-statics must be initially uninit!
bool MBUc2factHandler::handleDecl(DFAfact& df, PExprDecl& dd)
{
  MBUfactHandler::handler.handleDecl(df, dd);
  if(this->results.hasKey(dd.getAO()) && (dd.isLocal() || dd.isMalloc())){ //TODO: include malloc?
    this->results.addFact(dd.getAO(), &dd, 0, 0);
  }
  return false; //- not useless
}

//----------------------------------
// MBU

bool MBU::isUselessNode(PgmExpr& dn)
{
  return dn.MBUisUseless();
}

bool MBU::isUselessNode(CFGnode& cn)
{
  return cn.MBUisUseless();
}

bool MBU::markUselessNode(PgmExpr& dn)
{
  dn.MBUsetUseless();
  return true;
}

bool MBU::markUselessNode(CFGnode& cn)
{
  cn.MBUsetUseless();
  return true;
}

//- compare df1 with df2: if df2 is lower-than df1, return true
//  then absorb (meet) df2 into df1
//- (warn=true): if df2 is not <= df1, print warning message
bool MBU::absorbAndCompare(DFAfact& df1, DFAfact& df2, LocSet * backedge_filter/*ignored*/)
{
  if(flag_mbu_lowerthan_by_size &&
    (((MBUfact &)df1).length() == ((MBUfact &)df2).length())){

      return false;

  } else {

    return df1.meet(df2, false, true);

  }
}

//-- used in print_debug_stats
struct fmapentry {
  CFGfunction * fptr;
  int count;
  int oldcount;
};

static int fme_compare(const void * fe1, const void * fe2)
{
  return (((const struct fmapentry *)fe2)->count - ((const struct fmapentry *)fe1)->count);
}

//-- print number of CFG nodes, max and average fact size
void MBU::print_debug_stats(CFG& cfg, FILE * outf)
{
  int num_nodes = 0;
  int tot_facts = 0;
  int max_facts = 0;

  suco_iterator<CFGfunction *> fli(cfg.getFunctionList());
  while(fli.Iterate()){
    if(flag_use_bblocks){
      suco_iterator<CFGbblock *> bbi(fli.Current()->getBBlist());
      while(bbi.Iterate()){
        CFGbblock& bb = *bbi.Current();
        //-- count facts
        MBUfact& mf = bb.getMBUfact();
        int len = mf.length();
        num_nodes++;
        tot_facts += len;
        if(max_facts < len){
          max_facts = len;
        }
      }
    } else {
      suco_iterator<PgmStmt *> sti(fli.Current()->getStmtList());
      while(sti.Iterate()){
        PgmStmt& st = *sti.Current();
        //-- count facts
        MBUfact& mf = st.getMBUfact();
        int len = mf.length();
        num_nodes++;
        tot_facts += len;
        if(max_facts < len){
          max_facts = len;
        }
      }
    }
  }

  if(flag_verbose == 4){
    static fmapentry * func_map = 0;
    static int num_funcs = 0;
    int i;

    if(!func_map){
      //-- one-time initialization of func_map
      num_funcs = cfg.getFunctionList().Length();
      func_map = new struct fmapentry[num_funcs];
      for(i = 0; i < num_funcs; ++i){
        func_map[i].fptr = 0;
        func_map[i].count = 0;
        func_map[i].oldcount = 0;
      }
    }
    for(i = 0; i < num_funcs; ++i){
      func_map[i].oldcount = func_map[i].count;
      func_map[i].count = 0;
    }

    suco_iterator<CFGnode *> wli(this->worklist.list);
    while(wli.Iterate()){
      CFGfunction * fptr = &wli.Current()->getParentFunction();
      for(i = 0; i < num_funcs; ++i){
        if(!func_map[i].fptr){
          func_map[i].fptr = fptr;
          func_map[i].count = 1;
          break;
        } else if(func_map[i].fptr == fptr){
          func_map[i].count++;
          break;
        }
      }
    }

    qsort(func_map, num_funcs, sizeof(struct fmapentry), fme_compare);

    int mode = 0;
    fprintf(outf, "Worklist content: top 5 functions:\n\t");
    for(i = 0; i < num_funcs && func_map[i].count; ++i){
      if(i == 5){ // switch mode to active delta
        mode = 1;
        fprintf(outf, "\nRemaining active with deltas:");
      }
      if(mode == 0){
        fprintf(outf, " %s(%d/%d)", func_map[i].fptr->getId().getPid().getname(),
				  func_map[i].count, func_map[i].count - func_map[i].oldcount);
      } else if(func_map[i].count - func_map[i].oldcount){
        if(!((mode-1) % 5)) fprintf(outf, "\n\t");
        mode++;
        fprintf(outf, " %s(%d/%d)", func_map[i].fptr->getId().getPid().getname(),
				  func_map[i].count, func_map[i].count - func_map[i].oldcount);
      }
    }
    fprintf(outf, "\n");
  }

  fprintf(outf, "Facts: total %d, per %s %.2f, max = %d\n",
		tot_facts, flag_use_bblocks?"bblock":"stmt",
		(num_nodes)?((float)tot_facts/(float)num_nodes):((float)tot_facts),
		max_facts);
}

//----------------------------------
// END
//----------------------------------

@


1.52
log
@ADDED: is_zeroed field to AO!  (But only outermost (declared)
	objects will be marked)
Changed mbu4 so that
 - function calls don't gen new mbu facts;
 - at function entry, isZeroed objects are excluded
   from initial facts (intra mode)
@
text
@d399 5
a403 7
//  - MBU: fact will be GREF set (conservatively assume all GREF variables
//    may be uninitialized)
//  - NOTE: may want to optimize to initialize only IREF set (not
//    currently stored). However, this would not allow us at a callsite
//    to correctly check a called function's GREF against the current
//    fact, which may yield significantly-improved results?
//    OTOH, perhaps such an "optimizable" function call is infrequent?
d409 8
a416 1
  cn.getParentFunction().getGREF().addToAOset(mf.aoset);
d446 7
a452 2
      if(fni.Current()->getGREF().Intersects(mf.aoset)){
        fni.Current()->getGMOD().addToAOset(mf.aoset);
d454 3
a456 3
      } else if(flag_verbose) {
        //-- function doesn't access anything in mf - add nothing, but report
        fprintf(stderr, "NOTE: intra-proc skipped call to %s (MF size = %d, GREF size = ??)\n",
d459 1
d462 1
@


1.51
log
@CHANGES:
1. Moved PExprAssign::getSingletonLHSloc() to
   ExpDescr::getSingletonLoc(), so it can be used
   elsewhere to determine strong update.
1a. FIXED BUG (??) in getSingletonLoc(): previously
    for sdot object, was returning enclosing struct!?!
2. Added -vtfix flag, which enables/disables RED and
   MBU treatment of verifyTag as fixing the type on
   mismatch.
3. Added MBU handling of verifyTag vtfix.
4. Changed so that MBU uses the RED parallel hackery
   (PM_RED_UNSAFE) when vtfix is on.
@
text
@d416 6
a421 1
    if(!aoi.Current()->dfa_relevant){
d437 6
a442 4
  suco_iterator<CFGfunction *> fni(dc.getTargetFns());
  while(fni.Iterate()){
    if(fni.Current()->getGREF().Intersects(mf.aoset)){
      fni.Current()->getGMOD().addToAOset(mf.aoset);
d444 3
a446 3
    } else if(flag_verbose) {
      //-- function doesn't access anything in mf - add nothing, but report
      fprintf(stderr, "NOTE: intra-proc skipped call to %s (MF size = %d, GREF size = ??)\n",
d449 1
d451 4
a455 4
  //- add { R D dc.Faos }  (actually, picking just one representative should be enough?
  suco_iterator<AO *> faoi(dc.getFaos());
  while(faoi.Iterate())
    mf.insertComponentAOs(faoi.Current()->get_AOStar().get_AOReturn());
@


1.50
log
@Fix 1: in -mbu[34], don't add formal to MBUfact.
Fix 2: when inserting/removing AO from MBUfact, if
       AO is a struct/union, then insert its component
       scalars (or remove all components).
       ~ but only if isLoc and not isMalloc.
@
text
@d378 15
d470 10
@


1.49
log
@Added isZeroed filter to mbu handleDecl
@
text
@d113 1
a113 1
    aual_fact->aoset.Insert(&ao);
d181 49
d294 1
a294 1
      mf.aoset.Insert(&lhs);
d296 1
a296 1
      mf.aoset.Remove(&lhs);
d327 1
a327 1
              mf.aoset.Insert(&dd.getAO());
d331 1
a331 1
            mf.aoset.Insert(&dd.getAO());
d357 1
a357 1
        mf.aoset.Remove(lvi.Current());
d365 1
d368 2
a369 1
	(dd.isLocal() || dd.isFormal() || dd.isMalloc())){
d371 3
a373 2
    if(ao.dfa_relevant)
      mf.aoset.Insert(&ao);
d402 1
d421 1
d432 1
a432 1
    mf.aoset.Insert(&faoi.Current()->get_AOStar().get_AOReturn());
@


1.48
log
@Extracted pMBU into its own files: pmbu.c,pmbu.h.
@
text
@d317 2
a318 1
  if(dd.isLocal() || dd.isFormal() || dd.isMalloc()){
@


1.47
log
@Minor fix: when declaring something isZeroed(),
remove it from the MBUfact -- as it may have been
added by the overly-conservative intraProcInitializeEntryFact().
@
text
@a518 114
// pMBU : ptr/ptrw-mode

//- for each (relevant-loc)AO in uninit_aos,
//  if it affects use_exp, move it to results
//  (move = delete from uninit_aos, add to results)
void pMBUfactHandler::moveToResults(suco_set<AO *>& uninit_aos, ExpDescr& use_exp, bool deref)
{
//TODO: handle deref=true case: deref use_exp one level?
  if(!uninit_aos.IsEmpty()){
    suco_set<ECR *> affecrs;
    use_exp.collectAffectingAliasLocECRs(affecrs);
    suco_iterator<AO *> ui(uninit_aos);
    while(ui.Iterate()){
      if(affecrs.Contains(&ui.Current()->getECR())){
        this->results.Insert(ui.Current());
        ui.DeleteCurrent();
      }
    }
  }
}

void pMBUfactHandler::moveToResults(suco_set<AO *>& uninit_aos, LocSet& use_locs)
{
  if(!uninit_aos.IsEmpty()){
    suco_set<ECR *> affecrs;
    use_locs.addToEcrSet(affecrs);
    suco_iterator<AO *> ui(uninit_aos);
    while(ui.Iterate()){
      if(affecrs.Contains(&ui.Current()->getECR())){
        this->results.Insert(ui.Current());
        ui.DeleteCurrent();
      }
    }
  }
}

bool pMBUfactHandler::handleStrongAssign(DFAfact& df, AO& lhs, ExpDescr& rhs, PgmExpr * dnode, PgmStmt * cnode, PExprArg * arg)
{
  MBUfact& mf = (MBUfact&) df;
  this->moveToResults(mf.aoset, rhs, false);
  mf.aoset.Remove(&lhs);
  return false; //- not useless
}

bool pMBUfactHandler::handleWeakAssign(DFAfact& df, ExpDescr& lhs, ExpDescr& rhs, PExprAssign& dnode)
{
  MBUfact& mf = (MBUfact&) df;
  this->moveToResults(mf.aoset, rhs, false);
  return false; //- not useless
}

bool pMBUfactHandler::handleFormal(DFAfact& df, PExprDecl& dd, CFGfunction& parfn, bool interproc)
{
  return handleDecl(df, dd);
}

//TODO: structs? handle individually?
bool pMBUfactHandler::handleDecl(DFAfact& df, PExprDecl& dd)
{
  MBUfact& mf = (MBUfact&) df;
  if((!dd.isZeroed()) &&
	(dd.isLocal() || dd.isFormal() || dd.isMalloc())){
    AO& ao = dd.getAO();
    if(ao.dfa_relevant){
      mf.aoset.Insert(&ao);
    }
    return false; //- not useless
  } else if(dd.isZeroed()){
    mf.aoset.Remove(&dd.getAO());	//- may have been added during intraProcInitializeEntryFact()
    return false; //- not useless
  } else return true; //- useless
}

bool pMBUfactHandler::handleVerify(DFAfact& df, PExprVerify& dv)
{
  MBUfact& mf = (MBUfact&) df;
  if((dv.getVpKind() == PExprVerify::vpPtrW) ||
        (this->readwrite && (dv.getVpKind() == PExprVerify::vpPtr))){
    this->moveToResults(mf.aoset, dv.getDesc(), true);
  }

  return false; //- not useless
}

void pMBUfactHandler::intraProcInitializeEntryFact(DFAfact& df, CFGnode& cn)
{
  MBUfact& mf = (MBUfact&) df;

  cn.getParentFunction().getGREF().addToAOset(mf.aoset);

  //-optimization: keep only "relevant" aos, and exclude strlits:
// FOR NOW, exclude also sdot/udot (may change in future)
  suco_iterator<AO *> aoi(mf.aoset);
  while(aoi.Iterate()){
    AO& ao = *aoi.Current();
    if(!ao.dfa_relevant ||
	ao.getKind() == AO::aoStringLit ||
	ao.getKind() == AO::aoSDot ||
	ao.getKind() == AO::aoUDot){
      aoi.DeleteCurrent();
    }
  }
}

void pMBUfactHandler::intraProcHandleCall(DFAfact& df, PExprCall& dc)
{
  MBUfact& mf = (MBUfact&) df;
  suco_iterator<CFGfunction *> fni(dc.getTargetFns());
  while(fni.Iterate()){
    this->moveToResults(mf.aoset, fni.Current()->getGREF());
  }
}

//----------------------------------
@


1.46
log
@Added pMBU: may-be-uninit analysis for ptr/ptrw mode.
Very conservative, and still slow...
@
text
@d578 1
a580 1
    MBUfact& mf = (MBUfact&) df;
d585 3
@


1.45
log
@Changed AO/ECR relationship: added AO::getECR() function
that is to be called after pt-analysis finalization of
ECRs -- so, PRIOR to finalization, must use ECR::getECR()
(as is now done in pta.cpp), but AFTER, must only use
AO::getECR() which outputs a fatal error message if ECR
not found.
@
text
@d108 1
a108 1
//-- static helpers for addUnsafeAliasLocs
d112 1
a112 1
  if(MBUfact::aual_fact && ao.isLoc() && (ao.getTSC() >= AO::TSC_EXPOSED))
d119 1
a119 1
void MBUfact::addUnsafeAliasLocs(suco_set<AO *>& laoset)
d243 1
a243 1
  if(lhs.getTSC() >= AO::TSC_EXPOSED){
d259 1
a259 1
        mf.addUnsafeAliasLocs(lhs.getAOs());
d271 1
a271 1
      if(dd.getAO().getTSC() >= AO::TSC_EXPOSED){ //- skip if not safe (optimize)
d319 1
a319 1
    if(ao.getTSC() >= AO::TSC_EXPOSED)	//-- filter safe and tracked AOs
d345 1
a345 1
  //-optimization: keep only "safe" aos:
d348 1
a348 1
    if(aoi.Current()->getTSC() < AO::TSC_EXPOSED){ //- not safe or exposed
d412 1
a412 1
            if(ao.getTSC() >= AO::TSC_EXPOSED){
d517 112
@


1.44
log
@MAJOR UPDATE:
- Created new class LocSet to encapsulate a set of
  locations, used to store GMOD, GREF, and backedge
  filters.
  (Previously, was suco_set<AO *>, later changed to
  suco_set<ECR *>.)
- Created two versions, one storing AOs, another
  storing ECRs.  Verified that results are the
  same, though performance is not (but only when
  computing backedge filters).
@
text
@d125 1
a125 2
    if(aoi.Current()->hasECR())
      ecrset.Insert(&ECR::getECR(*aoi.Current()));
d148 1
a148 1
    MBUfact::cfr_ecrset.Insert(&ECR::getECR(ret));
d162 2
a163 2
  while(taoi.Iterate()){ // note: no hasECR() filtering!
    MBUfact::ia_ecrset.Insert(&ECR::getECR(*taoi.Current()));
d172 2
a173 2
    if(!rao.isVal() && rao.hasECR()){
      MBUfact::cfr_ecrset.Insert(&ECR::getECR(rao));
d423 2
a424 2
            if(!dvao.isVal() && dvao.hasECR()){
              dv_ecrs.Insert(&ECR::getECR(dvao));
@


1.43
log
@Major overhaul, to handle function call filtering.
See dfa.cpp for documentation.
 - filterRetnodeFact() eliminated; replaced by
 - interProcHandleRetvalAssign -- responsible for
   assigning from R X I <fn> to R D I <fp>.
 - interProcPrepareReturnCollector() -- special
    pre-processor for indirect calls to set "intersection"
   AOs to "top".
 - meetFiltered() -- does meet, but constrained by a
   window (defined by a function's GREF/MayFree set).
Supporting changes:
 - eliminated removeArgIntervalsExceptFor(); rendered obsolete
   by
 - filterGrefMayFree() -- called at function entry
 - RANfact::isTop()
 - collectAOset, createTopMappings, in support of
   interProcPrepareReturnCollector()
 - PExprCall::isDirectCall() and isRecursiveCall()
 - CFGfunction::GrefOrFreeHeapAffects()
@
text
@a20 20
void MBUfact::addAOs(suco_set<AO *>& aos)
{
  this->aoset.Union(aos);
}

//-- filter this, placing into ffact all elements of this in filterset
// - i.e. this = this \ filterset
// -      ffact = this intersect filterset
void MBUfact::filterInto(suco_set<AO *>& filterset, MBUfact& ffact)
{
  suco_iterator<AO *> thi(this->aoset);
  while(thi.Iterate()){
    AO * tao = thi.Current();
    if(filterset.Contains(tao)){
      thi.DeleteCurrent();
      ffact.aoset.Insert(tao);
    }
  }
}

d196 1
d198 10
a207 2
  while(tfi.Iterate())
    mbf_local.filterInto(tfi.Current()->getGREF(), mbf);
d210 3
a212 2
  for(int i = 1; dc.getArg(i); ++i)
    mbf_local.filterInto(dc.getArg(i)->getDesc().getAOs(), mbf);
d342 11
a352 1
  ((MBUfact&) df).addAOs(cn.getParentFunction().getGREF());
d366 2
a367 2
    if(mf.aoset.Intersects(fni.Current()->getGREF())){
      mf.aoset.Union(fni.Current()->getGMOD());
d370 1
a370 1
      fprintf(stderr, "NOTE: intra-proc skipped call to %s (MF size = %d, GREF size = %d)\n",
d372 1
a372 1
			mf.aoset.Length(), fni.Current()->getGREF().Length());
d546 1
a546 1
bool MBU::absorbAndCompare(DFAfact& df1, DFAfact& df2, suco_set<AO *> * backedge_filter/*ignored*/)
@


1.42
log
@Added new DFA interface function interProcFilterEntryFact()
called at each function entry (when doing inter-proc
analysis).
@
text
@d230 5
@


1.41
log
@Changed handleFormal to pass parent-function rather
than previous "ismain" and "callsites" pair.
@
text
@d331 5
@


1.40
log
@Added interProcHandleCallArgs() interface function to
DFA and all derived classes.
@
text
@d272 1
a272 1
bool MBUfactHandler::handleFormal(DFAfact& df, PExprDecl& dd, bool ismain, suco_llist<PExprCall *>& callsites, bool interproc)
d278 1
a278 1
        suco_iterator<PExprCall *> csi(callsites);
d475 1
a475 1
bool MBUc2factHandler::handleFormal(DFAfact& df, PExprDecl& dd, bool ismain, suco_llist<PExprCall *>& callsites, bool interproc)
d477 1
a477 1
  MBUfactHandler::handler.handleFormal(df, dd, ismain, callsites, interproc);
d480 1
a480 1
    suco_iterator<PExprCall *> csi(callsites);
@


1.39
log
@Semi-bug fix: remember that function return node is
represented by R F I <fn> not R I <fn>, which was
not the case, so I've fixed it throughout (occurs
mainly in handleReturnStmt() in the various analyses).

Also, added AOReturn::getStaticType() as a separate
function to look up the underlying function's return
type if staticType is not set;
added TCfunctionType::getReturnType() accessor to
assist.
@
text
@d225 5
@


1.38
log
@Changed AO::write_string_rep and write_list_string_rep
to take a "readable" flag.
So now, flag_readable_output only affects the parts intended
for machine-reading by sml; the other auxiliary output
(e.g. via debug_dump, or for longjmp targets) will be
always readable.
@
text
@d300 1
a300 1
      is_useless &= handleStrongAssign(df, parfn.getId().get_AOReturn(), *retedesc, 0, &retnode);
d487 1
a487 1
  AO& fnret_ao = retnode.getParentFunction().getId().get_AOReturn();
@


1.37
log
@PREVIOUSLY: handleReturnStmt was only called for non-void
return statements.
NOW: handleReturnStmt is called for ALL return statements.
This is needed so analyses can properly handle deallocation
of local variables.
OTHER CHANGES:
 1. RAN: handleReturnStmt now removes intervals pointing
    to freedStack ECRs.
 2. Interval: changed code for narrow() to be more logically
    sound?
@
text
@d120 1
a120 1
      aoi.Current()->write_string_rep(outf);
@


1.36
log
@Modified handleFormal to pass a flag indicating whether
the function is "main".  This is needed because main's
argc/argv formals may need to be initialized differently.

For RAN::handleFormal() - if ismain, then set bottom;
else do top MEET callsite facts.

For MBU::handleFormal() - *BUG FIX* - was previously calling
handleStrongAssign(), which was _wrong_ (doesn't correctly
meet facts from multiple callsites); fixed to do "weak"
assignment.
@
text
@d294 1
a294 1
bool MBUfactHandler::handleReturnStmt(DFAfact& df, PgmStmt& retnode, ExpDescr& retedesc, bool interproc)
d299 2
a300 2
    if(flag_may_be_uninit < 2){
      is_useless &= handleStrongAssign(df, parfn.getId().get_AOReturn(), retedesc, 0, &retnode);
d484 1
a484 1
bool MBUc2factHandler::handleReturnStmt(DFAfact& df, PgmStmt& retnode, ExpDescr& retedesc, bool interproc)
@


1.35
log
@Small bug fix: in handleReturn, was filtering out locals
only when recursive, rather than when NOT recursive, as
was intended.
@
text
@d267 1
a267 1
bool MBUfactHandler::handleFormal(DFAfact& df, PExprDecl& dd, suco_llist<PExprCall *>& callsites, bool interproc)
d277 4
a280 5
            //-- process assignment [dd.ao] = argaos
            handleStrongAssign(mf, dd.getAO(), arg->getDesc(), &dd, 0, arg);
            //-NOTE: this can be treated as a strong assignment, because since the callsite
            //       will be a merge-point, the meet operation should correctly take care of
            //       the alias approximation
d470 1
a470 1
bool MBUc2factHandler::handleFormal(DFAfact& df, PExprDecl& dd, suco_llist<PExprCall *>& callsites, bool interproc)
d472 1
a472 1
  MBUfactHandler::handler.handleFormal(df, dd, callsites, interproc);
@


1.34
log
@Another change: RETURN argument is now an ExpDescr
instead of an aoset (as was before); with a corresponding
change to the argument of handleReturnStmt.

Independently: updated RAN's handleFormal (wrote but
not tested).
@
text
@d305 1
a305 1
    if(parfn.getRecursionId()){
@


1.33
log
@Interface change: intraProcHandleCall now takes a PExprCall
rather than a CFGfunction -- consequently, the iteration
over target functions is now the responsibility of
intraProcHandleCall rather than in dfa.cpp: BBA::PgmExprPropagate.

Then, one update to body of MBU::intraProcHandleCall -
to account for assignment of return value, at callsite
dc to ao, now add "R D ao" to the MBUfact set, so that
the subsequent assignment of the call's return value
to a variable will mark that variable as MBU as well.
This was a bug in the old implemenation.
@
text
@d222 1
a222 1
    mbf_local.filterInto(dc.getArg(i)->getAOs(), mbf);
d278 1
a278 2
	    ExpDescr argaos_ed(arg->getAOs());
            handleStrongAssign(mf, dd.getAO(), argaos_ed, &dd, 0, arg);
d295 1
a295 1
bool MBUfactHandler::handleReturnStmt(DFAfact& df, PgmStmt& retnode, suco_set<AO *>& retaos, bool interproc)
d301 1
a301 2
      ExpDescr ret_ed(retaos);
      is_useless &= handleStrongAssign(df, parfn.getId().get_AOReturn(), ret_ed, 0, &retnode);
d485 1
a485 1
bool MBUc2factHandler::handleReturnStmt(DFAfact& df, PgmStmt& retnode, suco_set<AO *>& retaos, bool interproc)
d487 1
a487 1
  MBUfactHandler::handler.handleReturnStmt(df, retnode, retaos, interproc);
@


1.32
log
@Interface update: augmented handleFormal / handleReturnStmt
with "interproc" flag.
Not yet used.
@
text
@d269 18
a286 16
  MBUfact& mf = (MBUfact&) df;
  if(flag_may_be_uninit < 3){
    if(dd.getAO().getTSC() >= AO::TSC_EXPOSED){ //- skip if not safe (optimize)
      suco_iterator<PExprCall *> csi(callsites);
      while(csi.Iterate()){
        PExprArg * arg = csi.Current()->getArg(dd.getArgNo());
        if(arg){
          //-- process assignment [dd.ao] = argaos
	  ExpDescr argaos_ed(arg->getAOs());
          handleStrongAssign(mf, dd.getAO(), argaos_ed, &dd, 0, arg);
          //-NOTE: this can be treated as a strong assignment, because since the callsite
          //       will be a merge-point, the meet operation should correctly take care of
          //       the alias approximation
        } else { //-- this arg not included in callsite: set to uninit!?
                 // - note: may want to ignore -- assume PTA imprecision?
          mf.aoset.Insert(&dd.getAO());
d288 6
a293 4
      }
      return false;
    } else return true; //- useless
  } else return true;
d299 7
a305 6
  CFGfunction& parfn = retnode.getParentFunction();
  if(flag_may_be_uninit < 2){
    ExpDescr ret_ed(retaos);
    is_useless &= handleStrongAssign(df, parfn.getId().get_AOReturn(), ret_ed, 0, &retnode);
  }
  //-- filter out local vars, only if non-recursive
d307 7
a313 6
  if(parfn.getRecursionId()){
    is_useless = false;
    MBUfact& mf = (MBUfact&) df;
    suco_iterator<AOId *> lvi(parfn.getLocalVars());
    while(lvi.Iterate())
      mf.aoset.Remove(lvi.Current());
d321 1
a321 1
  if(dd.isLocal() || dd.isMalloc()){
a340 1
//TODO: add GREF intersect call target's GMOD!
d347 2
a348 1
void MBUfactHandler::intraProcHandleCall(DFAfact& df, CFGfunction& fn)
d351 11
a361 7
  if(mf.aoset.Intersects(fn.getGREF())){
    mf.aoset.Union(fn.getGMOD());
  } else if(flag_verbose) {
    //-- function doesn't access anything in mf - add nothing, but report
    fprintf(stderr, "NOTE: intra-proc skipped call to %s (MF size = %d, GREF size = %d)\n",
			fn.getId().getPid().getname(),
			mf.aoset.Length(), fn.getGREF().Length());
d363 4
@


1.31
log
@Infrastructure update: CFGnode backedge indicator has
been upgraded from a boolean to an AO set pointer, for
which a value of:
  0 indicates non-backedge
  1 (constant CFGnode::ALL_AOS) indicates a backedge
    with no AO-filter information (i.e. widen all intervals)
  otherwise, contains the set of AOs that may be modified
    in the loop body, and constitutes a safe superset of
    AOs whose interval needs to be widened.
So far, added the necessary interface and skeletal function
bodies; NOT YET DONE: write the engine to compute the may-mod
sets.
@
text
@d267 1
a267 1
bool MBUfactHandler::handleFormal(DFAfact& df, PExprDecl& dd, suco_llist<PExprCall *>& callsites)
d292 1
a292 1
bool MBUfactHandler::handleReturnStmt(DFAfact& df, PgmStmt& retnode, suco_set<AO *>& retaos)
d335 1
d459 1
a459 1
bool MBUc2factHandler::handleFormal(DFAfact& df, PExprDecl& dd, suco_llist<PExprCall *>& callsites)
d461 1
a461 1
  MBUfactHandler::handler.handleFormal(df, dd, callsites);
d473 1
a473 1
bool MBUc2factHandler::handleReturnStmt(DFAfact& df, PgmStmt& retnode, suco_set<AO *>& retaos)
d475 1
a475 1
  MBUfactHandler::handler.handleReturnStmt(df, retnode, retaos);
@


1.30
log
@1. Added code (to CFG::assignId) to mark backedges in
   the CFG.
   May be buggy -- must test.
2. -MAJOR UPDATE-
   Added ran.cpp/ran.h for range checking.
   Thusfar, ran.cpp contains only empty skeletons to be
   filled in - do not run!
3. Renamed widen_narrow in CFG to is_backedge;
   also, now widen/narrow are specific to RAN/RANfact,
   rather than generic to DFA/DFAfact.
@
text
@d519 1
a519 1
bool MBU::absorbAndCompare(DFAfact& df1, DFAfact& df2, bool is_backedge/*ignored*/)
@


1.29
log
@Added infrastructure for widening/narrowing:
 - added widen/narrow flag to CFGnode and DFA
 - added widen/narrow flag to absorbAndCompare to
   trigger widening/narrowing
Also, extended lookupNodeFact to take an extra argument:
a CFGnode to guide lookup of branch successors.
@
text
@d519 1
a519 1
bool MBU::absorbAndCompare(DFAfact& df1, DFAfact& df2, bool widen_narrow/*ignored*/)
@


1.28
log
@Changed rhs argument of Assign node from an aolist to an exp-descr
triplet: <aolist, aff-aolist, estr>.
Main effect is changing the type of the rhs argument of
handle[Strong/Weak]Assign from an aoset to an ExpDescr,
which has been down-propagated to all subclasses.
@
text
@d225 1
a225 1
DFAfact& MBUfactHandler::lookupNodeFact(CFGnode& cn)
d519 1
a519 1
bool MBU::absorbAndCompare(DFAfact& df1, DFAfact& df2)
@


1.27
log
@Changed final argument to handleWeakAssign from PgmExpr
to PExprAssign!
@
text
@d240 1
a240 1
bool MBUfactHandler::handleStrongAssign(DFAfact& df, AO& lhs, suco_set<AO *>& rhs,
d245 1
a245 1
    if(flag_may_be_uninit < 4 && mf.intersectsAliases(rhs)){
d254 1
a254 1
bool MBUfactHandler::handleWeakAssign(DFAfact& df, ExpDescr& lhs, suco_set<AO *>& rhs, PExprAssign& dnode)
d259 1
a259 1
      if(mf.intersectsAliases(rhs)){
d277 2
a278 1
          handleStrongAssign(mf, dd.getAO(), arg->getAOs(), &dd, 0, arg);
d297 2
a298 1
    is_useless &= handleStrongAssign(df, parfn.getId().get_AOReturn(), retaos, 0, &retnode);
d421 1
a421 1
bool MBUc2factHandler::handleStrongAssign(DFAfact& df, AO& lhs, suco_set<AO *>& rhs,
d440 1
a440 1
bool MBUc2factHandler::handleWeakAssign(DFAfact& df, ExpDescr& lhs, suco_set<AO *>& rhs, PExprAssign& dnode)
@


1.26
log
@Updated redundant analysis: strong and weak assignments written;
to do: function calls and result collection.
Entailed following changes:
  PExprAssign::getLHS to return ExpDescr instead of AO set.
  DFA handleWeakAssign's second argument is now ExpDescr rather than AO set.
  ECR: added helper collectAliasECRs (not tested!)
@
text
@d254 1
a254 1
bool MBUfactHandler::handleWeakAssign(DFAfact& df, ExpDescr& lhs, suco_set<AO *>& rhs, PgmExpr& dnode)
d438 1
a438 1
bool MBUc2factHandler::handleWeakAssign(DFAfact& df, ExpDescr& lhs, suco_set<AO *>& rhs, PgmExpr& dnode)
@


1.25
log
@Split dfa.h into mbu.h, rda.h, rdmb.h.
@
text
@d254 1
a254 1
bool MBUfactHandler::handleWeakAssign(DFAfact& df, suco_set<AO *>& lhs, suco_set<AO *>& rhs, PgmExpr& dnode)
d258 1
a258 1
    if(AO::getSetTSC(lhs) >= AO::TSC_EXPOSED){
d260 1
a260 1
        mf.addUnsafeAliasLocs(lhs);
d438 1
a438 1
bool MBUc2factHandler::handleWeakAssign(DFAfact& df, suco_set<AO *>& lhs, suco_set<AO *>& rhs, PgmExpr& dnode)
d444 2
a445 2
  if(numpre != numpost || mf.intersectsAliases(lhs)){ //TODO: should further filter by this->results!
    suco_iterator<AO *> laoi(lhs);
@


1.24
log
@Protected debug output with if(verbose_flag).
@
text
@d6 1
a6 1
#include "dfa.h"
@


1.23
log
@Removed debug verbose output (when function call is
skipped by intra analysis); but a one-line NOTE is
still output.
@
text
@d344 1
a344 1
  } else {
@


1.22
log
@Finished writing intra-procedural engine...
tested only on small example.
@
text
@d346 3
a348 7
    fprintf(stderr, "NOTE: intra-proc skipped call to %s\n", fn.getId().getPid().getname());
/**/fprintf(stderr, "MF:");
/**/AO::write_set_string_rep(stderr, mf.aoset);
/**/fprintf(stderr, "\n");
/**/fprintf(stderr, "GREF:");
/**/AO::write_set_string_rep(stderr, fn.getGREF());
/**/fprintf(stderr, "\n");
@


1.21
log
@Added -mbu-intra flag; starting to add intra-procedural
analysis mechanism -- wrote some skeletal setups, but
not done.
Should be only two pieces to write to do MBU intraprocedurally
(I don't think we can/should do RDA intraprocedurally).
@
text
@d21 5
d321 35
a515 12
}

//- initialize fn's entry node's facts for intra-procedural analysis
//  - fact will be IREF set (conservatively assume all IREF variables
//    may be uninitialized
void MBU::initializeIntraProcEntryFact(CFGfunction& fn)
{
  CFGnode * fen = fn.getEntryNode();
  if(fen){
    MBUfact& enf = (MBUfact&) dfh.lookupNodeFact(*fen);
//SY: TODO
  } else fprintf(stderr, "ERROR: function has no entry node!\n");
@


1.20
log
@FIXED mbuC1/2 collection for strong assignment:
must instrument an assignment if lhs is uninit either
before or after the assignment (or both); previously,
only instrumented if uninit-state changed. We cannot
do this because the uninit-state implies something *may*
be uninit; the alternative solution would be to expand the
facts to a three-valued system (may-be/must-be uninit)...
@
text
@d478 12
@


1.19
log
@Deleted commented-out old code for handleReturn/handleReturnDealloc.
@
text
@d389 1
a389 1
  if(inpre != inpost && this->results.hasKey(lhs)){
@


1.18
log
@Significant Update: changed handling of function returns
 - OLD: was handled at function callsite, split betwee
        functions handleReturn and handleReturnDealloc
 - NEW: handled when processing statement, by function
        handleReturnStmt
This checkin has old code commented-out; will remove in
next checkin.
@
text
@a285 22
/*
void MBUfactHandler::handleReturn(DFAfact& df, PExprCall& callnode, PgmStmt& retnode, suco_set<AO *>& retaos)
{
  MBUfact& mf = (MBUfact&) df;
  if(flag_may_be_uninit < 2){
    //-- for each function AO, do assign(Return(fao), return value AOs)
    suco_iterator<AO *> faoi(callnode.getFaos());
    while(faoi.Iterate()){
      if(!faoi.Current()->isVal())
        handleStrongAssign(mf, faoi.Current()->get_AOReturn(), retaos, &callnode, &retnode);
        //-NOTE: this can be treated as a strong assignment, because since the callsite
        //       will be a merge-point, the meet operation should correctly take care of
        //       the alias approximation
    }
//TODO: to optimize, we might try to remove the return AOs from the facts as soon
//      as possible, which might be complicated (might we need to traverse PARALLELs?)
//      OTOH: it might be simplest to leave them in (always, in fact), as our
//            context-insensitivity implies that a Return AO's fact holds always?
  }
}
*/

a304 10
/*
void MBUfactHandler::handleReturnDealloc(DFAfact& df, suco_set<AOId *>& localvars)
{
  MBUfact& mf = (MBUfact&) df;
  suco_iterator<AOId *> lvi(localvars);
  while(lvi.Iterate())
    mf.aoset.Remove(lvi.Current());
}
*/

a432 11

/*
void MBUc2factHandler::handleReturn(DFAfact& df, PExprCall& callnode, PgmStmt& retnode, suco_set<AO *>& retaos)
{
  MBUfactHandler::handler.handleReturn(df, callnode, retnode, retaos);
  AO& fnret_ao = retnode.getParentFunction().getId().get_AOReturn();
  if(((MBUfact&)df).contains(fnret_ao) && this->results.hasKey(fnret_ao)){
    this->results.addFact(fnret_ao, &callnode, &retnode, 0);
  }
}
*/
@


1.17
log
@Finished last rule for MBUc2 (handleReturn).
Seems to work on small sample; test more (entire MBUc1/2).
@
text
@d236 1
a236 1
				 PgmExpr& dnode, PgmStmt * cnode, PExprArg * arg)
d272 1
a272 1
          handleStrongAssign(mf, dd.getAO(), arg->getAOs(), dd, 0, arg);
d286 1
d295 1
a295 1
        handleStrongAssign(mf, faoi.Current()->get_AOReturn(), retaos, callnode, &retnode);
d306 1
d308 20
d335 1
d416 1
a416 1
                            PgmExpr& dnode, PgmStmt * cnode, PExprArg * arg)
d422 1
a422 1
    this->results.addFact(lhs, &dnode, cnode, arg);
d466 1
a468 1
  MBUfact& mf = (MBUfact&)df;
d474 11
@


1.16
log
@Added call to MBUc2 in tca.cpp;
added handler functions for MBUc2 for all but handleReturn case.
That one needs a small overhaul...
@
text
@d447 4
a450 1
//TODO
@


1.15
log
@Added MBUc2 skeleton, and wrote handleStrongAssign (though
evidently not correct); entailed adding RDAfact::hasKey
helper function.
@
text
@d404 7
d414 1
d416 10
a430 1
  MBUfact& mf = (MBUfact&)df;
d432 8
d447 1
d450 1
a450 6
void MBUc2factHandler::handleReturnDealloc(DFAfact& df, suco_set<AOId *>& localvars)
{
  MBUfact& mf = (MBUfact&)df;
  MBUfactHandler::handler.handleReturnDealloc(df, localvars);
}

a452 1
  MBUfact& mf = (MBUfact&)df;
d454 3
a458 1

@


1.14
log
@Rewrote MBUc1 to collect into results both
A. mbu-verified expressions (including derefs)
B. mbu-verified locations (these are the ones that will be
   delta'ed in c2)
@
text
@d390 48
@


1.13
log
@Removed RDMBc class; replaced by instantiation of
general MBUc class (for collecting may-be-uninit
results in a RDAfact object).
Added MBUc1factHandler class, and skeleton for MBUc2factHandler.
@
text
@d328 14
a347 1
        //-- collect MBU results
d349 5
d358 12
a369 1
              this->results.addFact(ao);
d372 5
@


1.12
log
@Major restructuring:
 1. added DFAfactHandler class to encapsulate functions
    that process a DFAfact based on the CFG node.
    Created a handler for each fact class thusfar
    (MBU, RDA, cMBU->RDMB)
 2. renamed cMBU to RDMB, to represent the pair (RDA,MBU).
    The collection analysis class is now called RDMBc.
    Use this new convention for naming?: end in "c" for
    a "collecting" analysis class (and "a" for "analysis"?)
@
text
@d326 30
@


1.11
log
@Systematic change: moved the seven handle_() functions
from DFAfact to DFA -- this means adding an additional
DFAfact argument (previously held by "this").
This change is needed to allow different DFA/BBA classes
to share the same underlying DFAfact.
Comment: in this case, C++'s class hierarchy mechanism
doesn't seem the ideal choice of abstraction!
@
text
@a101 90
bool MBU::handleStrongAssign(DFAfact& df, AO& lhs, suco_set<AO *>& rhs,
				 PgmExpr& dnode, PgmStmt * cnode, PExprArg * arg)
{
  MBUfact& mf = (MBUfact&) df;
  if(lhs.getTSC() >= AO::TSC_EXPOSED){
    if(flag_may_be_uninit < 4 && mf.intersectsAliases(rhs)){
      mf.aoset.Insert(&lhs);
    } else {
      mf.aoset.Remove(&lhs);
    }
    return false;
  } else return true; //- useless
}

bool MBU::handleWeakAssign(DFAfact& df, suco_set<AO *>& lhs, suco_set<AO *>& rhs, PgmExpr& dnode)
{
  MBUfact& mf = (MBUfact&) df;
  if(flag_may_be_uninit < 4){
    if(AO::getSetTSC(lhs) >= AO::TSC_EXPOSED){
      if(mf.intersectsAliases(rhs)){
        mf.addUnsafeAliasLocs(lhs);
      } //-- else cannot kill anything
      return false;
    } else return true; //- useless
  } else return true;
}

bool MBU::handleFormal(DFAfact& df, PExprDecl& dd, suco_llist<PExprCall *>& callsites)
{
  MBUfact& mf = (MBUfact&) df;
  if(flag_may_be_uninit < 3){
    if(dd.getAO().getTSC() >= AO::TSC_EXPOSED){ //- skip if not safe (optimize)
      suco_iterator<PExprCall *> csi(callsites);
      while(csi.Iterate()){
        PExprArg * arg = csi.Current()->getArg(dd.getArgNo());
        if(arg){
          //-- process assignment [dd.ao] = argaos
          handleStrongAssign(mf, dd.getAO(), arg->getAOs(), dd, 0, arg);
          //-NOTE: this can be treated as a strong assignment, because since the callsite
          //       will be a merge-point, the meet operation should correctly take care of
          //       the alias approximation
        } else { //-- this arg not included in callsite: set to uninit!?
                 // - note: may want to ignore -- assume PTA imprecision?
          mf.aoset.Insert(&dd.getAO());
        }
      }
      return false;
    } else return true; //- useless
  } else return true;
}

void MBU::handleReturn(DFAfact& df, PExprCall& callnode, PgmStmt& retnode, suco_set<AO *>& retaos)
{
  MBUfact& mf = (MBUfact&) df;
  if(flag_may_be_uninit < 2){
    //-- for each function AO, do assign(Return(fao), return value AOs)
    suco_iterator<AO *> faoi(callnode.getFaos());
    while(faoi.Iterate()){
      if(!faoi.Current()->isVal())
        handleStrongAssign(mf, faoi.Current()->get_AOReturn(), retaos, callnode, &retnode);
        //-NOTE: this can be treated as a strong assignment, because since the callsite
        //       will be a merge-point, the meet operation should correctly take care of
        //       the alias approximation
    }
//TODO: to optimize, we might try to remove the return AOs from the facts as soon
//      as possible, which might be complicated (might we need to traverse PARALLELs?)
//      OTOH: it might be simplest to leave them in (always, in fact), as our
//            context-insensitivity implies that a Return AO's fact holds always?
  }
}

void MBU::handleReturnDealloc(DFAfact& df, suco_set<AOId *>& localvars)
{
  MBUfact& mf = (MBUfact&) df;
  suco_iterator<AOId *> lvi(localvars);
  while(lvi.Iterate())
    mf.aoset.Remove(lvi.Current());
}

bool MBU::handleDecl(DFAfact& df, PExprDecl& dd)
{
  MBUfact& mf = (MBUfact&) df;
  if(dd.isLocal() || dd.isMalloc()){
    AO& ao = dd.getAO();
    if(ao.getTSC() >= AO::TSC_EXPOSED)	//-- filter safe and tracked AOs
      mf.aoset.Insert(&ao);
    return false;
  } else return true; //- useless
}

d197 4
a200 2
//----------------------------------
// MBU
d202 1
a202 1
void MBU::filterCallsiteFacts(PExprCall& dc, DFAfact& df, DFAfact& df_local)
d220 1
a220 1
DFAfact& MBU::lookupNodeFact(CFGnode& cn)
d225 1
a225 1
DFAfact& MBU::lookupNodeFact(PExprCall& dc)
d230 1
a230 1
DFAfact& MBU::lookupNodeFact(PExprParallel& dp)
d234 93
@


1.10
log
@Change of approach: the points-to graph will now contain
include-edges for function return nodes, so that the alias
set of Return(Star(exp)) will include Return(Id(foo)) for
all exp-aliased functions foo.
This negates previous hack approaches (treating function
calls as a special case when handling an assignment RHS),
which have been removed.
NOTE: the addition of the new include edges is done in
tca.cpp (TCAstate); perhaps should migrate to a better
place (pta.cpp?).

Also, cMBU fact-collection now includes non-location objects,
and the result set will include the reaching-defs of aliases.
For example, the cMBU result set might now include
{ *p : defn(i), defn(j) } where i and j are aliases of *p.
This was previously omitted, erroneously.
@
text
@d102 1
a102 1
bool MBUfact::handleStrongAssign(AO& lhs, suco_set<AO *>& rhs,
d105 1
d107 2
a108 2
    if(flag_may_be_uninit < 4 && this->intersectsAliases(rhs)){
      this->aoset.Insert(&lhs);
d110 1
a110 1
      this->aoset.Remove(&lhs);
d116 1
a116 1
bool MBUfact::handleWeakAssign(suco_set<AO *>& lhs, suco_set<AO *>& rhs, PgmExpr& dnode)
d118 1
d121 2
a122 2
      if(this->intersectsAliases(rhs)){
        this->addUnsafeAliasLocs(lhs);
d129 1
a129 1
bool MBUfact::handleFormal(PExprDecl& dd, suco_llist<PExprCall *>& callsites)
d131 1
d139 1
a139 1
          this->handleStrongAssign(dd.getAO(), arg->getAOs(), dd, 0, arg);
d145 1
a145 1
          this->aoset.Insert(&dd.getAO());
d153 1
a153 1
void MBUfact::handleReturn(PExprCall& callnode, PgmStmt& retnode, suco_set<AO *>& retaos)
d155 1
d161 1
a161 1
        this->handleStrongAssign(faoi.Current()->get_AOReturn(), retaos, callnode, &retnode);
d173 1
a173 1
void MBUfact::handleReturnDealloc(suco_set<AOId *>& localvars)
d175 1
d178 1
a178 1
    this->aoset.Remove(lvi.Current());
d181 1
a181 1
bool MBUfact::handleDecl(PExprDecl& dd)
d183 1
d187 1
a187 1
      this->aoset.Insert(&ao);
@


1.9
log
@Major fixes:
1. right-hand-side of assignment now treated as a "use";
   this is extended to cover formals and returns.
2. special case (in MBUfact) when handling RHS of assignment:
   if it is a return node (signifying the result of a call),
   then a special alias resolution is used, in which
   for Return(tgt), we find all aliases of tgt that are
   functions of the form Function(fid), then collect the
   set of Return(fid)s as  the alias set. Basically --
   we're normalizing the "MBU holder" to be Return(fid).
Appears to work on test cases -- the only remaining issue
to be dealt with: must store additional information signifying
whether a fact deals with the LHS or RHS of an assignment, as
they can be independently instrumented.
@
text
@a255 3
// - SPECIAL CASE: if ao is a return node (signifying a call),
//   then resolve the function ids and collect the ecr for that
//   id's return node!
d272 1
a272 4
    if(rao.getKind() == AO::aoReturn){
      AO& fpao = ((AOReturn&)rao).getParent();
      ECR::getECR(fpao).traverseAliases(collectFnReturns); //- collect into cfr_ecrset
    } else if(!rao.isVal() && rao.hasECR()){
@


1.8
log
@Rewrote filterCallsiteFacts to fix bug: instead of
"filtering out" local facts, must instead "filter into"
non-local facts -- to get the union rather than intersect
of GMOD/GREFs of callees.
This entailed also renaming and changing definition og
filterOut() to filterInto().

Additional change: MBUfact::filterCallsiteFacts now accoutns
for function arguments, including them in the non-local
facts (since these will be checked when processing formal
declarations).
@
text
@d103 1
a103 1
				 PgmExpr * dnode, PgmStmt * cnode, PExprArg * arg)
d136 1
a136 1
          this->handleStrongAssign(dd.getAO(), arg->getAOs(), &dd, 0, arg);
d157 1
a157 1
        this->handleStrongAssign(faoi.Current()->get_AOReturn(), retaos, &callnode, &retnode);
d242 11
d256 3
d265 3
a267 3
  while(taoi.Iterate())
    if(taoi.Current()->hasECR())
      MBUfact::ia_ecrset.Insert(&ECR::getECR(*taoi.Current()));
d270 2
a271 1
  suco_set<ECR *> ecrset;
d273 9
a281 3
  while(raoi.Iterate())
    if(!raoi.Current()->isVal() && raoi.Current()->hasECR())
      ecrset.Insert(&ECR::getECR(*raoi.Current()));
d284 1
a284 1
  return !ECR::traverseSetAliases(ecrset, 0, MBUfact::is_ia_ecrset);
@


1.7
log
@Eliminated LocAidNodes from MBUfact -- major strip-down.
Now MBUfact is implemented as simply a suco_set of AOs.
Added suco_set::Intersect.
@
text
@d21 4
a24 4
//-- filter this, placing into df_remainders all elements not in filterset
// - i.e. this = this intersect filterset
// -      df_remainders = this \ filterset
void MBUfact::filterOut(suco_set<AO *>& filterset, MBUfact& df_remainders)
d29 1
a29 1
    if(!filterset.Contains(tao)){
d31 1
a31 1
      df_remainders.aoset.Insert(tao);
d274 4
d280 5
a284 1
    mbf.filterOut(tfi.Current()->getGREF(), mbf_local);
@


1.6
log
@1. changed GMOD/GREF filtering mechanism -- now controlled
   by a BBA function, rather than a DFAfact function --
   this allows BBA-specific choice of filter, and also
   allows RDA to cache local facts
2. per above, added RDAlocal cache to PExprCall
3. added a parent PgmStmt pointer to PgmExpr (previously
   only defined for PExprCall, as a reference) -- this
   will allow cMBU to lookup the containing function of
   any PgmExpr (and will likely be useful later as well).
   Note that this is a pointer, and may be null for
   PgmExprs at global scope.
   Also, current assumption is that all PExprCalls have
   a non-null parent (asserted during input in one of
   the read() functions).
@
text
@d26 6
a31 17
  LocAidNode ** tnpp = &this->head;
  LocAidNode ** rnpp = &df_remainders.head;

  while(*tnpp){
    AO * tao = &(*tnpp)->getAO();
    if(filterset.Contains(tao)){
      tnpp = &(*tnpp)->next;
    } else {
      //-- advance rnpp
      while(*rnpp && (&(*rnpp)->getAO() < tao))
        rnpp = &(*rnpp)->next;

      //-- move node from *tnpp to *rnpp
      LocAidNode * tmp = *tnpp;
      *tnpp = tmp->next;
      tmp->next = *rnpp;
      *rnpp = tmp;
d39 1
d50 1
a50 1
    this->clear();
d65 1
a65 23
    //-- copy elements of mf into this
    LocAidNode ** tnpp = &this->head;
    LocAidNode * mnp = mf.head;

    bool mf_has_extra = false;

    while(mnp){
      if(!*tnpp){ //- copy over all remaining nodes in mf

        mf_has_extra = true;

        if(preserve){ //- copy over
          do {
            *tnpp = LocAidNode::acquire(*mnp);
            mnp = mnp->next;
            tnpp = &(*tnpp)->next;
          } while(mnp);
        } else { //- move over
          *tnpp = mf.head;
          mnp = mf.head = 0;
        }

      } else if(&mnp->getAO() < &(*tnpp)->getAO()){ //- copy over
d67 5
a71 31
        mf_has_extra = true;

        if(preserve){ //- copy over
          *tnpp = LocAidNode::acquire(*mnp, *tnpp);
          mnp = mnp->next;
          tnpp = &(*tnpp)->next;
        } else { //- move node(s) over
          mf.head = mnp->next;
          mnp->next = *tnpp;
          *tnpp = mnp;
          tnpp = &(mnp)->next;
          mnp = mf.head;
        }

      } else if(&mnp->getAO() == &(*tnpp)->getAO()){ //- add aids

        if(preserve){ //- add aids, increment mnp
          (*tnpp)->nodes.Union(mnp->nodes);
          (*tnpp)->args.Union(mnp->args);
          (*tnpp)->rets.Union(mnp->rets);
          mnp = mnp->next;
          tnpp = &(*tnpp)->next;
        } else { //- consume aids, delete mnp, reset mf.head
          (*tnpp)->nodes.UnionConsume(mnp->nodes);
          (*tnpp)->args.UnionConsume(mnp->args);
          (*tnpp)->rets.UnionConsume(mnp->rets);
          mf.head = mnp->next;
          LocAidNode::dispose(mnp);
          mnp = mf.head;
          tnpp = &(*tnpp)->next;
        }
d73 1
a73 1
      } else { //- continue
d75 1
a75 14
        if(warnNotLE){
          fprintf(stderr, "Meet: MBUfact Not <=: this has ");
          (*tnpp)->getAO().dump_descr(stderr);
          fprintf(stderr, "\n");
        }

        tnpp = &(*tnpp)->next;

      }
    }
    this->recomputeLength();
    mf.recomputeLength();

    return mf_has_extra;
d92 1
a92 1
    this->clear(); //-- redundant
d97 2
a98 25
    LocAidNode ** tnpp = &this->head;
    LocAidNode * mnp = mf.head;
    while(*tnpp){
      if((!mnp) || (&(*tnpp)->getAO() < &mnp->getAO())){ //- not in mf, delete
        LocAidNode * del = *tnpp;
        *tnpp = (*tnpp)->next;
        LocAidNode::dispose(del);
      } else if(&(*tnpp)->getAO() == &mnp->getAO()){ //- add aids
        if(preserve){ //- add aids
          (*tnpp)->nodes.Union(mnp->nodes);
          (*tnpp)->args.Union(mnp->args);
          (*tnpp)->rets.Union(mnp->rets);
        } else { //- union consume
          (*tnpp)->nodes.UnionConsume(mnp->nodes);
          (*tnpp)->args.UnionConsume(mnp->args);
          (*tnpp)->rets.UnionConsume(mnp->rets);
        }
        mnp = mnp->next;
        tnpp = &(*tnpp)->next;
      } else { //- continue
        mnp = mnp->next;
      }
    }
    this->recomputeLength();
    mf.recomputeLength();
d107 1
a107 1
      this->addFact(lhs, dnode, cnode, arg);
d109 1
a109 1
      this->removeFacts(lhs);
d120 1
a120 1
        this->addUnsafeAliasLocs(lhs, dnode);
d142 1
a142 1
          this->addFact(dd.getAO(), &dd, 0, arg);
d173 1
a173 1
    this->removeFacts(*lvi.Current());
d181 1
a181 1
      this->addFact(ao, &dd);
d193 1
a193 1
    LocAidNode * np;
d195 3
a197 1
    for(np = this->head; np; np = np->next){
d199 1
a199 31
      np->getAO().write_string_rep(outf);
      fprintf(outf, ":");
      suco_iterator<PgmExpr *> ni(np->nodes);
      while(ni.Iterate()){
        switch(ni.Current()->getKind()){
          case PgmExpr::fCall: {
              AID& aid = ((PExprCall *)ni.Current())->getAid();
              fprintf(outf, " call<%d,%d>", aid.filestem_id, aid.aid);
            } break;
          case PgmExpr::fAssign: {
              AID& aid = ((PExprAssign *)ni.Current())->getAid();
              fprintf(outf, " assign<%d,%d>", aid.filestem_id, aid.aid);
            } break;
          case PgmExpr::fVT: {
              AID& aid = ((PExprVerify *)ni.Current())->getAid();
              fprintf(outf, " verifyTag<%d,%d>", aid.filestem_id, aid.aid);
            } break;
          case PgmExpr::fDecl: {
              fprintf(outf, " decl(");
              ((PExprDecl *)ni.Current())->getAO().write_string_rep(outf);
              fprintf(outf, ")");
            } break;
          default:
            fprintf(outf, "Invalid PgmExpr recorded in MBUfact:\n");
            ni.Current()->debug_dump(outf, 2);
        }
      }
      suco_iterator<PExprArg *> ai(np->args);
      while(ai.Iterate()) fprintf(outf, "", ai.Current());
      suco_iterator<PgmStmt *> ri(np->rets);
      while(ri.Iterate()) fprintf(outf, "", ri.Current());
a206 114
void MBUfact::clear()
{
  LocAidNode * np = this->head;
  while(np){
    LocAidNode * del = np;
    np = np->next;
    LocAidNode::dispose(del);
  }
  this->head = 0;
  this->num_elts = 0;
}

void MBUfact::writeResults(FILE * outf)
{
  LocAidNode * np;
  for(np = this->head; np; np = np->next){
    //-- do nodes
    suco_iterator<PgmExpr *> ni(np->nodes);
    while(ni.Iterate()){
      switch(ni.Current()->getKind()){
        case PgmExpr::fCall: {
            //-- mbu calls: ! <N> u c <int>
            AID& aid = ((PExprCall *)ni.Current())->getAid();
            fprintf(outf, "! %d u c %d\n", aid.filestem_id, aid.aid);
          } break;
        case PgmExpr::fAssign: {
            //-- mbu assigns: ! <N> u g <int>
            AID& aid = ((PExprAssign *)ni.Current())->getAid();
            fprintf(outf, "! %d u g %d\n", aid.filestem_id, aid.aid);
          } break;
        case PgmExpr::fVT: {
            //-- mbu vts: ! <N> u v <int>
            AID& aid = ((PExprVerify *)ni.Current())->getAid();
            fprintf(outf, "! %d u v %d\n", aid.filestem_id, aid.aid);
          } break;
        case PgmExpr::fDecl: {
            //-- mbu decls (including formals): ! <N> u d <AO>
            PExprDecl& dd = *(PExprDecl *)ni.Current();
            fprintf(outf, "! %d u d ", dd.getFSid());
            dd.getAO().write_string_rep(outf);
            fprintf(outf, "\n");
          } break;
        default:
          fprintf(stderr, "Invalid PgmExpr recorded in MBUfact:\n");
          ni.Current()->debug_dump(stderr, 2);
      }
    }
    //-- do args
    //-- mbu args: ! <N> u a <int>
    suco_iterator<PExprArg *> ai(np->args);
    while(ai.Iterate()){
      AID& aid = ai.Current()->getAid();
      fprintf(outf, "! %d u a %d\n", aid.filestem_id, aid.aid);
    }
    //-- do rets
    //-- mbu rets: ! <N> u r <int>
    suco_iterator<PgmStmt *> ri(np->rets);
    while(ri.Iterate()){
      AID& aid = ri.Current()->getAid();
      fprintf(outf, "! %d u r %d\n", aid.filestem_id, aid.aid);
    }
  }
}

//- return 0 indicates bottom
MBUfact::LocAidNode * MBUfact::getFactNode(AO& ao)
{
  if(this->is_bot)
    return 0;

  LocAidNode ** np;
  for(np = &this->head; *np && (&(*np)->getAO() < &ao); np = &(*np)->next);
  if(!(*np) || (&(*np)->getAO() != &ao)){ //-- node not found, add new
    *np = LocAidNode::acquire(ao, *np);
    this->num_elts++;
  }
  return *np;
}

void MBUfact::addFact(AO& ao, PgmExpr * dnode, PgmStmt * cnode, PExprArg * arg)
{
  LocAidNode * n = getFactNode(ao);
/*
  if(n){
    if(dnode) n->nodes.Insert(dnode);
    if(cnode) n->rets.Insert(cnode);
    if(arg)   n->args.Insert(arg);
  }
*/
}

void MBUfact::copyFacts(AO& ao, MBUfact& mf)
{
  LocAidNode * tn = this->getFactNode(ao);
  LocAidNode * mfn = mf.getFactNode(ao);
  if(tn && mfn){
    tn->nodes.Union(mfn->nodes);
    tn->rets.Union(mfn->rets);
    tn->args.Union(mfn->args);
  }
}

void MBUfact::removeFacts(AO& ao)
{
  LocAidNode ** np;
  for(np = &head; *np && (&(*np)->getAO() < &ao); np = &(*np)->next);
  if(*np && (&(*np)->getAO() == &ao)){ //-- node found, remove
    LocAidNode * del = *np;
    *np = (*np)->next;
    LocAidNode::dispose(del);
    this->num_elts--;
  }
}

a208 1
PgmExpr * MBUfact::aual_assign_node = 0; //- should never be zero when used
d212 1
a212 1
    aual_fact->addFact(ao, MBUfact::aual_assign_node);
d218 1
a218 1
void MBUfact::addUnsafeAliasLocs(suco_set<AO *>& aoset, PgmExpr& asgnode)
d222 1
a222 1
  suco_iterator<AO *> aoi(aoset);
d227 1
a227 1
  //-- set aual_fact, aual_assign_node
a228 1
  MBUfact::aual_assign_node = &asgnode;
d246 1
a246 1
bool MBUfact::intersectsAliases(suco_set<AO *>& aoset)
d250 4
a253 4
  LocAidNode * np;
  for(np = head; np; np = np->next)
    if(np->getAO().hasECR())
      MBUfact::ia_ecrset.Insert(&ECR::getECR(np->getAO()));
d255 1
a255 1
  //-- collect aoset's ecrset -- exclude values! (optimization)
d257 4
a260 4
  suco_iterator<AO *> aoi(aoset);
  while(aoi.Iterate())
    if(!aoi.Current()->isVal() && aoi.Current()->hasECR())
      ecrset.Insert(&ECR::getECR(*aoi.Current()));
a265 77
int MBUfact::length(bool confirm)
{
  if(confirm){
    int i = 0;
    for(LocAidNode * n = head; n; n = n->next)
      i++;
    if(i != num_elts){
      fprintf(stderr, "MBU length != num_elts (%d != %d)\n", i, this->num_elts);
      this->num_elts = i;
    }
  }
  return this->num_elts;
}

void MBUfact::recomputeLength()
{
  int i = 0;
  for(LocAidNode * n = head; n; n = n->next)
    i++;
  this->num_elts = i;
}

int MBUfact::freelistLength()
{
  int i = 0;
  for(LocAidNode * n = LocAidNode::freelist; n; n = n->next)
    i++;
  return i;
}

//----------------------------------
// MBUfact::LocAidNode

MBUfact::LocAidNode * MBUfact::LocAidNode::freelist = 0;

MBUfact::LocAidNode * MBUfact::LocAidNode::acquire(AO& o, LocAidNode * nx)
{
  LocAidNode * nn;

  if(freelist){
    TCstats::recy_la_nodes++;
    nn = freelist;
    freelist = freelist->next;
    nn->ao = &o;
    nn->next = nx;
  } else {
    TCstats::new_la_nodes++;
    nn = new LocAidNode(o, nx);
  }

  return nn;
}

MBUfact::LocAidNode * MBUfact::LocAidNode::acquire(LocAidNode& n, LocAidNode * nx)
{
  LocAidNode * nn = acquire(n.getAO(), nx);
  //- deep copy
  nn->nodes.Copy(n.nodes);
  nn->args.Copy(n.args);
  nn->rets.Copy(n.rets);
  return nn;
}

void MBUfact::LocAidNode::dispose(LocAidNode * n)
{
  if(flag_recycle){
    n->ao = 0;
    n->nodes.Clear();
    n->args.Clear();
    n->rets.Clear();
    n->next = freelist;
    freelist = n;
  } else {
    delete n;
  }
}

d360 1
a360 1
        int len = mf.length(true);
d373 1
a373 1
        int len = mf.length(true);
@


1.5
log
@Added EXPOSED-filtering to rda;
also, commented out reaching-def facts from mbu --
when sure of results, can remove the whole MBUfact::LocAidNode
mechanism fully.
@
text
@d24 1
a24 1
void MBUfact::filterOut(suco_set<AO *>& filterset, DFAfact& df_remainders)
d27 1
a27 1
  LocAidNode ** rnpp = &((MBUfact &)df_remainders).head;
d583 10
@


1.4
log
@Added GMOD/IMOD computation.
Modified DFA to have different call-filtering modes:
by GMOD, GREF, or NONE.
Renamed DFAfact::filter to filterOut (which performs
the opposite of what filter used to).
Currently, RDA is GMOD-filtered, MBU and cMBU are
GREF-filtered.
@
text
@d224 1
a224 1
    if(dd.getAO().getTSC() >= AO::TSC_EXPOSED){ //- skip if not unsafe (optimize)
d411 1
d417 1
@


1.3
log
@Cleaned up a few things:
 - eliminated dmode (mode_iterating/mode_collecting);
 - added checkParallelProgress;
 - migrated absorbAndCompare from DFAfact to DFA;
 - rewrote fParallel case incorporating these changes;
 - added a cMBUfact as a member of each CFG node, call,
   and parallel, so cMBU can also define lookupNodeFact.
@
text
@d21 4
a24 4
//-- filter this, placing into df_gref all elements in gref
// - i.e. this = this \ gref
// -      df_gref = this intersect gref
void MBUfact::filter(suco_set<AO *>& gref, DFAfact& df_gref)
d27 1
a27 1
  LocAidNode ** dnpp = &((MBUfact &)df_gref).head;
d31 6
a36 10
    if(gref.Contains(tao)){
      //-- advance dnpp
      while(*dnpp && (&(*dnpp)->getAO() < tao))
        dnpp = &(*dnpp)->next;

      //-- copy node from *tnpp to *dnpp
      LocAidNode * tp = *tnpp;
      *tnpp = tp->next;
      tp->next = *dnpp;
      *dnpp = tp;
d38 5
a42 2
    } else {
      tnpp = &(*tnpp)->next;
@


1.2
log
@Added cMBU class to collect may-be-uninit results (after
running RDA and MBU); new class is in cmbu.cpp.
Appears to be working, though a few open issues remain:
 - lookupNodeFact needs a complement (releaseNodeFact),
   since cMBU returns a new node (though neither MBU
   nor RDA do)
 - mode_iterating/mode_collecting -- should get rid
   of this flag cleanly
 - absorbAndCompare -- should obsolesce this, or migrate
   it to DFA/MBU/RDA
Longer term:
 - RDA should use GMOD, but when collecting, will need
   to refer to GREF.
@
text
@a196 18
//- compare df with this: if df is lower-than this, return true
//  then absorb (meet) df into this
//- (warn=true): if df is not <= this, print warning message
bool MBUfact::absorbAndCompare(DFAfact& df, bool warn)
{
  if(flag_mbu_lowerthan_by_size && warn){

    if(((MBUfact &)df).length() == this->length()){
      return false;
    } else {
      return this->meet(df, false, true);
    }

  } else {
    return this->meet(df, false, warn);
  }
}

a582 20
void MBU::collectResultsVerifyTag(DFAfact& df, PExprVerify& dn)
{
  MBUfact& mf = (MBUfact&) df;
  if(mf.intersectsAliases(dn.getAOs())){
    //-- for each of dn's AOs...
    suco_iterator<AO *> aoi(dn.getAOs());
    while(aoi.Iterate()){
      AO& ao = *aoi.Current();
      if(ao.isLoc() && (ao.getTSC() >= AO::TSC_EXPOSED)){
        //-- add to results <ao, dn>
        this->results.addFact(ao, &dn);
        //-- add to results <ao, _> from mf
        this->results.copyFacts(ao, mf);
      }
    }
  }
}

//----------------------------------

d618 17
@


1.1
log
@Initial revision
@
text
@d299 1
a299 1
void MBUfact::debug_dump(FILE * outf)
d303 2
@
