head	1.35;
access;
symbols;
locks; strict;
comment	@ * @;


1.35
date	2004.07.03.23.28.02;	author suan;	state Exp;
branches;
next	1.34;

1.34
date	2004.07.01.22.40.23;	author suan;	state Exp;
branches;
next	1.33;

1.33
date	2004.06.24.18.10.20;	author suan;	state Exp;
branches;
next	1.32;

1.32
date	2004.06.23.19.02.03;	author suan;	state Exp;
branches;
next	1.31;

1.31
date	2004.05.18.21.40.37;	author suan;	state Exp;
branches;
next	1.30;

1.30
date	2004.03.03.16.42.26;	author suan;	state Exp;
branches;
next	1.29;

1.29
date	2004.02.10.19.40.43;	author suan;	state Exp;
branches;
next	1.28;

1.28
date	2004.02.09.23.42.54;	author suan;	state Exp;
branches;
next	1.27;

1.27
date	2004.02.06.21.59.31;	author suan;	state Exp;
branches;
next	1.26;

1.26
date	2004.02.03.23.35.27;	author suan;	state Exp;
branches;
next	1.25;

1.25
date	2004.01.27.21.52.14;	author suan;	state Exp;
branches;
next	1.24;

1.24
date	2004.01.16.23.50.04;	author suan;	state Exp;
branches;
next	1.23;

1.23
date	2003.12.10.16.52.03;	author suan;	state Exp;
branches;
next	1.22;

1.22
date	2003.12.08.18.07.44;	author suan;	state Exp;
branches;
next	1.21;

1.21
date	2003.11.28.21.47.44;	author suan;	state Exp;
branches;
next	1.20;

1.20
date	2003.11.26.21.51.52;	author suan;	state Exp;
branches;
next	1.19;

1.19
date	2003.11.25.21.16.06;	author suan;	state Exp;
branches;
next	1.18;

1.18
date	2003.11.11.20.55.43;	author suan;	state Exp;
branches;
next	1.17;

1.17
date	2003.11.11.18.00.29;	author suan;	state Exp;
branches;
next	1.16;

1.16
date	2003.11.10.23.36.30;	author suan;	state Exp;
branches;
next	1.15;

1.15
date	2003.09.17.21.14.35;	author suan;	state Exp;
branches;
next	1.14;

1.14
date	2003.02.27.19.20.53;	author suan;	state Exp;
branches;
next	1.13;

1.13
date	2003.01.30.16.53.35;	author suan;	state Exp;
branches;
next	1.12;

1.12
date	2003.01.30.16.50.32;	author suan;	state Exp;
branches;
next	1.11;

1.11
date	2003.01.23.20.29.37;	author suan;	state Exp;
branches;
next	1.10;

1.10
date	2002.10.25.04.02.11;	author suan;	state Exp;
branches;
next	1.9;

1.9
date	2002.10.23.00.07.04;	author suan;	state Exp;
branches;
next	1.8;

1.8
date	2002.10.21.16.32.48;	author suan;	state Exp;
branches;
next	1.7;

1.7
date	2002.10.18.18.07.08;	author suan;	state Exp;
branches;
next	1.6;

1.6
date	2002.10.16.00.52.46;	author suan;	state Exp;
branches;
next	1.5;

1.5
date	2002.10.14.23.04.26;	author suan;	state Exp;
branches;
next	1.4;

1.4
date	2002.10.14.21.01.04;	author suan;	state Exp;
branches;
next	1.3;

1.3
date	2002.10.14.20.04.24;	author suan;	state Exp;
branches;
next	1.2;

1.2
date	2002.10.11.00.12.02;	author suan;	state Exp;
branches;
next	1.1;

1.1
date	2002.10.10.18.03.17;	author suan;	state Exp;
branches;
next	;


desc
@TCPtr main runtime engines, etc.
@


1.35
log
@BUG FIX: mhashopt check was to be disabled in vuln
mode, but I'd surrounded it with a wrong guard!
@
text
@#include <stdio.h>
#include <stdlib.h>
#include <string.h> /* memset */
#include <sys/resource.h> /* for getrusage timing stuff */
#include <sys/time.h> /* for gettimeofday timing stuff */
#include <time.h> /* time, ctime */

#include "tcptr_internal.h"
#include "tcmalloc-hash.h" /* for mhash_getsize optimization, and mhash_debugout */

/******************************************/
/* COMPILE_TIME FLAGS */
/******************************************/
/* #define TC_NOSIGNAL */

#define TC_PRINT_TIMINGS

/* #define TC_LINUX_PRINT_PROC_STAT */

/* #define TC_PRINT_STATS */ /* turned on when compiling -g */

/* #define LOG_VP_CALLERS */ /* diagnosis tool: logs histogram of vp callers */

/******************************************/
/* AUXILIARY */
/******************************************/
/* TIMINGS */
#ifdef TC_PRINT_TIMINGS /* { */
#define TC_DO_TIMINGS(x) x
struct rusage ru0, ru1, ru2, ru3, ru4, ru5;
struct timeval tv0, tv1, tv2, tv3, tv4, tv5;
#else /* } !defined TC_PRINT_TIMINGS { */
#define TC_DO_TIMINGS(x)
#endif /* } !defined TC_PRINT_TIMINGS */

#ifdef TC_PRINT_STATS /* { */
#define TC_STAT_COUNT(x) (statcounter[x]++)
#define TC_STAT_COUNT_KB_ADD(x,i) do {	static int tmp = 512;		\
					tmp += i;			\
					if(tmp >= 1024){		\
					  statcounter[x] += tmp/1024;	\
					  tmp = tmp%1024;		\
					}				\
				  } while(0)
#else /* } !defined TC_PRINT_STATS { */
#define TC_STAT_COUNT(x)
#define TC_STAT_COUNT_KB_ADD(x,i)
#endif /* } !defined TC_PRINT_STATS */

/* SIGNALS */
#ifndef TC_NOSIGNAL /* { */
#include <sys/types.h>
#include <signal.h>
#include <unistd.h>

#define TCSIG SIGUSR1
#define TCKILL kill(getpid(),TCSIG)

#else /* } TC_NOSIGNAL { */

#define TCKILL

#endif /* } TC_NOSIGNAL */

int tc_flag_hashopt_threshhold = 64; /* hash optimization lookup threshhold */

char * tc_flag_logfile = 0;

static char tc_flag_skipvp = 0;
static char tc_flag_skipst = 0;
static char tc_flag_skipct = 0;

/******************************************/
/* MIRROR SETUP */
/******************************************/
#if defined(TC_STATIC_MIRROR) /* { */
  /**************************************/
  /* STATIC MIRROR */
  /**************************************/

unsigned char _tc_mirror[1 << (sizeof(void *)*8 - TAGS_PER_BYTE_BITS)];

#else /* } !defined(TC_STATIC_MIRROR) { */
  /**************************************/
  /* NOT STATIC MIRROR: MIRRORMAP */
  /**************************************/

/* the mirrormap lookup table */
void * mirrormap[MIRRORMAP_NUMELEMENTS] = {0};

/* invariant: mirrormap_freelist[0] == 0 always, to signify bottom of "stack" */
void * mirrormap_freelist[TAGS_PER_BYTE] = {0};
void ** mirrormap_freelist_top = &mirrormap_freelist[0];

void _touchMirrorPage(unsigned long mapindex)
{
  if(*mirrormap_freelist_top){
    mirrormap[mapindex] = *mirrormap_freelist_top;
    mirrormap_freelist_top--;
 } else {
    int i;
    mirrormap[mapindex] = (void *) memalign(MIRRORPAGE_NUMBYTES, MIRRORPAGE_NUMBYTES);
    if(!mirrormap[mapindex])
      exit((_output_flce(__FILE__,__LINE__,0,"(_touchMirrorPage)","FATAL: memalign out of memory"),-1));
    for(i = 1; i < TAGS_PER_BYTE; ++i)
      *(++mirrormap_freelist_top) = (char *)mirrormap[mapindex] + i * MIRRORPAGE_SIZE;
  }
  /* initialize mirror to 0 */
  bzero(mirrormap[mapindex], MIRRORPAGE_SIZE);
}

#endif /* } !defined(TC_STATIC_MIRROR) */

/******************************************/
/* DIAGNOSTIC */
/******************************************/
/* typechecker output streams */
/* these are initialized in main() */
enum _tc_stream {_tc_null = 0,
		 _tc_stat,
		 _tc_error,
		 _tc_debug,
		 _tc_numstreams
		};
static FILE * streams[_tc_numstreams] = {0};

/* on function return, different modes of
   clearing the stack frame w.r.t. formals */
#define _TC_NONE        0
#define _TC_SEGS_ONLY   1
#define _TC_TO_SCALAR   2
#define _TC_TO_AGGR     3
#define _TC_TO_HIGHEST  4
static int tc_flag_clear = _TC_SEGS_ONLY;

static int tc_flag_signal = 1;

#ifdef TC_PRINT_STATS /* { */

enum statcounter_entries {
  sc_pr_calls,		/* number of processReturn calls */
  sc_vp_array,		/* verifyPtr of array-index expression */
  sc_vp_onebyte,	/* verifyPtr tag fits in one byte */
  sc_debug_vp_onebyte_ff,	/* verifyPtr one-byte is 0xff */
  sc_vp_twobytes,	/* verifyPtr tag fits in two byte */
  sc_vp_multibytes,	/* verifyPtr tag larger than 8 */
  sc_vp_multipage,	/* verifyPtr tag traversing page boundary */
  sc_vp_hash_succ,	/* verifyPtr hash optimization succeeded */
  sc_vp_hash_fail,	/* verifyPtr hash optimization failed */
  sc_st_onebyte,	/* setTag fits in one byte */
  sc_st_twobytes,	/* setTag fits in two byte */
  sc_st_multibytes,	/* setTag larger than 8 */
  sc_st_multipage,	/* setTag traversing page boundary */
  sc_ct_onebyte,	/* clearTag fits in one byte */
  sc_ct_twobytes,	/* clearTag fits in two byte */
  sc_ct_multibytes,	/* clearTag larger than 8 */
  sc_ct_multipage,	/* clearTag traversing page boundary */

  sc_count_vp,		/* count (total) calls, and number of bytes affected */
  sc_count_vp_kbs,
  sc_count_st,
  sc_count_st_kbs,
  sc_count_ct,
  sc_count_ct_kbs,
  sc_max
};
static const char * statdesc[sc_max] = {
  "pr_calls",
  "vp_array",
  "vp_onebyte",
  "debug_vp_onebyte_ff",
  "vp_twobytes",
  "vp_multibytes",
  "vp_multipage",
  "vp_hash_succ",
  "vp_hash_fail",
  "st_onebyte",
  "st_twobytes",
  "st_multibytes",
  "st_multipage",
  "ct_onebyte",
  "ct_twobytes",
  "ct_multibytes",
  "ct_multipage",
  "count_vp",
  "count_vp_kbs",
  "count_st",
  "count_st_kbs",
  "count_ct",
  "count_ct_kbs",
};
unsigned long long statcounter[sc_max] = {0};

struct static_count_node {
  const char * descr;
  unsigned long count;
  struct static_count_node * next;
} * static_count_head = 0;

#endif /* } TC_PRINT_STATS */

void _printConstsStderr()
{
#if !defined(TC_STATIC_MIRROR) /* { */
#define EXPAND_PRINT_STMT(CID) fprintf(stderr, #CID " = %d (0x%08x)\n", CID, CID)
  EXPAND_PRINT_STMT(MIRRORPAGE_NUMBITS);
  EXPAND_PRINT_STMT(MIRRORPAGE_NUMBYTES);
  EXPAND_PRINT_STMT(MIRRORPAGE_MASK);
  EXPAND_PRINT_STMT(MIRRORMAP_NUMBITS);
  EXPAND_PRINT_STMT(MIRRORMAP_NUMELEMENTS);
#undef EXPAND_PRINT_STMT
#endif /* } !defined(TC_STATIC_MIRROR) */
}

int tc_dont_die = 0;

struct msg_entry {
  const char * file;
  int line, col;
  const char * exp;
  int count;
  struct msg_entry * next;
} * msg_head = 0,
 ** msg_tail = &msg_head;

int tc_flag_summarize = 0;

static struct msg_entry * find(const char * file, int line, int col, const char * exp)
{
  struct msg_entry * n;
  if(file && *file){
    for(n = msg_head; n; n = n->next)
      if(n->line == line && n->col == col &&
	 (n->file == file || !strcmp(n->file, file)))
        return n;
  } else { /* empty file: library function; use exp as key */
    for(n = msg_head; n; n = n->next)
      if(n->exp == exp) return n;
  }
  return 0;
}

static int print_error_summary(FILE * os)
{
  int count = 0;
  struct msg_entry * n;
  for(n = msg_head; n; n = n->next){
    fprintf(os, "{%d}[%s:%d.%d](%s)\n", n->count, n->file, n->line, n->col, n->exp);
    count += n->count;
  }
  return count;
}

void _output_flce(const char * file, int line, int col, const char * exp, const char * msg)
{
  FILE * lf = streams[_tc_error];
  if(tc_flag_logfile){
    if((lf = fopen(tc_flag_logfile, "a"))){
      time_t now;
      char * tstr;
      time(&now);
      tstr = ctime(&now);
      fprintf(lf, "%s: ", tstr);
    } else {
      fprintf(streams[_tc_error], "TC Log Failed\n");
      lf = 0;
    }
  }
  if(lf){
    if(tc_flag_summarize){
      struct msg_entry * e = find(file, line, col, exp);
      if(e){
        e->count++;
      } else {
        fprintf(lf, "[%s:%d.%d](%s) %s\n", file, line, col, exp, msg);
        e = (struct msg_entry *) malloc(sizeof(struct msg_entry));
        if(!e){
          fprintf(lf, "_output_flce: malloc out of memory");
        } else {
          e->file = file;
          e->line = line;
          e->col = col;
          e->exp = exp;
          e->count = 1;
          e->next = 0;
          *msg_tail = e;
          msg_tail = &e->next;
        }
      }
    } else {
      fprintf(lf, "[%s:%d.%d](%s) %s\n", file, line, col, exp, msg);
      TCKILL;
    }
    if(tc_flag_logfile){
      fclose(lf);
    }
  }
  if(!tc_dont_die) exit(-1);
}

void _reportStaticCounts(const char * fname, const char * descr, int count)
{
#ifdef TC_PRINT_STATS /* { */
  struct static_count_node ** np;
  for(np = &static_count_head; *np; np = &(*np)->next){
    if(!strcmp(descr, (*np)->descr)){
      (*np)->count += count;
      break;
    }
  }
  if(!*np){
    *np = (struct static_count_node *) malloc(sizeof(struct static_count_node));
    (*np)-> descr = descr;
    (*np)->count = count;
    (*np)->next = 0;
  }
#endif /* } TC_PRINT_STATS */
}

void _printBinary(FILE * os, unsigned char c)
{
  int i;
  for(i = 0; i < _TC_BYTE; ++i, c >>= 1)
    fprintf(os, (c&0x01)?"I":"O");
}

void _printTag(FILE * os, const char * addr, size_t size)
{
  const char * saddr = addr;
  const char * eaddr = addr + size - 1;
  const unsigned char * sbyte = &GET_TAG_BYTE(saddr);
  const unsigned char * ebyte = &GET_TAG_BYTE(eaddr);
  int spos = MOD_TAGS_PER_BYTE(saddr);
  int epos = MOD_TAGS_PER_BYTE(eaddr);
  int mode = 0;
  int outcount = 0;

  if(sbyte == ebyte){ /* same byte */
    int i;
    unsigned char c = *sbyte;

    fprintf(os, "0x%08x: ", (unsigned long)saddr - spos);
    for(i = 0; i < _TC_BYTE; ++i){
      if(i == spos) mode = 1;
      fprintf(os, (mode)?((c & 0x01)?"I":"O"):((c & 0x01)?"i":"o"));
      if(i == epos) mode = 0;
      c >>= 1;
    }
  } else if(SAME_MIRROR_PAGE(saddr, eaddr)){
    int i;
    unsigned char c = *sbyte;
    unsigned long output_addr = (unsigned long)saddr - spos;

    fprintf(os, "0x%08x: ", output_addr);

    for(i = 0; i < _TC_BYTE; ++i){
      if(i == spos) mode = 1;
      fprintf(os, (mode)?((c & 0x01)?"I":"O"):((c & 0x01)?"i":"o"));
      c >>= 1;
    }
    outcount++;
    for(sbyte++; sbyte != ebyte; sbyte++){
      fprintf(os, " ");
      _printBinary(os, *sbyte);
      if(!(++outcount % 8))
        fprintf(os, "\n0x%08x:", output_addr += 64);
    }
    c = *sbyte;
    fprintf(os, " ");
    for(i = 0; i < _TC_BYTE; ++i){
      fprintf(os, (mode)?((c & 0x01)?"I":"O"):((c & 0x01)?"i":"o"));
      if(i == epos) mode = 0;
      c >>= 1;
    }
  } else { /* different mirror page */
#if !defined(TC_STATIC_MIRROR) /* { */
    int i;
    unsigned char c = *sbyte;
    unsigned long output_addr = (unsigned long)saddr - spos;
    const char * nbaddr = saddr;
    const unsigned char * nb_byte;
    const char * blank = " ";

    fprintf(os, "0x%08x: ", output_addr);

    for(i = 0; i < _TC_BYTE; ++i){
      if(i == spos) mode = 1;
      fprintf(os, (mode)?((c & 0x01)?"I":"O"):((c & 0x01)?"i":"o"));
      c >>= 1;
    }
    outcount++;
    sbyte++;
    do {
      nbaddr = (const char *)((unsigned long)nbaddr | MIRRORPAGE_MASK);
      nb_byte = &GET_TAG_BYTE(nbaddr) + 1;

      for(; sbyte != nb_byte; sbyte++){
        fprintf(os, blank);
        blank = " ";
        _printBinary(os, *sbyte);
        if(!(++outcount % 8))
          fprintf(os, "\n0x%08x:", output_addr += 64);
      }

      nbaddr++;
      sbyte = &GET_TAG_BYTE(nbaddr);
      blank = "*";
    } while(!SAME_MIRROR_PAGE(nbaddr, eaddr));

    for(; sbyte != ebyte; sbyte++){
      fprintf(os, blank);
      blank = " ";
      _printBinary(os, *sbyte);
      if(!(++outcount % 8))
        fprintf(os, "\n0x%08x:", output_addr += 64);
    }

    c = *sbyte;
    fprintf(os, blank);
    blank = " ";
    for(i = 0; i < _TC_BYTE; ++i){
      fprintf(os, (mode)?((c & 0x01)?"I":"O"):((c & 0x01)?"i":"o"));
      if(i == epos) mode = 0;
      c >>= 1;
    }
#endif /* } !defined(TC_STATIC_MIRROR) */
  }
  fprintf(os, "\n");
}

void _printTagStderr(const char * addr, size_t size)
{
  _printTag(stderr, addr, size);
}

/*****************************************/
/* print user and system time difference */
/*****************************************/
static void printdelta(FILE * s, struct rusage * r1, struct rusage * r2,
			struct timeval * tv1, struct timeval * tv2)
{
  struct timeval u1 = r1->ru_utime;
  struct timeval u2 = r2->ru_utime;
  struct timeval s1 = r1->ru_stime;
  struct timeval s2 = r2->ru_stime;

  fprintf(s, "%.3f r, %.3f u, %.3f s\n",
	(double)(tv2->tv_sec-tv1->tv_sec)+(double)(tv2->tv_usec-tv1->tv_usec)/1000000,
	(double)(u2.tv_sec-u1.tv_sec)+(double)(u2.tv_usec-u1.tv_usec)/1000000,
	(double)(s2.tv_sec-s1.tv_sec)+(double)(s2.tv_usec-s1.tv_usec)/1000000
	);
}

/******************************************/
/* API FUNCTIONS */
/******************************************/

#ifdef LOG_VP_CALLERS /* { */
static struct flc_count_node {
  const char * file;
  int line, col;
  const char * exp;
  int ncalls, nbytes;
  struct flc_count_node * next;
} * vp_callers = 0;
#endif /* } LOG_VP_CALLERS  */

void _tcptr_verifyPtr(const char * file, int line, int col, const char * exp,
		const void * addr, size_t size)
{
#if defined(TC_VULNERABLE_VP) /* { */
#define VP_VALID_TAG_BYTE 0
#else /* } !defined(TC_VULNERABLE_VP) { */
#define VP_VALID_TAG_BYTE 0xff
#endif /* } !defined(TC_VULNERABLE_VP) */

  if(tc_flag_skipvp) return;

#ifdef LOG_VP_CALLERS /* { */
  {
    struct flc_count_node * np;
    for(np = vp_callers; np; np = np->next){
      if(np->file == file &&
	  np->line == line &&
	  np->col == col){
        np->ncalls++;
        np->nbytes += size;
        break;
      }
    }
    if(!np){
      np = (struct flc_count_node *) malloc(sizeof(struct flc_count_node));
      np->file = file;
      np->line = line;
      np->col = col;
      np->exp = exp;
      np->ncalls = 1;
      np->nbytes = size;
      np->next = vp_callers;
      vp_callers = np;
    }
  }
#endif /* } LOG_VP_CALLERS  */

  TC_STAT_COUNT(sc_count_vp);
  TC_STAT_COUNT_KB_ADD(sc_count_vp_kbs, size);

#ifdef TC_PRINT_STATS /* { */
  /* count array-index expressions -- use exp string to guess */
  if(exp[strlen(exp)-1] == ']'){
    TC_STAT_COUNT(sc_vp_array);
  }
#endif /* } ifdef TC_PRINT_STATS */

  if((signed)(MOD_TAGS_PER_BYTE(addr)) <= TAGS_PER_BYTE - (signed)size){

    unsigned char mask = ((~(0xffu << (size))) << MOD_TAGS_PER_BYTE(addr));

    /* tag is all in one byte */
    TC_STAT_COUNT(sc_vp_onebyte);

#ifdef TC_PRINT_STATS /* { */
    if(GET_TAG_BYTE(addr) == VP_VALID_TAG_BYTE)
      TC_STAT_COUNT(sc_debug_vp_onebyte_ff);
#endif /* } TC_PRINT_STATS */

#if defined(TC_VULNERABLE_VP) /* { */
    if((mask & GET_TAG_BYTE(addr)) != 0)
      _output_flce(file,line,col,exp, "Vuln-VerifyPtr failed (case 1)");
#else /* } !defined(TC_VULNERABLE_VP) { */
    if((mask & GET_TAG_BYTE(addr)) != mask)
      _output_flce(file,line,col,exp, "VerifyPtr failed (case 1)");
#endif /* } !defined(TC_VULNERABLE_VP) */

  } else {

    const char * saddr = (const char *) addr;
    const char * eaddr = saddr + size;
    unsigned char maskfront = (0xff << MOD_TAGS_PER_BYTE(saddr));
    unsigned char maskback = (0xffu >> (TAGS_PER_BYTE-MOD_TAGS_PER_BYTE(eaddr)));
    unsigned char * head_byte = &GET_TAG_BYTE(saddr);
    unsigned char * tail_byte = &GET_TAG_BYTE(eaddr);

    if(head_byte == tail_byte-1){

      /* tag is split across two successive bytes */
      TC_STAT_COUNT(sc_vp_twobytes);

#if defined(TC_VULNERABLE_VP) /* { */
      if((maskfront & GET_TAG_BYTE(saddr)) != 0 ||
         (maskback  & GET_TAG_BYTE(eaddr)) != 0)
        _output_flce(file,line,col,exp, "Vuln-VerifyPtr failed (case 2)");
#else /* } !defined(TC_VULNERABLE_VP) { */
      if((maskfront & GET_TAG_BYTE(saddr)) != maskfront ||
         (maskback  & GET_TAG_BYTE(eaddr)) != maskback)
        _output_flce(file,line,col,exp, "VerifyPtr failed (case 2)");
#endif /* } !defined(TC_VULNERABLE_VP) */

    } else {

      TC_STAT_COUNT(sc_vp_multibytes);

      /* mhash optimization: disable for vuln-vp */
#if !defined(TC_VULNERABLE_VP) /* { */
      if(size >= tc_flag_hashopt_threshhold){
	if(size <= mhash_getsize(addr)){
          TC_STAT_COUNT(sc_vp_hash_succ);
          return;
        } else {
          TC_STAT_COUNT(sc_vp_hash_fail);
        }
      }
#endif /* } !defined(TC_VULNERABLE_VP) */

      if(SAME_MIRROR_PAGE(saddr, eaddr)){

#if defined(TC_VULNERABLE_VP) /* { */
        if((maskfront & *head_byte) != 0 ||
	   (maskback  & *tail_byte) != 0){
          _output_flce(file,line,col,exp, "Vuln-VerifyPtr failed (case 3a)");
        }
#else /* } !defined(TC_VULNERABLE_VP) { */
        if((maskfront & *head_byte) != maskfront ||
	   (maskback  & *tail_byte) != maskback){
          _output_flce(file,line,col,exp, "VerifyPtr failed (case 3a)");
        }
#endif /* } !defined(TC_VULNERABLE_VP) */
        else {
          for(head_byte++; head_byte != tail_byte; ++head_byte){
            if(*head_byte != VP_VALID_TAG_BYTE){
              _output_flce(file,line,col,exp, "VerifyPtr failed (case 3b)");
              break;
            }
          }
        }


      } else {
#if !defined(TC_STATIC_MIRROR) /* { */

        TC_STAT_COUNT(sc_vp_multipage);

#if defined(TC_VULNERABLE_VP) /* { */
        if((maskfront & *head_byte) != 0 ||
           (maskback  & *tail_byte) != 0){
          _output_flce(file,line,col,exp, "Vuln-VerifyPtr failed (case 3c)");
        }
#else /*  }!defined(TC_VULNERABLE_VP) { */
        if((maskfront & *head_byte) != maskfront ||
           (maskback  & *tail_byte) != maskback){
          _output_flce(file,line,col,exp, "VerifyPtr failed (case 3c)");
        }
#endif /* } !defined(TC_VULNERABLE_VP) */
        else {

          const char * nbaddr = saddr;

          head_byte++;

          do {
            const unsigned char * nb_byte;

            nbaddr = (const char *)((unsigned long)nbaddr | MIRRORPAGE_MASK);
            nb_byte = &GET_TAG_BYTE(nbaddr) + 1;

            for(; head_byte != nb_byte; ++head_byte){
              if(*head_byte != VP_VALID_TAG_BYTE){
                _output_flce(file,line,col,exp, "VerifyPtr failed (case 3d)");
                return;
              }
            }

            nbaddr++;
            head_byte = &GET_TAG_BYTE(nbaddr);

          } while(!SAME_MIRROR_PAGE(nbaddr, eaddr));

          for(; head_byte != tail_byte; ++head_byte){
            if(*head_byte != VP_VALID_TAG_BYTE){
              _output_flce(file,line,col,exp, "VerifyPtr failed (case 3e)");
              return;
            }
          }
        }
#endif /* } !defined(TC_STATIC_MIRROR) */
      }
    }
  }
#undef VP_VALID_TAG_BYTE
}

void _tcptr_setTags(const void * addr, size_t size)
{
  if(tc_flag_skipst) return;

  TC_STAT_COUNT(sc_count_st);
  TC_STAT_COUNT_KB_ADD(sc_count_st_kbs, size);

  if((signed)(MOD_TAGS_PER_BYTE(addr)) <= TAGS_PER_BYTE - (signed)size){

    unsigned char mask = ((~(0xffu << (size))) << MOD_TAGS_PER_BYTE(addr));

    /* tag is all in one byte */
    TC_STAT_COUNT(sc_st_onebyte);

    GET_TAG_BYTE(addr) |= mask;

  } else {

    const char * saddr = (const char *) addr;
    const char * eaddr = saddr + size;
    unsigned char maskfront = (0xff << MOD_TAGS_PER_BYTE(saddr));
    unsigned char maskback = (0xffu >> (TAGS_PER_BYTE-MOD_TAGS_PER_BYTE(eaddr)));
    unsigned char * head_byte = &GET_TAG_BYTE(saddr);
    unsigned char * tail_byte = &GET_TAG_BYTE(eaddr);

    if(head_byte == tail_byte-1){

      /* tag is split across two successive bytes */
      TC_STAT_COUNT(sc_st_twobytes);

      *head_byte |= maskfront;
      *tail_byte |= maskback;

    } else {

      TC_STAT_COUNT(sc_st_multibytes);

      if(SAME_MIRROR_PAGE(saddr, eaddr)){

        *head_byte |= maskfront;
        memset(head_byte+1, 0xff, tail_byte - head_byte - 1);
        *tail_byte |= maskback;

      } else {
#if !defined(TC_STATIC_MIRROR) /* { */

        const char * nbaddr = saddr;

        TC_STAT_COUNT(sc_st_multipage);

        *head_byte |= maskfront;

        head_byte++;

        do {

          const unsigned char * nb_byte;

          nbaddr = (const char *)((unsigned long)nbaddr | MIRRORPAGE_MASK);
          nb_byte = &GET_TAG_BYTE(nbaddr) + 1;

          memset(head_byte, 0xff, nb_byte - head_byte);

          nbaddr++;
          head_byte = &GET_TAG_BYTE(nbaddr);

        } while(!SAME_MIRROR_PAGE(nbaddr, eaddr));

        memset(head_byte, 0xff, tail_byte - head_byte);

        *tail_byte |= maskback;
#endif /* } !defined(TC_STATIC_MIRROR) */
      }
    }
  }
}

/* should be near-identical to setTags */
void _tcptr_clearTags(const void * addr, size_t size)
{
  if(tc_flag_skipct) return;

  TC_STAT_COUNT(sc_count_ct);
  TC_STAT_COUNT_KB_ADD(sc_count_ct_kbs, size);

  if((signed)(MOD_TAGS_PER_BYTE(addr)) <= TAGS_PER_BYTE - (signed)size){

    unsigned char mask = ((~(0xffu << (size))) << MOD_TAGS_PER_BYTE(addr));

    /* tag is all in one byte */
    TC_STAT_COUNT(sc_ct_onebyte);

    GET_TAG_BYTE(addr) &= ~mask;

  } else {

    const char * saddr = (const char *) addr;
    const char * eaddr = saddr + size;
    unsigned char maskfront = (0xff << MOD_TAGS_PER_BYTE(saddr));
    unsigned char maskback = (0xffu >> (TAGS_PER_BYTE-MOD_TAGS_PER_BYTE(eaddr)));
    unsigned char * head_byte = &GET_TAG_BYTE(saddr);
    unsigned char * tail_byte = &GET_TAG_BYTE(eaddr);

    if(head_byte == tail_byte-1){

      /* tag is split across two successive bytes */
      TC_STAT_COUNT(sc_ct_twobytes);

      *head_byte &= ~maskfront;
      *tail_byte &= ~maskback;

    } else {

      TC_STAT_COUNT(sc_ct_multibytes);

      if(SAME_MIRROR_PAGE(saddr, eaddr)){

        *head_byte &= ~maskfront;
        memset(head_byte+1, 0x00, tail_byte - head_byte - 1);
        *tail_byte &= ~maskback;

      } else {
#if !defined(TC_STATIC_MIRROR) /* { */

        const char * nbaddr = saddr;

        TC_STAT_COUNT(sc_ct_multipage);

        *head_byte &= ~maskfront;

        head_byte++;

        do {

          const unsigned char * nb_byte;

          nbaddr = (const char *)((unsigned long)nbaddr | MIRRORPAGE_MASK);
          nb_byte = &GET_TAG_BYTE(nbaddr) + 1;

          memset(head_byte, 0x00, nb_byte - head_byte);

          nbaddr++;
          head_byte = &GET_TAG_BYTE(nbaddr);

        } while(!SAME_MIRROR_PAGE(nbaddr, eaddr));

        memset(head_byte, 0x00, tail_byte - head_byte);

        *tail_byte &= ~maskback;
#endif /* } !defined(TC_STATIC_MIRROR) */
      }
    }
  }
}

void _tcptr_processReturn(void * scaf_start, void * scaf_end,
			  void * agrf_start, void * agrf_end,
			  void * local_start)
{
  static int debugflag = 0;

  /* mark end of stack frame */
  void * sf_top = &sf_top;

  TC_STAT_COUNT(sc_pr_calls);

  /* Clear the stack frame between sf_bottom and sf_top */

  /* mark start of stack */
  if(local_start > sf_top){ /* stack grows downward */

    void * sf_bottom = local_start;

    switch(tc_flag_clear){
      case _TC_TO_HIGHEST:
           if(scaf_start && scaf_end > sf_bottom) sf_bottom = scaf_end;
           if(agrf_start && agrf_end > sf_bottom) sf_bottom = agrf_end;
           break;
      case _TC_TO_SCALAR:
           if(scaf_start && scaf_end > sf_bottom) sf_bottom = scaf_end;
           if(agrf_start && agrf_end > scaf_end) {
             _tcptr_clearTags(agrf_start, (char *)agrf_end-(char *)agrf_start);
           }
           break;
      case _TC_TO_AGGR:
           if(agrf_start && agrf_end > sf_bottom) sf_bottom = agrf_end;
           if(scaf_start && scaf_end > agrf_end) {
             _tcptr_clearTags(scaf_start, (char *)scaf_end-(char *)scaf_start);
           }
           break;
      case _TC_SEGS_ONLY:
           if(scaf_start) {
             _tcptr_clearTags(scaf_start, (char *)scaf_end-(char *)scaf_start);
           }
           if(agrf_start) {
             _tcptr_clearTags(agrf_start, (char *)agrf_end-(char *)agrf_start);
           }
      case _TC_NONE:
           ;
    }

    _tcptr_clearTags(sf_top, (char *)sf_bottom-(char *)sf_top);

    if(!debugflag++ && streams[_tc_debug])
      fprintf(streams[_tc_debug], "Note: stack grows decreasingly!\n");

  } else {                /* stack grows upward   */

    void * sf_bottom = local_start;

    switch(tc_flag_clear){
      case _TC_TO_HIGHEST:
           if(scaf_start && scaf_start < sf_bottom) sf_bottom = scaf_start;
           if(agrf_start && agrf_start < sf_bottom) sf_bottom = agrf_start;
           break;
      case _TC_TO_SCALAR:
           if(scaf_start && scaf_start < sf_bottom) sf_bottom = scaf_start;
           if(agrf_start && agrf_start < scaf_start) {
             _tcptr_clearTags(agrf_start, (char *)agrf_end-(char *)agrf_start);
           }
           break;
      case _TC_TO_AGGR:
           if(agrf_start && agrf_start < sf_bottom) sf_bottom = agrf_end;
           if(scaf_start && scaf_start < agrf_start) {
             _tcptr_clearTags(scaf_start, (char *)scaf_end-(char *)scaf_start);
           }
           break;
      case _TC_SEGS_ONLY:
           if(scaf_start) {
             _tcptr_clearTags(scaf_start, (char *)scaf_end-(char *)scaf_start);
           }
           if(agrf_start) {
             _tcptr_clearTags(agrf_start, (char *)agrf_end-(char *)agrf_start);
           }
      case _TC_NONE:
           ;
    }

    _tcptr_clearTags(sf_bottom, (char *)sf_top-(char *)sf_bottom);

    if(!debugflag++ && streams[_tc_debug])
      fprintf(streams[_tc_debug], "Note: stack grows increasingly\n");
  }
}

/******************************************/

/******************************************/
/* SETUP - not needed! */
/******************************************/
void processExternVars(void)
{
}

/***********************************/
/* CLEANUP */
/***********************************/
static void cleanup()
{
  FILE * statstream = streams[_tc_stat];

#ifdef TC_PRINT_STATS /* { */
  if(statstream){
    extern void print_histo(FILE * s);	/* defined in tcptrhisto.c */
    tcptr_print_histo(statstream);

    mhash_debugout(statstream);	/* defined in tcmalloc-hash.c */
  }
#endif /* } TC_PRINT_STATS */

#ifdef LOG_VP_CALLERS /* { */
  if(statstream){
    struct flc_count_node * np;
    fprintf(statstream, "VPcounts:\n");
    for(np = vp_callers; np; np = np->next){
      fprintf(statstream, "VPcount(%d,%d): %s:%d.%d (%s)\n", np->ncalls, np->nbytes,
					np->file, np->line, np->col, np->exp);
    }
  }
#endif /* } LOG_VP_CALLERS */

  TC_DO_TIMINGS(getrusage(RUSAGE_SELF, &ru5));
  TC_DO_TIMINGS(gettimeofday(&tv5, 0));
#ifdef TC_PRINT_TIMINGS /* { */
  if(statstream){
    fprintf(statstream, "Total time: ");
    printdelta(statstream, &ru0, &ru5, &tv0, &tv5);

    fprintf(statstream, "Call init functions: ");
    printdelta(statstream, &ru1, &ru2, &tv1, &tv2);

    fprintf(statstream, "Process externs: ");
    printdelta(statstream, &ru2, &ru3, &tv2, &tv3);

    fprintf(statstream, "Prog_main: ");
    printdelta(statstream, &ru4, &ru5, &tv4, &tv5);

    fprintf(statstream, "RU Min PgFaults: %ld\n", ru5.ru_minflt);
    fprintf(statstream, "RU Maj PgFaults: %ld\n", ru5.ru_majflt);

/* These are unfortunately not implemented in current linux
    fprintf(statstream, "RU Max RSS: %ld\n", ru5.ru_maxrss);
    fprintf(statstream, "RU Swaps: %ld\n", ru5.ru_nswap);
*/

#ifdef TC_LINUX_PRINT_PROC_STAT /* { */
    {
      FILE * statf = fopen("/proc/self/stat", "r");
      if(statf){
	int pid;
	char comm[1024];	/* unsafe scanf! :-D */
	char state;
	int ppid, pgrp, session,
	tty, tty_pgrp, flags,
	min_flt, cmin_flt, maj_flt, cmaj_flt,
	utime, stime, cutime, cstime,
	counter, priority, timeout,
	it_real_value,
	start_time,
	vsize, rss, rlim,
	start_code, end_code,
	start_stack, esp, eip,
	signal, blocked, sigign, sigcatch,
	wchan,
	nswap, cnswap,
	exit_signal, processor;

        fscanf(statf, "%d %s %c ""%d%d%d""%d%d%u""%u%u%u%u""%d%d%d%d""%d%d%u""%u""%d"
			"%u%u%u""%u%u""%u%u%u""%d%d%d%d""%u""%d%d""%d%d",
		&pid, comm, &state,
		&ppid, &pgrp, &session,
		&tty, &tty_pgrp, &flags,
		&min_flt, &cmin_flt, &maj_flt, &cmaj_flt,
		&utime, &stime, &cutime, &cstime,
		&counter, &priority, &timeout,	/* or priority/nice/NULL? */
		&it_real_value,
		&start_time,
		&vsize, &rss, &rlim,
		&start_code, &end_code,
		&start_stack, &esp, &eip,
		&signal, &blocked, &sigign, &sigcatch,
		&wchan,
		&nswap, &cnswap,
		&exit_signal, &processor);
        fprintf(statstream, "proc/stat: minflt = %u\n", min_flt);
        fprintf(statstream, "proc/stat: majflt = %u\n", maj_flt);
        fprintf(statstream, "proc/stat: vsize = %u\n", vsize);
        fprintf(statstream, "proc/stat: rss = %u\n", rss);
        fprintf(statstream, "proc/stat: rlim = %u\n", rlim);
        fprintf(statstream, "proc/stat: nswap = %d\n", nswap);
        fclose(statf);
      }
    }
#endif /* } TC_LINUX_PRINT_PROC_STAT */
  }
#endif /* } TC_PRINT_TIMINGS */

#ifdef TC_PRINT_STATS /* { */
  if(statstream){
    int i;
    for(i = 0; i < sc_max; ++i){
      fprintf(statstream, "Dynamic %s = %llu\n", statdesc[i], statcounter[i]);
    }
  }
  if(statstream){
    struct static_count_node * np;
    for(np = static_count_head; np; np = np->next)
      fprintf(statstream, "Static %s = %lu\n", np->descr, np->count);
  }
#endif /* } TC_PRINT_STATS */

  if(tc_flag_summarize && streams[_tc_error]){
    int nerr = print_error_summary(streams[_tc_error]);
    fprintf(streams[_tc_error], "Total errors = %d\n", nerr);
  }
}

/******************************************/
/* MAIN */
/******************************************/
#if !defined(STANDALONE) /* { */
int main(int argc, char * argv[], char * envp[])
{
  extern void callInitFunctions(void);
  extern int _prog_main(int argc, char * argv[], char * envp[]);
  char * argv_array_end;
  int tc_init_argv = 1;
  int tc_init_envp = 1;
  int tc_info = 0;
  int i;

  /* this points to the terminating null in the argv array */
  argv_array_end = argv[argc-1] + strlen(argv[argc-1]);

  TC_DO_TIMINGS(getrusage(RUSAGE_SELF, &ru0));
  TC_DO_TIMINGS(gettimeofday(&tv0, 0));

  /* typechecker output streams */
  /* if set to 0, nothing will be output */
  streams[_tc_stat] = stderr;
  streams[_tc_debug] = 0; /* debug messages are just meaninglessly annoying */
  streams[_tc_error] = stderr;

#ifndef TC_NOSIGNAL /* { */
  signal(TCSIG,SIG_IGN);
#endif /* } !TC_NOSIGNAL */

  /* register the cleanup function with atexit() */
  atexit(cleanup);

  /* intercept TC command-line arguments */
  for(i = 0; i < argc; ++i){
    if(!strncmp(argv[i],"-tc-",4)){
      int j;
      if(!strcmp(argv[i]+4,"sig")) tc_flag_signal = 1;
      else if(!strcmp(argv[i]+4,"nosig")) tc_flag_signal = 0;
      else if(!strcmp(argv[i]+4,"summarize")) tc_flag_summarize = 1;
      else if(!strcmp(argv[i]+4,"skip-vp")) tc_flag_skipvp = 1;
      else if(!strcmp(argv[i]+4,"skip-st")) tc_flag_skipst = 1;
      else if(!strcmp(argv[i]+4,"skip-ct")) tc_flag_skipct = 1;
      else if(!strcmp(argv[i]+4,"dont-die")) tc_dont_die = 1;
      else if(!strcmp(argv[i]+4,"no-argv")) tc_init_argv = 0;
      else if(!strcmp(argv[i]+4,"no-envp")) tc_init_envp = 0;
      else if(!strcmp(argv[i]+4,"info")) tc_info = 1;
      else if(!strncmp(argv[i]+4,"hashopt=",8)){
        tc_flag_hashopt_threshhold = atoi(argv[i]+12);
        fprintf(stderr, "TC: Setting hashopt threshhold to %d\n", tc_flag_hashopt_threshhold);
      } else if(!strncmp(argv[i]+4,"clear=",6)){
        if(!strcmp(argv[i]+10,"none"))
	  tc_flag_clear = _TC_NONE;
        else if(!strcmp(argv[i]+10,"segs"))
	  tc_flag_clear = _TC_SEGS_ONLY;
        else if(!strcmp(argv[i]+10,"scalar"))
	  tc_flag_clear = _TC_TO_SCALAR;
        else if(!strcmp(argv[i]+10,"aggr"))
	  tc_flag_clear = _TC_TO_AGGR;
        else if(!strcmp(argv[i]+10,"highest"))
	  tc_flag_clear = _TC_TO_HIGHEST;
        else fprintf(stderr, "TC: Unrecognized -tc- flag ignored (%s)\n", argv[i]);
      } else if(!strncmp(argv[i]+4,"logfile=",8)){
        FILE * lf;
	tc_flag_logfile = argv[i]+12;
        if((lf = fopen(tc_flag_logfile, "a"))){
          time_t now;
          char * tstr;
          int li;
          time(&now);
          tstr = ctime(&now);
          fprintf(lf, "%s: TCPTR Running :", tstr);
          for(li = 0; li < argc; ++li)
            fprintf(lf, " %s", argv[li]);
          fprintf(lf, "\n");
          fclose(lf);
          fprintf(stderr, "TC: Logging errors to file (%s)\n", tc_flag_logfile);
        } else {
          fprintf(stderr, "TC: Logfile (%s) append failed; no logging...\n", tc_flag_logfile);
	  tc_flag_logfile = 0;
        }
      } else if(!strncmp(argv[i]+4,"stream-",7)){
        enum _tc_stream stream_id = _tc_null;
	const char * stream_id_str = argv[i]+11;

	if(!strncmp(stream_id_str, "stat", 4)) stream_id = _tc_stat;
	else if(!strncmp(stream_id_str, "error", 5)) stream_id = _tc_error;
	else if(!strncmp(stream_id_str, "debug", 5)) stream_id = _tc_debug;
	else fprintf(stderr, "TC: Unrecognized stream in argument %s\n", argv[i]); 

	if(stream_id != _tc_null){
	  const char * fname = strchr(argv[i]+11, '=');
          if(!fname){
	    fprintf(stderr, "TC: Malformed stream argument %s\n", argv[i]);
	  } else {
	    fname++;
	    if(!strcmp(fname,"")){
	      streams[stream_id] = 0;
	      fprintf(stderr, "TC: Disabling stream (%s)\n", stream_id_str);
	    } else if(!strcmp(fname,"-")){
	      streams[stream_id] = stdout;
	      fprintf(stderr, "TC: Setting stream to stdout (%s)\n", stream_id_str);
	    } else if(!strcmp(fname,"=")){
	      streams[stream_id] = stderr;
	      fprintf(stderr, "TC: Setting stream to stderr (%s)\n", stream_id_str);
	    } else {
	      if((streams[stream_id] = fopen(fname, "w")))
	        fprintf(stderr, "TC: Redirecting stream to file %s (%s)\n", fname, stream_id_str);
	      else
	        fprintf(stderr, "TC: Error opening file %s for output (%s)\n", fname, stream_id_str);
	    }
	  }
        }
      } else fprintf(stderr, "TC: Unrecognized -tc- flag ignored (%s)\n", argv[i]);

      /* adjust remaining args */
      {
        int argvilen = strlen(argv[i])+1;

        /* 0. decrement array_end marker by argvilen, argc by one */
        argv_array_end -= argvilen;
        argc--;

        /* 1. copy argv bytes forward by argvilen */
        { char * c;
          for(c = argv[i]; c <= argv_array_end; ++c)
            c[0] = c[argvilen];
        }

        /* 2. subtract argvs by argvilen */
        { int j;
          for(j = i; j < argc; ++j) argv[j] = argv[j+1] - argvilen;
          argv[argc] = 0;
        }
        i--; /* decrement to process next item */
      }
    }
  }

  /* Initialize globals and externs */
  TC_DO_TIMINGS(getrusage(RUSAGE_SELF, &ru1));
  TC_DO_TIMINGS(gettimeofday(&tv1, 0));
  callInitFunctions();
  TC_DO_TIMINGS(getrusage(RUSAGE_SELF, &ru2));
  TC_DO_TIMINGS(gettimeofday(&tv2, 0));
  processExternVars();
  TC_DO_TIMINGS(getrusage(RUSAGE_SELF, &ru3));
  TC_DO_TIMINGS(gettimeofday(&tv3, 0));

#if !defined(TC_VULNERABLE_VP) /* { */
  if(tc_init_argv){
    int count_argv_bytes = 0;

    /* initialize argv */
    for(i = 0; i < argc; ++i){
      _tcptr_setTags(&argv[i],sizeof(char *));
      _tcptr_setTags(argv[i],strlen(argv[i])+1);
      count_argv_bytes += strlen(argv[i])+1;
    }

    /* (terminating null pointer) */
    _tcptr_setTags(&argv[i],sizeof(char *));

#ifdef TC_PRINT_STATS /* { */
    if(streams[_tc_stat]){
      fprintf(streams[_tc_stat] , "Init: %d argvs, %d bytes\n", argc, count_argv_bytes);
    }
#endif /* } TC_PRINT_STATS */
  }
#endif /* } !defined(TC_VULNERABLE_VP) */

#if !defined(TC_VULNERABLE_VP) /* { */
  if(tc_init_envp){
    int count_envp = 0;
    int count_envp_bytes = 0;

    /* initialize envp */
    for(i = 0; envp[i]; ++i){
      _tcptr_setTags(&envp[i],sizeof(char *));
      _tcptr_setTags(envp[i],strlen(envp[i])+1);
      count_envp_bytes += strlen(envp[i])+1;
    }
    count_envp = i;

    /* (terminating null pointer) */
    _tcptr_setTags(&envp[i],sizeof(char *));

#ifdef TC_PRINT_STATS /* { */
    if(streams[_tc_stat]){
      fprintf(streams[_tc_stat] , "Init: %d envps, %d bytes\n", count_envp, count_envp_bytes);
    }
#endif /* } TC_PRINT_STATS */
  }
#endif /* } !defined(TC_VULNERABLE_VP) */

  if(tc_info) return 1;

  TC_DO_TIMINGS(getrusage(RUSAGE_SELF, &ru4));
  TC_DO_TIMINGS(gettimeofday(&tv4, 0));
  return _prog_main(argc, argv, envp);
}

#else /* } if defined(STANDALONE) { */

/*********************************/
/* standalone test main function */
/*********************************/
int main()
{
  streams[_tc_error] = stderr;

  printf("Mirrorpage Numbytes = %d\n", MIRRORPAGE_NUMBYTES);
  printf("Mirrorpage Size = %d\n", MIRRORPAGE_SIZE);
  printf("Mirrorpage Zero Mask = 0x%08x\n", MIRRORPAGE_ZERO_MASK);
  printf("Mirrorpage Mask = 0x%08x\n", MIRRORPAGE_MASK);
  printf("Mirrormap Numbits = %d\n", MIRRORMAP_NUMBITS);
  printf("Mirrormap Numelements = %d\n", MIRRORMAP_NUMELEMENTS);

  /* setTags */
  fprintf(stderr, "SetTags test:\n");

#define SET_TAG_TEST(ADDR,SIZE) \
	fprintf(stderr, "%08x, %d: ", ADDR, SIZE); \
	_tcptr_setTags((unsigned char *) ADDR, SIZE); \
	_printTagStderr((unsigned char *) ADDR, SIZE+8);
  SET_TAG_TEST(0x0000, 0)
  SET_TAG_TEST(0x0100, 1)
  SET_TAG_TEST(0x0200, 7)
  SET_TAG_TEST(0x0300, 8)
  SET_TAG_TEST(0x0400, 9)
  SET_TAG_TEST(0x0500, 15)
  SET_TAG_TEST(0x0600, 16)
  SET_TAG_TEST(0x0700, 17)
  SET_TAG_TEST(0x0800, 23)
  SET_TAG_TEST(0x0900, 24)
  SET_TAG_TEST(0x0a00, 25)

  SET_TAG_TEST(0x1000, 7)
  SET_TAG_TEST(0x1101, 7)
  SET_TAG_TEST(0x1207, 7)
  SET_TAG_TEST(0x1308, 7)
  SET_TAG_TEST(0x1400, 8)
  SET_TAG_TEST(0x1501, 8)
  SET_TAG_TEST(0x1607, 8)
  SET_TAG_TEST(0x1708, 8)
  SET_TAG_TEST(0x1800, 9)
  SET_TAG_TEST(0x1901, 9)
  SET_TAG_TEST(0x1a07, 9)
  SET_TAG_TEST(0x1b08, 9)
  SET_TAG_TEST(0x1c00, 15)
  SET_TAG_TEST(0x1d01, 15)
  SET_TAG_TEST(0x1e07, 15)
  SET_TAG_TEST(0x1f08, 15)

  SET_TAG_TEST(0x000ffff1, 30)
  SET_TAG_TEST(0x001fffff, 2)
#undef SET_TAG_TEST

  /* clearTags */
  fprintf(stderr, "ClearTags test:\n");
#define CLEAR_TAG_TEST(ADDR,SIZE) \
	fprintf(stderr, "%08x, %d: ", ADDR, SIZE); \
	_tcptr_setTags((unsigned char *) ADDR-1, SIZE+2); \
	_tcptr_clearTags((unsigned char *) ADDR, SIZE); \
	_printTagStderr((unsigned char *) ADDR-1, SIZE+8);
  CLEAR_TAG_TEST(0x2000, 0)
  CLEAR_TAG_TEST(0x2100, 1)
  CLEAR_TAG_TEST(0x2200, 7)
  CLEAR_TAG_TEST(0x2300, 8)
  CLEAR_TAG_TEST(0x2400, 9)
  CLEAR_TAG_TEST(0x2500, 15)
  CLEAR_TAG_TEST(0x2600, 16)
  CLEAR_TAG_TEST(0x2700, 17)
  CLEAR_TAG_TEST(0x2800, 23)
  CLEAR_TAG_TEST(0x2900, 24)
  CLEAR_TAG_TEST(0x2a00, 25)

  CLEAR_TAG_TEST(0x3000, 7)
  CLEAR_TAG_TEST(0x3101, 7)
  CLEAR_TAG_TEST(0x3207, 7)
  CLEAR_TAG_TEST(0x3308, 7)
  CLEAR_TAG_TEST(0x3400, 8)
  CLEAR_TAG_TEST(0x3501, 8)
  CLEAR_TAG_TEST(0x3607, 8)
  CLEAR_TAG_TEST(0x3708, 8)
  CLEAR_TAG_TEST(0x3800, 9)
  CLEAR_TAG_TEST(0x3901, 9)
  CLEAR_TAG_TEST(0x3a07, 9)
  CLEAR_TAG_TEST(0x3b08, 9)
  CLEAR_TAG_TEST(0x3c00, 15)
  CLEAR_TAG_TEST(0x3d01, 15)
  CLEAR_TAG_TEST(0x3e07, 15)
  CLEAR_TAG_TEST(0x3f08, 15)
#undef CLEAR_TAG_TEST

  /* verifyPtr */
  fprintf(stderr, "VerifyPtr test:\n");
#define VERIFY_PTR_TEST(ADDR,SIZE) \
	fprintf(stderr, "%08x, %d:\n", ADDR, SIZE); \
	_tcptr_setTags((unsigned char *) ADDR, SIZE); \
	_tcptr_verifyPtr("",0,0,"fit",(unsigned char *) ADDR, SIZE); \
	_tcptr_verifyPtr("",0,0,"<1",(unsigned char *) ADDR-1, SIZE); \
	_tcptr_verifyPtr("",0,0,">1",(unsigned char *) ADDR, SIZE+1);

  VERIFY_PTR_TEST(0x4000, 0)
  VERIFY_PTR_TEST(0x4100, 1)
  VERIFY_PTR_TEST(0x4200, 7)
  VERIFY_PTR_TEST(0x4300, 8)
  VERIFY_PTR_TEST(0x4400, 9)
  VERIFY_PTR_TEST(0x4500, 15)
  VERIFY_PTR_TEST(0x4600, 16)
  VERIFY_PTR_TEST(0x4700, 17)
  VERIFY_PTR_TEST(0x4800, 23)
  VERIFY_PTR_TEST(0x4900, 24)
  VERIFY_PTR_TEST(0x4a00, 25)
#undef VERIFY_PTR_TEST



  return 0;
}

#endif /* defined(STANDALONE) */

@


1.34
log
@Replaced _output_error() with _output_flce() in library
functions, so their output can be controlled by tc-summarize.
@
text
@d564 1
a564 1
#if defined(TC_VULNERABLE_VP) /* { */
@


1.33
log
@In vulnerable mode, DON'T initialize tags for argv/envp.
@
text
@d104 1
a104 1
      exit((_output_error("_touchMirrorPage/FATAL: memalign out of memory"),-1));
a215 21

void _output_error(const char * msg)
{
  if(tc_flag_logfile){
    FILE * lf;
    if((lf = fopen(tc_flag_logfile, "a"))){
      time_t now;
      char * tstr;
      time(&now);
      tstr = ctime(&now);
      fprintf(lf, "%s: %s\n", tstr, msg);
      fclose(lf);
    } else {
      fprintf(stderr, "TC Log Failed; msg=%s\n", msg);
    }
  } else if(streams[_tc_error]){
    fprintf(streams[_tc_error], "%s\n", msg);
    TCKILL;
  }
  if(!tc_dont_die) exit(-1);
}
@


1.32
log
@Added TC_VULNERABLE_VP stuff: changing behavior of
_verifyPtr().
@
text
@d1199 1
d1219 1
d1221 1
d1243 1
@


1.31
log
@Minor fixes as detected by -Wall compilation.
@
text
@d492 6
d544 1
a544 1
    if(GET_TAG_BYTE(addr) == 0xff)
d548 4
d554 1
a554 1

d570 5
d578 1
d584 2
a585 1
      /* mhash optimization */
d594 1
d598 6
d607 3
a609 1
        } else {
d611 1
a611 1
            if(*head_byte != 0xff){
d624 6
d633 3
a635 1
        } else {
d648 1
a648 1
              if(*head_byte != 0xff){
d660 1
a660 1
            if(*head_byte != 0xff){
d670 1
@


1.30
log
@Added -tc-info flag, to just output stats w/o
running main (intended purpose, to dump static counts).
@
text
@d551 1
a551 1
    unsigned char maskback = (0xffu >> TAGS_PER_BYTE-MOD_TAGS_PER_BYTE(eaddr));
d659 1
a659 1
    unsigned char maskback = (0xffu >> TAGS_PER_BYTE-MOD_TAGS_PER_BYTE(eaddr));
d737 1
a737 1
    unsigned char maskback = (0xffu >> TAGS_PER_BYTE-MOD_TAGS_PER_BYTE(eaddr));
d1089 1
a1089 1
          fprintf(lf, "\n", tstr);
@


1.29
log
@Set defailt hashopt threshhold to 64.
@
text
@d1026 1
d1061 1
d1205 2
@


1.28
log
@Added debug histogram output for tcmalloc-hash
statistics (guarded by TC_PRINT_STAT, only runs
when building -g).
Also, malloc hash table size is now 16381 (may revert
back to smaller number depending on SPEC behavior)
@
text
@d65 1
a65 1
int tc_flag_hashopt_threshhold = 0; /* hash optimization lookup threshhold */
@


1.27
log
@Added "hashopt": optimize verifyPtr to lookup in the malloc
hash table when lookup size is greater than hashopt thresh-
hold (default 0; can set with -tc-hashopt=N).
@
text
@d9 1
a9 1
#include "tcmalloc-hash.h" /* for mhash_getsize optimization */
d17 1
d903 2
@


1.26
log
@Added linking with tcptrhisto.c (diagnostic histogram
of instrumented calls).
@
text
@d9 1
d64 2
d147 2
d174 2
d567 10
d1057 4
a1060 1
      else if(!strncmp(argv[i]+4,"clear=",6)){
@


1.25
log
@Fixed diagnostic output bug: long long output needed %llu
not %lu
@
text
@d881 7
@


1.24
log
@Added skip-vp, skip-st, skip-ct flags
(useful for diagnosing slowdowns?)
NOTE: this probably slows down overhead by
a small bit -- negligible?
@
text
@d971 3
a973 2
    for(i = 0; i < sc_max; ++i)
      fprintf(statstream, "Dynamic %s = %lu\n", statdesc[i], statcounter[i]);
@


1.23
log
@Fixed bug in TC_STAT_COUNT_KB_ADD
@
text
@d65 4
d484 2
d487 21
a507 8
  struct flc_count_node * np;
  for(np = vp_callers; np; np = np->next){
    if(np->file == file &&
	np->line == line &&
	np->col == col){
      np->ncalls++;
      np->nbytes += size;
      break;
a509 11
  if(!np){
    np = (struct flc_count_node *) malloc(sizeof(struct flc_count_node));
    np->file = file;
    np->line = line;
    np->col = col;
    np->exp = exp;
    np->ncalls = 1;
    np->nbytes = size;
    np->next = vp_callers;
    vp_callers = np;
  }
d622 2
d700 2
d1026 3
@


1.22
log
@Change 1: update vp/st/ct counters to count in KBs rather
	bytes, as it was overflowing on some benchmarks.
Change 2: Added LOG_VP_CALLERS diagnostic histogram code
	(#define-able).
@
text
@d36 6
a41 3
#define TC_STAT_COUNT_KB_ADD(x,i) do {	static int tmp = -511;	\
					if(++tmp % 1024 == 0)	\
					  statcounter[x] += i;	\
@


1.21
log
@Added STATIC_MIRROR implementation.
@
text
@d20 2
d36 4
a39 1
#define TC_STAT_COUNT_ADD(x,i) (statcounter[x] += i)
d42 1
a42 1
#define TC_STAT_COUNT_ADD(x,i)
d147 1
a147 1
  sc_count_vp_bytes,
d149 1
a149 1
  sc_count_st_bytes,
d151 1
a151 1
  sc_count_ct_bytes,
d171 1
a171 1
  "count_vp_bytes",
d173 1
a173 1
  "count_st_bytes",
d175 1
a175 1
  "count_ct_bytes",
d464 10
d477 24
d502 1
a502 1
  TC_STAT_COUNT_ADD(sc_count_vp_bytes, size);
d612 1
a612 1
  TC_STAT_COUNT_ADD(sc_count_st_bytes, size);
d688 1
a688 1
  TC_STAT_COUNT_ADD(sc_count_ct_bytes, size);
d865 11
@


1.20
log
@Augmented timer output to use also gettimeofday to
compute "real" time (previously was only using
getrusage to get user/sys time).
@
text
@d60 12
d96 2
d184 1
d192 1
d377 1
d427 1
d526 1
d564 1
d612 1
d639 1
d688 1
d715 1
@


1.19
log
@Added min/maj pagefault output from getrusage.
Also wrote code to output linux /proc/self/stat
numbers, but commented it out because the number
I wanted (nswap) is not available.
@
text
@d5 1
d27 1
d422 2
a423 1
static void printdelta(FILE * s, struct rusage * r1, struct rusage * r2)
d430 2
a431 1
  fprintf(s, "%.3f u, %.3f s\n",
d804 1
d808 1
a808 1
    printdelta(statstream, &ru0, &ru5);
d811 1
a811 1
    printdelta(statstream, &ru1, &ru2);
d814 1
a814 1
    printdelta(statstream, &ru2, &ru3);
d817 1
a817 1
    printdelta(statstream, &ru4, &ru5);
d915 1
d1031 1
d1034 1
d1037 1
d1082 1
@


1.18
log
@Added -tc-no-argv -tc-no-envp flags, to disable
initialization of those locations.
@
text
@d15 1
d813 58
a879 1

@


1.17
log
@1. Changed handling of argvs -- old version still leaves
   old "-tc-..." stuff on the argv array; new version
   compacts the remaining argvs -- more compliant with
   C specs?
2. Added debug stat counter for number of argc/envp
   bytes instrumented.
@
text
@d844 2
d874 2
d960 1
a961 1
      i--; /* decrement to process next item */
d972 1
a972 2
  {
    int count_argc = 0;
a973 2
    int count_envp = 0;
    int count_envp_bytes = 0;
d981 1
a981 1
    count_argc = i;
d985 11
d1009 1
a1009 2
      fprintf(streams[_tc_stat] , "Arg/Env: %d argvs, %d bytes; %d envps, %d bytes\n"
				, argc, count_argv_bytes, count_envp, count_envp_bytes);
@


1.16
log
@Added counters to count vp/st/ct counts and bytes
(dynamic counters).
@
text
@d843 1
d846 3
d936 2
d939 17
a955 4
        int j;
        for(j = i+1; j < argc; ++j) argv[j-1] = argv[j];
        argv[--argc] = 0;
        i--;
d957 1
d968 14
a981 2
  /* initialize argv */
  for(i = 0; i < argc; ++i){
a982 4
    _tcptr_setTags(argv[i],strlen(argv[i])+1);
  }
  /* (terminating null pointer) */
  _tcptr_setTags(&argv[i],sizeof(char *));
d984 9
a992 2
  /* initialize envp */
  for(i = 0; envp[i]; ++i){
d994 7
a1000 1
    _tcptr_setTags(envp[i],strlen(envp[i])+1);
a1001 2
  /* (terminating null pointer) */
  _tcptr_setTags(&envp[i],sizeof(char *));
@


1.15
log
@Added -tc-dont-die flag.
@
text
@d31 1
d34 1
d123 7
d148 6
d155 1
a155 1
unsigned long statcounter[sc_max] = {0};
d439 3
d547 3
d621 3
@


1.14
log
@Added counter to count dynamic verifyPtr calls to
array-index expressions (anything ending with ']').
@
text
@d161 2
d181 1
d246 9
a254 1
          return;
a255 8
        e->file = file;
        e->line = line;
        e->col = col;
        e->exp = exp;
        e->count = 1;
        e->next = 0;
        *msg_tail = e;
        msg_tail = &e->next;
d265 1
d843 1
@


1.13
log
@Small change to be std-C compliant.
@
text
@d107 1
d125 1
d420 7
@


1.12
log
@Added primitive tc-logfile= option.
The primitive part is that if -tc-summarize is on,
it'll still log the date for each occurrence.
@
text
@d843 1
a844 1
        FILE * lf;
@


1.11
log
@Added handling of envp argument (third argument to main).
@
text
@d5 1
d50 2
d161 13
a173 1
  if(streams[_tc_error]){
d218 14
a231 1
  if(streams[_tc_error]){
d237 1
a237 1
        fprintf(streams[_tc_error], "[%s:%d.%d](%s) %s\n", file, line, col, exp, msg);
d240 1
a240 1
          _output_error("_output_flce: malloc out of memory");
d253 1
a253 1
      fprintf(streams[_tc_error], "[%s:%d.%d](%s) %s\n", file, line, col, exp, msg);
d256 3
d842 19
@


1.10
log
@Changed output mechanism for static counts to allow for
arbitrary reported values (rather than hard-coding a fixed
set of items to count)
@
text
@d771 1
a771 1
int main(int argc, char * argv[])
d774 1
a774 1
  extern int _prog_main(int argc, char * argv[]);
d868 8
d877 1
a877 1
  return _prog_main(argc, argv);
@


1.9
log
@renamed reportNumCalls to reportStaticCounts, taking an extra
parameter describing the count.
currently, only tcptr.c collects the count correctly.
@
text
@a102 3
  sc_static_tot_inst,	/* static number of instrumentation calls */
  sc_static_vp_inst,	/* static number of verifyPtrs instrumented */
  sc_static_vp_elided,	/* static number of verifyPtrs elided */
a119 3
  "static_tot_inst",
  "static_vp_inst",
  "static_vp_elided",
d137 6
d234 12
a245 6
  if(!strcmp(descr,"tot_inst")){
    statcounter[sc_static_tot_inst] += count;
  } else if(!strcmp(descr,"vp_inst")){
    statcounter[sc_static_vp_inst] += count;
  } else if(!strcmp(descr,"vp_elided")){
    statcounter[sc_static_vp_elided] += count;
d751 7
a757 1
      fprintf(statstream, "%s = %lu\n", statdesc[i], statcounter[i]);
@


1.8
log
@MAJOR BUG FIX: setTag, clearTag, and verifyPtr were buggy!
Fixed, and included more systematic tests in -DSTANDALONE
code.
@
text
@d15 1
a15 1
#define TC_PRINT_STATS
d28 6
d100 2
d103 3
a105 1
  sc_num_static_calls,	/* number of static instrumentation calls */
d123 3
a125 1
  "num_static_calls",
d143 2
d231 1
a231 1
void _reportNumCalls(const char * fname, int num_calls)
d233 9
a241 1
  statcounter[sc_num_static_calls] += num_calls;
d386 1
a386 1
    statcounter[sc_vp_onebyte]++;
d388 4
a391 2
    if(streams[_tc_stat] && GET_TAG_BYTE(addr) == 0xff)
      statcounter[sc_debug_vp_onebyte_ff]++;
d409 1
a409 1
      statcounter[sc_vp_twobytes]++;
d417 1
a417 1
      statcounter[sc_vp_multibytes]++;
d436 1
a436 1
        statcounter[sc_vp_multipage]++;
d484 1
a484 1
    statcounter[sc_st_onebyte]++;
d500 1
a500 1
      statcounter[sc_st_twobytes]++;
d507 1
a507 1
      statcounter[sc_st_multibytes]++;
d519 1
a519 1
        statcounter[sc_st_multipage]++;
d555 1
a555 1
    statcounter[sc_ct_onebyte]++;
d571 1
a571 1
      statcounter[sc_ct_twobytes]++;
d578 1
a578 1
      statcounter[sc_ct_multibytes]++;
d590 1
a590 1
        statcounter[sc_ct_multipage]++;
d627 1
a627 1
  statcounter[sc_pr_calls] ++;
@


1.7
log
@Fixed error count initialization from 0 to 1.
@
text
@d359 1
a359 8
  const char * saddr = (const char *) addr;
  const char * eaddr = saddr + size;
  unsigned char maskfront = (0xff << MOD_TAGS_PER_BYTE(saddr));
  unsigned char maskback = (0xffu >> MOD_TAGS_PER_BYTE(TAGS_PER_BYTE-MOD_TAGS_PER_BYTE(eaddr)));

  if(size <= TAGS_PER_BYTE){
    if(MOD_TAGS_PER_BYTE(saddr) <= TAGS_PER_BYTE - size){
      unsigned char mask = maskfront&maskback;
d361 1
a361 2
      /* tag is all in one byte */
      statcounter[sc_vp_onebyte]++;
d363 2
a364 2
      if(streams[_tc_stat] && GET_TAG_BYTE(addr) == 0xff)
        statcounter[sc_debug_vp_onebyte_ff]++;
d366 19
a384 4
      if((mask & GET_TAG_BYTE(addr)) != mask)
        _output_flce(file,line,col,exp, "VerifyPtr failed (case 1)");
    } else {
      /* tag is split across two bytes */
a389 2
    }
  } else {
d391 1
a391 2
    const unsigned char * head_byte = &GET_TAG_BYTE(saddr);
    const unsigned char * tail_byte = &GET_TAG_BYTE(eaddr);
d393 1
a393 1
    statcounter[sc_vp_multibytes]++;
d395 1
a395 1
    if(SAME_MIRROR_PAGE(saddr, eaddr)){
d397 9
a405 8
      if((maskfront & *head_byte) != maskfront ||
         (maskback  & *tail_byte) != maskback){
        _output_flce(file,line,col,exp, "VerifyPtr failed (case 3a)");
      } else {
        for(head_byte++; head_byte != tail_byte; ++head_byte){
          if(*head_byte != 0xff){
            _output_flce(file,line,col,exp, "VerifyPtr failed (case 3b)");
            break;
a407 2
      }
    } else {
a408 1
      statcounter[sc_vp_multipage]++;
a409 3
      if((maskfront & *head_byte) != maskfront ||
         (maskback  & *tail_byte) != maskback){
        _output_flce(file,line,col,exp, "VerifyPtr failed (case 3c)");
d412 16
a427 1
        const char * nbaddr = saddr;
d429 6
a434 1
        head_byte++;
d436 2
a437 2
        do {
          const unsigned char * nb_byte;
d439 1
a439 2
          nbaddr = (const char *)((unsigned long)nbaddr | MIRRORPAGE_MASK);
          nb_byte = &GET_TAG_BYTE(nbaddr) + 1; /* add one (test condition) */
d441 1
a441 1
          for(; head_byte != nb_byte; ++head_byte){
d443 1
a443 1
              _output_flce(file,line,col,exp, "VerifyPtr failed (case 3d)");
a446 9
          nbaddr++;
          head_byte = &GET_TAG_BYTE(nbaddr);
        } while(!SAME_MIRROR_PAGE(nbaddr, eaddr));

        for(; head_byte != tail_byte; ++head_byte){
          if(*head_byte != 0xff){
            _output_flce(file,line,col,exp, "VerifyPtr failed (case 3e)");
            return;
          }
d455 3
a457 14
  const char * saddr = (const char *) addr;
  const char * eaddr = saddr + size;
  unsigned char maskfront = (0xff << MOD_TAGS_PER_BYTE(saddr));
  unsigned char maskback = (0xffu >> MOD_TAGS_PER_BYTE(TAGS_PER_BYTE-MOD_TAGS_PER_BYTE(eaddr)));

  if(size <= TAGS_PER_BYTE){
    if(MOD_TAGS_PER_BYTE(saddr) <= TAGS_PER_BYTE - size){

      unsigned char mask = maskfront&maskback;
/* alternative formulation, for single-byte case only:
      unsigned char mask = ((~(0xffu << (size))) << MOD_TAGS_PER_BYTE(addr));
*/
      /* tag is all in one byte */
      statcounter[sc_st_onebyte]++;
d459 2
a460 1
      GET_TAG_BYTE(addr) |= mask;
d462 1
a462 3
    } else {
      /* tag is split across two bytes */
      statcounter[sc_st_twobytes]++;
a463 3
      GET_TAG_BYTE(saddr) |= maskfront;
      GET_TAG_BYTE(eaddr) |= maskback;
    }
d466 4
d473 1
a473 1
    statcounter[sc_st_multibytes]++;
d475 2
a476 1
    if(SAME_MIRROR_PAGE(saddr, eaddr)){
a478 1
      memset(head_byte, 0xff, tail_byte - head_byte);
d483 1
a483 1
      const char * nbaddr = saddr;
d485 1
a485 1
      statcounter[sc_st_multipage]++;
d487 9
a495 1
      *head_byte |= maskfront;
d497 1
a497 1
      head_byte++;
d499 1
a499 1
      do {
d501 3
a503 1
        const unsigned char * nb_byte;
d505 2
a506 2
        nbaddr = (const char *)((unsigned long)nbaddr | MIRRORPAGE_MASK);
        nb_byte = &GET_TAG_BYTE(nbaddr) + 1;
d508 1
a508 1
        memset(head_byte, 0xff, nb_byte - head_byte);
d510 2
a511 2
        nbaddr++;
        head_byte = &GET_TAG_BYTE(nbaddr);
d513 1
a513 1
      } while(!SAME_MIRROR_PAGE(nbaddr, eaddr));
d515 1
a515 1
      memset(head_byte, 0xff, tail_byte - head_byte);
d517 2
a518 1
      *tail_byte |= maskback;
d526 1
a526 8
  const char * saddr = (const char *) addr;
  const char * eaddr = saddr + size;
  unsigned char maskfront = (0xff << MOD_TAGS_PER_BYTE(saddr));
  unsigned char maskback = (0xffu >> MOD_TAGS_PER_BYTE(TAGS_PER_BYTE-MOD_TAGS_PER_BYTE(eaddr)));

  if(size <= TAGS_PER_BYTE){
    if(MOD_TAGS_PER_BYTE(saddr) <= TAGS_PER_BYTE - size){
      unsigned char mask = maskfront&maskback;
d528 1
a528 2
      /* tag is all in one byte */
      statcounter[sc_ct_onebyte]++;
d530 2
a531 1
      GET_TAG_BYTE(addr) &= ~mask;
d533 1
a533 3
    } else {
      /* tag is split across two bytes */
      statcounter[sc_ct_twobytes]++;
a534 3
      GET_TAG_BYTE(saddr) &= ~maskfront;
      GET_TAG_BYTE(eaddr) &= ~maskback;
    }
d537 4
d544 1
a544 1
    statcounter[sc_ct_multibytes]++;
d546 2
a547 1
    if(SAME_MIRROR_PAGE(saddr, eaddr)){
a549 1
      memset(head_byte, 0x00, tail_byte - head_byte);
d554 1
a554 1
      const char * nbaddr = saddr;
d556 1
a556 1
      statcounter[sc_ct_multipage]++;
d558 3
a560 1
      *head_byte &= ~maskfront;
d562 1
a562 1
      head_byte++;
d564 1
a564 1
      do {
d566 1
a566 1
        const unsigned char * nb_byte;
d568 3
a570 2
        nbaddr = (const char *)((unsigned long)nbaddr | MIRRORPAGE_MASK);
        nb_byte = &GET_TAG_BYTE(nbaddr) + 1;
d572 1
a572 1
        memset(head_byte, 0x00, nb_byte - head_byte);
d574 1
a574 2
        nbaddr++;
        head_byte = &GET_TAG_BYTE(nbaddr);
d576 2
a577 1
      } while(!SAME_MIRROR_PAGE(nbaddr, eaddr));
d579 1
a579 1
      memset(head_byte, 0x00, tail_byte - head_byte);
d581 9
a589 1
      *tail_byte &= ~maskback;
d852 100
a951 51
/**********************************/
/* SINGLE BYTE */
fprintf(stderr, "------single byte\n");
/**********************************/

  _tcptr_setTags((const char *)0x09, 4);
  _printTagStderr((const char *)0x09,4);
  _printTagStderr((const char *)0x09,6);
  _tcptr_clearTags((const char *)0x09, 4);
  _printTagStderr((const char *)0x09,6);

fprintf(stderr, "- 01\n"); _tcptr_verifyPtr("",0,0,"",(const char *)0x00, 1);
fprintf(stderr, "- 91\n"); _tcptr_verifyPtr("",0,0,"",(const char *)0x09, 1);
fprintf(stderr, "- 94\n"); _tcptr_verifyPtr("",0,0,"",(const char *)0x09, 4);
fprintf(stderr, "- 95\n"); _tcptr_verifyPtr("",0,0,"",(const char *)0x09, 5);
fprintf(stderr, "- a3\n"); _tcptr_verifyPtr("",0,0,"",(const char *)0x0a, 3);
fprintf(stderr, "- a4\n"); _tcptr_verifyPtr("",0,0,"",(const char *)0x0a, 4);

  _tcptr_setTags((const char *)0x17, 2);
  _tcptr_setTags((const char *)0x1a, 2);
  _printTagStderr((const char *)0x16,160);

/**********************************/
/* TWO BYTES */
fprintf(stderr, "------two bytes\n");
/**********************************/
  _tcptr_setTags((const char *)0x123ffffe, 4);
  _tcptr_setTags((const char *)0x12400004, 5);
  _printTagStderr((const char *)0x123fffff,30);

fprintf(stderr, "- d1\n"); _tcptr_verifyPtr("",0,0,"",(const char *)0x123ffffd, 1);
fprintf(stderr, "- e1\n"); _tcptr_verifyPtr("",0,0,"",(const char *)0x123ffffe, 1);
fprintf(stderr, "- e2\n"); _tcptr_verifyPtr("",0,0,"",(const char *)0x123ffffe, 2);
fprintf(stderr, "- e3\n"); _tcptr_verifyPtr("",0,0,"",(const char *)0x123ffffe, 3);
fprintf(stderr, "- e4\n"); _tcptr_verifyPtr("",0,0,"",(const char *)0x123ffffe, 4);
fprintf(stderr, "- e5\n"); _tcptr_verifyPtr("",0,0,"",(const char *)0x123ffffe, 5);

fprintf(stderr, "- e11\n"); _tcptr_verifyPtr("",0,0,"",(const char *)0x123ffffe, 11);

/**********************************/
/* MULTI BYTES */
fprintf(stderr, "------multi bytes\n");
/**********************************/
  _tcptr_setTags((const char *)0x071ffffe, 12);
  _printTagStderr((const char *)0x071fffff,30);

fprintf(stderr, "- d1\n"); _tcptr_verifyPtr("",0,0,"",(const char *)0x071ffffd, 1);
fprintf(stderr, "- e1\n"); _tcptr_verifyPtr("",0,0,"",(const char *)0x071ffffe, 1);
fprintf(stderr, "- e5\n"); _tcptr_verifyPtr("",0,0,"",(const char *)0x071ffffe, 5);
fprintf(stderr, "- e12\n"); _tcptr_verifyPtr("",0,0,"",(const char *)0x071ffffe, 12);
fprintf(stderr, "- e13\n"); _tcptr_verifyPtr("",0,0,"",(const char *)0x071ffffe, 13);
@


1.6
log
@Minor changes; added new debug_vp_onebyte_ff counter,
and wrote alternative formulation of verifyPtr mask
(commented out)
@
text
@d205 1
a205 1
        e->count = 0;
@


1.5
log
@Reintroduced file,line,col,exp arguments to _tcptr_verifyPtr
Wrote tc-summarize mechanism
FIXED bug with operator precedence (a & b != c && d & e != f)
@
text
@d96 1
a96 1
  sc_num_dynamic_calls,	/* number of static instrumentation calls */
d98 1
d114 1
a114 1
  "num_dynamic_calls",
d116 1
d371 3
d453 1
d455 3
a457 1

d591 1
a591 1
  statcounter[sc_num_dynamic_calls] ++;
@


1.4
log
@Wrote processReturn, which should round up the necessary
instrumentation (not counting libc).
@
text
@d142 1
a142 1
  if(streams[_tc_error])
d144 69
d354 2
a355 1
void _tcptr_verifyPtr(const void * addr, size_t size)
d370 1
a370 1
        _output_error("VerifyPtr failed (case 1)");
d377 1
a377 1
        _output_error("VerifyPtr failed (case 2)");
d388 3
a390 3
      if(maskfront & *head_byte != maskfront ||
         maskback  & *tail_byte != maskback){
        _output_error("VerifyPtr failed (case 3a)");
d394 1
a394 1
            _output_error("VerifyPtr failed (case 3b)");
d403 3
a405 3
      if(maskfront & *head_byte != maskfront ||
         maskback  & *tail_byte != maskback){
        _output_error("VerifyPtr failed (case 3c)");
d420 1
a420 1
              _output_error("VerifyPtr failed (case 3d)");
d430 1
a430 1
            _output_error("VerifyPtr failed (case 3e)");
d704 5
d742 2
a743 1
      } else if(!strncmp(argv[i]+4,"clear=",6)){
a767 11
	} else {
	  fname++;
	  if(!strcmp(fname,"")){
	    streams[stream_id] = 0;
	    fprintf(stderr, "TC: Disabling stream (%s)\n", stream_id_str);
	  } else if(!strcmp(fname,"-")){
	    streams[stream_id] = stdout;
	    fprintf(stderr, "TC: Setting stream to stdout (%s)\n", stream_id_str);
	  } else if(!strcmp(fname,"=")){
	    streams[stream_id] = stderr;
	    fprintf(stderr, "TC: Setting stream to stderr (%s)\n", stream_id_str);
d769 16
a784 4
	    if((streams[stream_id] = fopen(fname, "w")))
	      fprintf(stderr, "TC: Redirecting stream to file %s (%s)\n", fname, stream_id_str);
	    else
	      fprintf(stderr, "TC: Error opening file %s for output (%s)\n", fname, stream_id_str);
d843 6
a848 6
fprintf(stderr, "- 01\n"); _tcptr_verifyPtr((const char *)0x00, 1);
fprintf(stderr, "- 91\n"); _tcptr_verifyPtr((const char *)0x09, 1);
fprintf(stderr, "- 94\n"); _tcptr_verifyPtr((const char *)0x09, 4);
fprintf(stderr, "- 95\n"); _tcptr_verifyPtr((const char *)0x09, 5);
fprintf(stderr, "- a3\n"); _tcptr_verifyPtr((const char *)0x0a, 3);
fprintf(stderr, "- a4\n"); _tcptr_verifyPtr((const char *)0x0a, 4);
d862 6
a867 6
fprintf(stderr, "- d1\n"); _tcptr_verifyPtr((const char *)0x123ffffd, 1);
fprintf(stderr, "- e1\n"); _tcptr_verifyPtr((const char *)0x123ffffe, 1);
fprintf(stderr, "- e2\n"); _tcptr_verifyPtr((const char *)0x123ffffe, 2);
fprintf(stderr, "- e3\n"); _tcptr_verifyPtr((const char *)0x123ffffe, 3);
fprintf(stderr, "- e4\n"); _tcptr_verifyPtr((const char *)0x123ffffe, 4);
fprintf(stderr, "- e5\n"); _tcptr_verifyPtr((const char *)0x123ffffe, 5);
d869 1
a869 1
fprintf(stderr, "- e11\n"); _tcptr_verifyPtr((const char *)0x123ffffe, 11);
d878 5
a882 5
fprintf(stderr, "- d1\n"); _tcptr_verifyPtr((const char *)0x071ffffd, 1);
fprintf(stderr, "- e1\n"); _tcptr_verifyPtr((const char *)0x071ffffe, 1);
fprintf(stderr, "- e5\n"); _tcptr_verifyPtr((const char *)0x071ffffe, 5);
fprintf(stderr, "- e12\n"); _tcptr_verifyPtr((const char *)0x071ffffe, 12);
fprintf(stderr, "- e13\n"); _tcptr_verifyPtr((const char *)0x071ffffe, 13);
@


1.3
log
@Wrote _printTags, _tcptr_setTags and _tcptr_clearTags;
also, STANDALONE main function to test these functionalities.
@
text
@d96 1
d113 1
d127 12
a138 1
int statcounter[sc_max] = {0};
d298 1
a298 5
/*
fprintf(stderr, "mask="); _printBinary(stderr, mask);
fprintf(stderr, "; byte="); _printBinary(stderr, GET_TAG_BYTE(addr));
fprintf(stderr, "\n");
*/
d504 3
a506 1
void _tcptr_processReturn(void * scaf_start, void * scaf_end, void * agrf_start, void * agrf_end)
d508 84
d595 3
a597 1
/* SETUP */
d631 1
a631 1
      fprintf(statstream, "%s = %d\n", statdesc[i], statcounter[i]);
d741 3
a811 2133


#if 0 /* { */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/resource.h> /* for getrusage timing stuff */

#define TC_DEFINE_MSGS
#include "tcinternal.h"
#undef TC_DEFINE_MSGS

/******************/
/* Run time flags */
/******************/

/* turn on/off sending of signal on error/warning */
static int signalflags[_tc_numstreams] = {0};

int tc_flag_summarize = 0; /* "summarize" errors and warnings, by line number,
				at end of execution; may not print on crash */

int tc_flag_terse = 0; /* "terse" output of errors and warnings */

int tc_flag_trackfree = 0; /* keep track of free'd memory for diagnostic lookup */

#define _TC_NONE	0
#define _TC_SEGS_ONLY	1
#define _TC_TO_SCALAR	2
#define _TC_TO_AGGR	3
#define _TC_TO_HIGHEST	4
int tc_flag_clear = _TC_SEGS_ONLY; /* on function return, different modes of
				      clearing the stack frame w.r.t. formals */

/*********************************/
/* Instrumentation Call counters */
/*********************************/
static unsigned long tot_static_num_calls = 0;
static unsigned long tot_dynamic_num_calls = 0;
static unsigned long tot_dynamic_num_calls_overflow = 0;

/****************************/
/* Macro statistic counters */
/****************************/
int  _vpctr = 0, _vpcctr = 0, _vpactr = 0, /* verifyPtr */
    _vpfctr = 0,_vpcfctr = 0,_vpafctr = 0;
int  _vtctr = 0, _vtcctr = 0, _vtactr = 0, /* verifyTag */
    _vtfctr = 0,_vtcfctr = 0,_vtafctr = 0;
int  _ctctr = 0, _ctcctr = 0, _ctactr = 0, /* copyTag */
    _ctfctr = 0,_ctcfctr = 0,_ctafctr = 0;
int  _sstctr = 0, _sstcctr = 0, /* setScalarTag */
    _sstfctr = 0,_sstcfctr = 0;
int  _ssutctr = 0, _ssutcctr = 0, /* setScalarUninitTag */
    _ssutfctr = 0,_ssutcfctr = 0;
int _patctr = 0, _patactr = 0, _patpctr = 0, /* processArgTag */
    _patfctr = 0,_patafctr = 0;

/**********************/
/* Compile time flags */
/**********************/
/* the values for these are or-ed by the initialization functions
   from the instrumented output. Each file in a given compilation
   should have used the same flags; otherwise the behavior can be
   a bit odd. */

int strictPointer = 0;

/********************************/
/* Paged mirror data structures */
/********************************/

/* the mirrormap lookup table */
void * mirrormap[MIRRORMAP_NUMELEMENTS] = {_typetag_unalloc};

/* for now, freelist assumes tags-per-byte ratio is 2.
   - to be more general introduces unnecessary complications? */
void * mirrormap_freelist = 0;

/******************/
/* Auxiliary data */
/******************/

const char * _typeDesc[] = {"UNA", "UNI", "INT",
                            "FLT", "PTR", "INI", "BIT"};

/******************************/
/* "private" API data members */
/******************************/

/* typechecker output streams */
/* these are initialized in main() */
static FILE * streams[_tc_numstreams] = {0};

/********************/
/* API data members */
/********************/
char _ini_static_rep[64];

int _int_static_rep[2];
char _char_static_rep[2];
short _short_static_rep[2];
long _long_static_rep[2];
long long _longlong_static_rep[2];
float _float_static_rep[2];
double _double_static_rep[2];
#ifdef LONGDOUBLE
long double _longdouble_static_rep[2];
#endif /* LONGDOUBLE */
void * _pointer_static_rep[2];

_addr_and_size_t * _globalArgAddrs = 0;
int _globalArgCount = 0;
void * _globalCallTarget = 0;
void * _dummyAddr;
char * _globalErrlocFile = "<none>";
int _globalErrlocLine = 0, _globalErrlocCol = 0;

/* for bitfields */
long long _dummyInt;

/***********/
/* Globals */
/***********/
int _tc_init_mode = 0; /* set to true when initializing globals, and to false when program starts */

/***********************/
/* More auxiliary data */
/***********************/

_typeinfo_t typeinfo[] = {

/* note: ordering must coincide with enum _ctype
	 (which will be used to index into this table) */

  { 0, _typetag_unalloc, 0, 0, 0, _ctype_void_invalid, "void" },
  { &_int_static_rep[0], _typetag_int, sizeof(int), 0, 0,
						_ctype_int, "int" },
  { &_char_static_rep[0], _typetag_int, sizeof(char), 0, 0,
						_ctype_int, "char" },
  { &_short_static_rep[0], _typetag_int, sizeof(short), 0, 0,
						_ctype_int, "short" },
  { &_long_static_rep[0], _typetag_int, sizeof(long), 0, 0,
						_ctype_long, "long" },
  { &_longlong_static_rep[0], _typetag_int, sizeof(long long), 0, 0,
						_ctype_longlong, "long long" },
  { &_float_static_rep[0], _typetag_float, sizeof(float), 0, 0,
						_ctype_double, "float" },
  { &_double_static_rep[0], _typetag_float, sizeof(double), 0, 0,
						_ctype_double, "double" },
#ifdef LONGDOUBLE
  { &_longdouble_static_rep[0], _typetag_float, sizeof(long double), 0, 0,
					_ctype_longdouble, "long double" },
#else /* !LONGDOUBLE */
  /* This preserves correspondence between this table and enum ctype_t */
  { 0, _typetag_float, sizeof(long double), 0, 0,
					_ctype_void_invalid, "long double" },
#endif /* !LONGDOUBLE */
  { &_pointer_static_rep[0], _typetag_ptr, sizeof(void *), 0, 0,
						_ctype_pointer, "pointer" },
  { 0, _typetag_unalloc, 0, 0, 0, _ctype_aggregate, "aggregate" }
};


/*************************/
/* register extern stuff */
/*************************/

struct fnCallNode {
  enum { setUninitTag, setScalarTag, replicateTag } function;
  union {
    struct { const char * fname; int line; int col;
             void * addr; size_t size; } sut;
    struct { const char * fname; int line; int col;
             const void * addr; _ctype_t type; } sst;
    struct { const char * fname; int line; int col;
             void * addr; size_t size; int nelem; } rt;
  } args;
  struct fnCallNode * next;
} * externInitFns = 0,
 ** externInitFnsIter = &externInitFns;

struct externVarNode {
  /*--errloc--*/
  const char * fname;
  int line;
  int col;

  /*--variable info--*/
  const char * varname;  /* NOTE: not currently used */
  void * addr;
  _ctype_t type;
  struct fnCallNode * initfns;

  /*--next--*/
  struct externVarNode * next;
} * externVarList = 0;

/**********************************/
/* Auxiliary function definitions */
/**********************************/

/* executes the initialization functions encoded in list */
/* also, free memory used up by list */
static void executeFnCalls(struct fnCallNode * list)
{
  struct fnCallNode * iter = list;
  while(iter){
    struct fnCallNode * temp;
    switch(iter->function){
      case setUninitTag:
        _setUninitTag(	iter->args.sut.fname,
			iter->args.sut.line,
			iter->args.sut.col,
			iter->args.sut.addr,
			iter->args.sut.size);
        break;
      case setScalarTag:
        _setScalarTag(	iter->args.sst.fname,
			iter->args.sst.line,
			iter->args.sst.col,
			iter->args.sst.addr,
			iter->args.sst.type);
        break;
      case replicateTag:
        _replicateTag(	iter->args.rt.fname,
			iter->args.rt.line,
			iter->args.rt.col,
			iter->args.rt.addr,
			iter->args.rt.size,
			iter->args.rt.nelem);
        break;
    }
    temp = iter;
    iter = iter->next;
    free(temp);
  }
}

/************************************************/
/* GDB-friendly function for setting breakpoint */
/************************************************/

int _brk_msgid = 0;
int _brk_line = 0;

/* call with 0,0 to clear breakpoints */
void _tcSetBreak(int msgid, int line){
  /* remember signal flags */
  static int old_signalflags[_tc_numstreams] = {0};

  if(_brk_msgid == 0 && _brk_line == 0){
    int i;
    for(i = 0; i < _tc_numstreams; ++i){
      old_signalflags[i] = signalflags[i];
      signalflags[i] = 0;
    }
  } else if(msgid == 0 && line == 0){
    int i;
    for(i = 0; i < _tc_numstreams; ++i)
      signalflags[i] = old_signalflags[i];
  }

  /* output informative message */

  fprintf(stderr, "TC: Changing breakpoint from %d:%d to %d:%d\n",
		_brk_msgid, _brk_line, msgid, line);

  if(msgid == 0){
    fprintf(stderr, "\t(clear breakpoints)\n");
  } else if (msgid < MSGS_LAST){
    fprintf(stderr, "\t(%d-%s)\n", msgid, _msgs[msgid].msg);
  } else {
    fprintf(stderr, "\t(%d-invalid message id)\n", msgid);
  }

  /* update breakpoint */

  _brk_msgid = msgid;
  _brk_line  = line;
}

/***********************************************************************/
/* Output manager (more or less centralizes log/warning/error outputs) */
/***********************************************************************/

#ifdef TC_MULTILINE
#define IF_MULTILINE(x) x
#else
#define IF_MULTILINE(x)
#endif

/********************/
/* Output functions */
/********************/

void _print_simple(FILE * stream, int msgid)
{
  if(tc_flag_terse){
    fprintf(stream, "%d\n", msgid);
  } else {
    fprintf(stream, "%d-%s\n", msgid, _msgs[msgid].msg);
  }
}

void _print_flc(FILE * stream, const char * file, int line, int col,
		int msgid)
{
  if(tc_flag_terse){
    fprintf(stream, "%d[%s:%d.%d]\n", msgid, file,line,col);
  } else {
    fprintf(stream, "[%s:%d.%d] %d-%s\n", file, line, col, msgid, _msgs[msgid].msg);
  }
}

void _print_si(FILE * stream, const char * file, int line, int col,
		int msgid,
		const char *s1, const char *s2, const char *s3, const char *s4,
		int i1, int i2, int i3, int i4)
{
  if(tc_flag_terse){
    fprintf(stream, "%d[%s:%d.%d]\n", msgid, file,line,col);
  } else {
    fprintf(stream, "[%s:%d.%d] %d-%s ", file, line, col, msgid, _msgs[msgid].msg);
    switch(_msgs[msgid].sargs){
      case 4:
        IF_MULTILINE(fprintf(stream, "\n "));
        fprintf(stream, "(%s) = (%s:%s:%s:%s)", _msgs[msgid].sdesc,s1,s2,s3,s4);
        break;
      case 3:
        IF_MULTILINE(fprintf(stream, "\n "));
        fprintf(stream, "(%s) = (%s:%s:%s)", _msgs[msgid].sdesc, s1,s2,s3);
        break;
      case 2:
        IF_MULTILINE(fprintf(stream, "\n "));
        fprintf(stream, "(%s) = (%s:%s)", _msgs[msgid].sdesc, s1,s2);
        break;
      case 1:
        IF_MULTILINE(fprintf(stream, "\n "));
        fprintf(stream, "(%s) = (%s)", _msgs[msgid].sdesc, s1);
        break;
    }
    switch(_msgs[msgid].iargs){
      case 4:
        IF_MULTILINE(fprintf(stream, "\n "));
        fprintf(stream, "(%s) = (%i:%i:%i:%i)", _msgs[msgid].idesc,i1,i2,i3,i4);
        break;
      case 3:
        IF_MULTILINE(fprintf(stream, "\n "));
        fprintf(stream, "(%s) = (%i:%i:%i)", _msgs[msgid].idesc, i1,i2,i3);
        break;
      case 2:
        IF_MULTILINE(fprintf(stream, "\n "));
        fprintf(stream, "(%s) = (%i:%i)", _msgs[msgid].idesc, i1,i2);
        break;
      case 1:
        IF_MULTILINE(fprintf(stream, "\n "));
        fprintf(stream, "(%s) = (%i)", _msgs[msgid].idesc, i1);
        break;
    }
    fprintf(stream, "\n");
  }
}

void _print_full(FILE * stream, const char * file, int line, int col,
		int msgid,
		const char *s1,
		int i1, int i2, int i3,
		const void *a1, const void *a2,
		const void *t1, const void *t2, const void *t3)
{
  if(tc_flag_terse){
    fprintf(stream, "%d[%s:%d.%d]\n", msgid, file,line,col);
  } else {
    fprintf(stream, "[%s:%d.%d] %d-%s ", file, line, col, msgid, _msgs[msgid].msg);
    if(_msgs[msgid].sargs){
      IF_MULTILINE(fprintf(stream, "\n "));
      fprintf(stream, "(%s) = (%s)", _msgs[msgid].sdesc, s1);
    }
    switch(_msgs[msgid].iargs){
      case 3:
        IF_MULTILINE(fprintf(stream, "\n "));
        fprintf(stream, "(%s) = (%i:%i:%i)", _msgs[msgid].idesc, i1,i2,i3);
        break;
      case 2:
        IF_MULTILINE(fprintf(stream, "\n "));
        fprintf(stream, "(%s) = (%i:%i)", _msgs[msgid].idesc, i1,i2);
        break;
      case 1:
        IF_MULTILINE(fprintf(stream, "\n "));
        fprintf(stream, "(%s) = (%i)", _msgs[msgid].idesc, i1);
        break;
    }
    switch(_msgs[msgid].aargs){
      case 2:
        IF_MULTILINE(fprintf(stream, "\n "));
        fprintf(stream, "(%s) = (0x%x:0x%x)", _msgs[msgid].adesc, a1,a2);
        break;
      case 1:
        IF_MULTILINE(fprintf(stream, "\n "));
        fprintf(stream, "(%s) = (0x%x)", _msgs[msgid].adesc, a1);
        break;
    }
    if(_msgs[msgid].targs){
      IF_MULTILINE(fprintf(stream, "\n "));
      fprintf(stream, "(%s) = (", _msgs[msgid].tdesc);
      if(_msgs[msgid].targs >= 1){
          _printTag(stream, t1, i1);
      }
      if(_msgs[msgid].targs >= 2){
          fprintf(stream, ")(");
          _printTag(stream, t2, i2);
      }
      if(_msgs[msgid].targs >= 3){
          fprintf(stream, ")(");
          _printTag(stream, t3, i3);
      }
      fprintf(stream, ")");
    }
    fprintf(stream, "\n");
  }
}

/**************************
 * summarize output stuff *
 **************************/

struct msg_entry {
  int msgid;
  int count;
  const char * file;
  int line, col;
  enum { _msg_simple, _msg_flc, _msg_si, _msg_full } mode;
  const char *s1, *s2, *s3, *s4;
  int i1, i2, i3, i4;
  const void *a1, *a2;
  void *t1, *t2, *t3;
  struct msg_entry * hnext; /* "hash next": for msg_store search */
  struct msg_entry * onext; /* "order next": for output ordering */
} * _msg_store[MSGS_LAST] = {0},
  * _msg_head = 0,
 ** _msg_tail = &_msg_head;

/* prints output to stat stream */
/* also frees _msg_entry nodes */
int _print_all_msgs()
{
  FILE * statstream = streams[_tc_stat];
  int msg_count = 0;
  while(_msg_head){
    struct msg_entry * t = _msg_head;
    _msg_head = _msg_head->onext;
    fprintf(statstream, "{%d}%s:", t->count, stream_descr[_msgs[t->msgid].str]);
    msg_count += t->count;
    switch(t->mode){
      case _msg_simple:
          _print_simple(statstream, t->msgid);
          break;
      case _msg_flc:
          _print_flc(statstream, t->file, t->line, t->col, t->msgid);
          break;
      case _msg_si:
          _print_si(statstream, t->file, t->line, t->col, t->msgid,
		t->s1, t->s2, t->s3, t->s4,
		t->i1, t->i2, t->i3, t->i4);
          break;
      case _msg_full:
          _print_full(statstream, t->file, t->line, t->col, t->msgid,
		t->s1, t->i1, t->i2, t->i3,
		t->a1, t->a2, t->t1, t->t2, t->t3);
          break;
    }
    if(t->t3) free(t->t3);
    if(t->t2) free(t->t2);
    if(t->t1) free(t->t1);
    free(t);
  }
  _msg_tail = &_msg_head;
  return msg_count;
}

static struct msg_entry * find(FILE * stream, int msgid, const char * file, int line, int col,
			int i1, int i2, int i3, const void * t1, const void * t2, const void * t3)
{
  struct msg_entry * n;
  int match = 0;

  for(n = _msg_store[msgid]; n; n = n->hnext){
    if(n->line == line && n->col == col &&
	(n->file == file || !strcmp(n->file, file))){
      char tb, ntb;
      switch(_msgs[msgid].targs){
        case 3: tb = GET_TAG_BYTE(t3);
		ntb = GET_TAG_BYTE(n->t3);
		if((i3 == 1)
		    ? (GET_CHAR_TAG(ntb, (unsigned long)(n->t3)&0x1)
			!= GET_CHAR_TAG(tb, (unsigned long)(t3)&0x1))
		    : (ntb != tb)) continue;
        case 2: tb = GET_TAG_BYTE(t2);
		ntb = GET_TAG_BYTE(n->t2);
		if((i2 == 1)
		    ? (GET_CHAR_TAG(ntb, (unsigned long)(n->t2)&0x1)
			!= GET_CHAR_TAG(tb, (unsigned long)(t2)&0x1))
		    : (ntb != tb)) continue;
        case 1: tb = GET_TAG_BYTE(t1);
		ntb = GET_TAG_BYTE(n->t1);
		if((i1 == 1)
		    ? (GET_CHAR_TAG(ntb, (unsigned long)(n->t1)&0x1)
			!= GET_CHAR_TAG(tb, (unsigned long)(t1)&0x1))
		    : (ntb != tb)) continue;
        case 0: return n;
      }
    }
  }
  return 0;
}

/********************/
/* Output functions */
/********************/

void _output_internal_error(const char * context, const char * msg)
{
  FILE * errstr = (streams[_tc_error])?(streams[_tc_error]):(stderr);
  fprintf(errstr, "TC INTERNAL ERROR (%s): %s\n", context, msg);
  fflush(errstr);
}

void _output_simple(int msgid)
{
  FILE * stream = streams[_msgs[msgid].str];
  if(stream){
    if(tc_flag_summarize){
      struct msg_entry * n = find(stream, msgid, 0,0,0, 0,0,0, 0,0,0);
      if(n) n->count ++;
      else {
        /* print first time */
        _print_simple(stream, msgid);
        if(signalflags[_msgs[msgid].str]) TCKILL;
        else if(_brk_msgid == msgid) TCKILL;

        /* add entry to _msg_store */
        n = (struct msg_entry *)malloc(sizeof(struct msg_entry));
        if(!n){
          _output_internal_error("_output_simple", "Malloc out of memory");
          return;
        }
        n->msgid = msgid;
        n->count = 1;
        n->file = 0; n->line = 0; n->col = 0;
        n->mode = _msg_simple;
        n->s1 = 0; n->s2 = 0; n->s3 = 0; n->s4 = 0;
        n->i1 = 0; n->i2 = 0; n->i3 = 0; n->i4 = 0;
        n->a1 = 0; n->a2 = 0; n->t1 = 0; n->t2 = 0; n->t3 = 0;
        n->hnext = _msg_store[msgid];
        _msg_store[msgid] = n;
        n->onext = 0;
        *_msg_tail = n;
        _msg_tail = &n->onext;
      }
    } else {
      _print_simple(stream, msgid);
      if(signalflags[_msgs[msgid].str]) TCKILL;
      else if(_brk_msgid == msgid) TCKILL;
    }
  }
}

void _output_flc(const char * file, int line, int col,
		int msgid)
{
  FILE * stream = streams[_msgs[msgid].str];
  if(stream){
    if(tc_flag_summarize){
      struct msg_entry * n = find(stream, msgid, file,line,col, 0,0,0, 0,0,0);
      if(n) n->count ++;
      else {
        /* print first time */
        _print_flc(stream, file, line, col, msgid);
        if(signalflags[_msgs[msgid].str]) TCKILL;
        else if(_brk_msgid == msgid && _brk_line == line) TCKILL;

        /* add entry to _msg_store */
        n = (struct msg_entry *)malloc(sizeof(struct msg_entry));
        if(!n){
          _output_internal_error("_output_flc", "Malloc out of memory");
          return;
        }
        n->msgid = msgid;
        n->count = 1;
        n->file = file; n->line = line; n->col = col;
        n->mode = _msg_flc;
        n->s1 = 0; n->s2 = 0; n->s3 = 0; n->s4 = 0;
        n->i1 = 0; n->i2 = 0; n->i3 = 0; n->i4 = 0;
        n->a1 = 0; n->a2 = 0; n->t1 = 0; n->t2 = 0; n->t3 = 0;
        n->hnext = _msg_store[msgid];
        _msg_store[msgid] = n;
        n->onext = 0;
        *_msg_tail = n;
        _msg_tail = &n->onext;
      }
    } else {
      _print_flc(stream, file, line, col, msgid);
      if(signalflags[_msgs[msgid].str]) TCKILL;
      else if(_brk_msgid == msgid && _brk_line == line) TCKILL;
    }
  }
}

void _output_si(const char * file, int line, int col,
		int msgid,
		const char *s1, const char *s2, const char *s3, const char *s4,
		int i1, int i2, int i3, int i4)
{
  FILE * stream = streams[_msgs[msgid].str];
  if(stream){
    if(tc_flag_summarize){
      struct msg_entry * n = find(stream, msgid, file,line,col, 0,0,0, 0,0,0);
      if(n) n->count ++;
      else {
        /* print first time */
        _print_si(stream, file, line, col, msgid,
		s1,s2,s3,s4, i1,i2,i3,i4);
        if(signalflags[_msgs[msgid].str]) TCKILL;
        else if(_brk_msgid == msgid && _brk_line == line) TCKILL;

        /* add entry to _msg_store */
        n = (struct msg_entry *)malloc(sizeof(struct msg_entry));
        if(!n){
          _output_internal_error("_output_si", "Malloc out of memory");
          return;
        }
        n->msgid = msgid;
        n->count = 1;
        n->file = file; n->line = line; n->col = col;
        n->mode = _msg_si;
        n->s1 = s1;   n->i1 = i1;
        n->s2 = s2;   n->i2 = i2;
        n->s3 = s3;   n->i3 = i3;
        n->s4 = s4;   n->i4 = i4;
        n->a1 = 0; n->a2 = 0; n->t1 = 0; n->t2 = 0; n->t3 = 0;
        n->hnext = _msg_store[msgid];
        _msg_store[msgid] = n;
        n->onext = 0;
        *_msg_tail = n;
        _msg_tail = &n->onext;
      }
    } else {
      _print_si(stream, file, line, col, msgid,
		s1,s2,s3,s4, i1,i2,i3,i4);
      if(signalflags[_msgs[msgid].str]) TCKILL;
      else if(_brk_msgid == msgid && _brk_line == line) TCKILL;
    }
  }
}

void _output_full(const char * file, int line, int col,
		int msgid,
		const char *s1,
		int i1, int i2, int i3,
		const void *a1, const void *a2,
		const void *t1, const void *t2, const void *t3)
{
  FILE * stream = streams[_msgs[msgid].str];
  if(stream){
    if(tc_flag_summarize){
      struct msg_entry * n = find(stream, msgid, file,line,col, i1,i2,i3, t1,t2,t3);
      if(n) n->count ++;
      else {
        /* print first time */
        _print_full(stream, file, line, col, msgid,
		s1, i1,i2,i3, a1,a2, t1,t2,t3);
        if(signalflags[_msgs[msgid].str]) TCKILL;
        else if(_brk_msgid == msgid && _brk_line == line) TCKILL;

        /* add entry to _msg_store */
        n = (struct msg_entry *)malloc(sizeof(struct msg_entry));
        if(!n){
          _output_internal_error("_output_full", "Malloc out of memory");
          return;
        }
        n->msgid = msgid;
        n->count = 1;
        n->file = file; n->line = line; n->col = col;
        n->mode = _msg_full;
        n->s1 = s1;
        n->s2 = 0;
        n->s3 = 0;
        n->s4 = 0;
        n->i1 = i1; n->i2 = i2; n->i3 = i3;
        n->i4 = 0;
        n->a1 = a1; n->a2 = a2;
        n->t1 = 0; n->t2 = 0; n->t3 = 0;
        switch(_msgs[msgid].targs){
          case 3: n->t3 = (void *)malloc(i3+1);
                  _copyTagSilent(n->t3, t3, i3);
          case 2: n->t2 = (void *)malloc(i2+1);
                  _copyTagSilent(n->t2, t2, i2);
          case 1: n->t1 = (void *)malloc(i1+1);
                  _copyTagSilent(n->t1, t1, i1);
          case 0: ;
        }
        n->hnext = _msg_store[msgid];
        _msg_store[msgid] = n;
        n->onext = 0;
        *_msg_tail = n;
        _msg_tail = &n->onext;
      }
    } else {
      _print_full(stream, file, line, col, msgid,
		s1, i1,i2,i3, a1,a2, t1,t2,t3);
      if(signalflags[_msgs[msgid].str]) TCKILL;
      else if(_brk_msgid == msgid && _brk_line == line) TCKILL;
    }
  }
}

/*************************/
/* tagpos functions, etc */
/*************************/

/* temporary hack, to get the address associated with tagpos
   NOTE: does the reverse of _getTagPos */
static char * getAddrForPos(_mirror_pos_t tagpos)
{
  unsigned long i;
  void * mapaddr = (void *)((unsigned long)tagpos.ptr & ~(MIRRORPAGE_MASK>>1));
  unsigned long pageaddr = ((unsigned long)tagpos.ptr & (MIRRORPAGE_MASK>>1));

  for(i = 0; i < MIRRORMAP_NUMELEMENTS; ++i){
    if(mirrormap[i] == mapaddr){
      return (char *)(i << MIRRORPAGE_NUMBITS)
	+ pageaddr * 2
	+ tagpos.bit/BITS_PER_TAG;
    }
  }
  _output_internal_error("getAddForPos", "failed!");
  return 0;
}

void overflowTagPos(_mirror_pos_t * tagpos, int offset)
{
  GET_TAG_POS(*tagpos, getAddrForPos(*tagpos) + offset);
}


/* used by "setScalarTag"
 * stray tags should be cleared to "_typetag_uninit"
 * and warn (only if tag wasn't uninit [or unalloc?] before)
 */
static void initTag(const char * fname, int line, int col,
		    void * addr, _ctype_t type)
{
  int i;
  /* Get the position of the tag for the address. */
  _mirror_pos_t tagpos;

  /* First nibble has tag 0xxx, where xxx is the typetag;
     second nibble is 1yyy, where yyy is the log of the size;
     third nibble is 0zzz, where zzz is unalloc typetag (really 0). */
  uchar first_nibble = typeinfo[type].typetag;
  uchar size_nibble = CONT_BIT_MASK | typeinfo[type].logsize;
  uchar subsequent_nibble = CONT_BIT_MASK | _typetag_unalloc;

  GET_TAG_POS(tagpos, addr);

  /* Clear off stray tags to the left */
  if(CONT_BIT(tagpos)){
    _mirror_pos_t iter = tagpos;
    int overwritten = 1;

    PREV_POS(iter);
    while(CONT_BIT(iter)){
      WRITE_TAG(iter,_typetag_uninit);
      PREV_POS(iter);
      overwritten++;
    }

    if(TAG_BITS(iter) != _typetag_uninit){
        _output_full(fname, line, col, SST_ONM,
		_typeDesc[TYPE_BITS(iter)],
		overwritten,0,0,   addr,0,   0,0,0);
    }

    WRITE_TAG(iter,_typetag_uninit);
  }

  /* write tags for initial byte */
  WRITE_TAG(tagpos, first_nibble);
  if (typeinfo[type].size > 1) {
    NEXT_POS(tagpos);
    WRITE_TAG(tagpos, size_nibble);
  }

  for(i = 2; i < typeinfo[type].size; ++i){
    /* write tag for subsequent bytes */
    NEXT_POS(tagpos);
    WRITE_TAG(tagpos, subsequent_nibble);
  }

  /* Clear off stray tags to the right */
  NEXT_POS(tagpos);
  while(CONT_BIT(tagpos)){
    WRITE_TAG(tagpos,_typetag_uninit)
    NEXT_POS(tagpos);
  }
}

/* If addr's tag is init, return 1 (and set to reftype if fix==1).
 * Otherwise, return 0;
 */
int _checkIfInit(const void * addr, _ctype_t reftype /* must be scalar */, int fix)
{
  _mirror_pos_t tpi;
  int i;

  GET_TAG_POS(tpi, addr);

  for(i = 0; i < typeinfo[reftype].size; ++i){
    if(TAG_BITS(tpi) != _typetag_init)
      return 0;
    NEXT_POS(tpi);
  }

  if(fix){
    _setScalarTag("(tc:_checkIfInit)", 0, 0, addr, reftype);
    if(!tot_dynamic_num_calls--) tot_dynamic_num_calls_overflow--; /* adjust count */
  }

  return 1;
}

/* Equivalent to _verifyTag, except instead of reporting an error,
   it returns status (1 = verify succeeded, 0 = verify failed).
   - used by _promoteTag, _processArgTag/_processRetTag
   - not part of API
   - Note: reftype cannot be aggregate
*/
int _verifyTagSilent(const void * addr, _ctype_t reftype)
{
  _mirror_pos_t tpi;
  _mirror_pos_t stpi;

  GET_TAG_POS(tpi, addr);
  GET_TAG_POS(stpi, typeinfo[reftype].staticrep_ptr);

  /* Compare tags */
  while(TAG_BITS(stpi) != _typetag_unalloc){
    if(TAG_BITS(tpi) != TAG_BITS(stpi)
	&& !_checkIfInit(addr, reftype, 0))
      return 0; /* type mismatch */
    NEXT_POS(tpi);
    NEXT_POS(stpi);
  }

  /* Make sure tagpos has "ended" */
  if(CONT_BIT(tpi))
    return 0; /* type size mismatch */

  /* Verify succeeded, return 1 */
  return 1;
}

/* plain uncomplicated copyTag:
    - don't check alloc
    - don't complain
   but DO clear stray tags to left and right
 */
void _copyTagSilent(const void * dstaddr, const void * srcaddr, size_t size)
{
  int i;
  _mirror_pos_t dst;
  _mirror_pos_t src;

  GET_TAG_POS(dst, dstaddr);
  GET_TAG_POS(src, srcaddr);

  /* Clear off stray tags to the left */
  if(CONT_BIT(dst)){
    _mirror_pos_t iter = dst;
    PREV_POS(iter);
    while(CONT_BIT(iter)){
      /* AAL: unalloc or uninit? */
      WRITE_TAG(iter,_typetag_uninit);
      PREV_POS(iter);
    }
    WRITE_TAG(iter,_typetag_uninit);
  }

  /* Copy tags */
  for(i = 0; i < size; ++i){
    WRITE_TAG(dst,TAG_BITS(src))
    NEXT_POS(src);
    NEXT_POS(dst);
  }

  /* Clear off stray tags to the right */
  while(CONT_BIT(dst)){
    /* AAL: unalloc or uninit? */
    WRITE_TAG(dst,_typetag_uninit)
    NEXT_POS(dst);
  }
}

/* stuff used by verifyAlloc, copyTag, and possibly other functions;
   will eventually want to move to appropriate header file or something */
/* AAL: Macrofy! - after NEXT_POS must somehow PREV_POS! */
#if 0 /* { */
#define TAG_SIZE(pos) ( \
	CONT_BIT(pos) ? -1 : \
		(NEXT_POS(pos), CONT_BIT(pos) ? (1 << TYPE_BITS(pos)) : 1) \
	)
#endif /* } 0 */
int TAG_SIZE(_mirror_pos_t pos)
{
  /* If the CONT_BIT is set on pos, then we're not even at the start
     of a tag.  Return -1.
     If the CONT_BIT is set on the next pos, return the size as encoded
     in the type bits for the next pos.  Otherwise, it is 1. */
  return CONT_BIT(pos) ? -1 :
    (NEXT_POS(pos), CONT_BIT(pos) ? (1 << TYPE_BITS(pos)) : 1);
}

/* verify that memory at tagpos, for size size, is not _typetag_unalloc.
 */
int verifyAlloc(const void * addr, size_t size)
{
  _mirror_pos_t tp;
  _mirror_pos_t tpi;
  int i;

  if(!mirrormap[MIRRORMAP_INDEX(addr)])
    return 0; /* unallocated page */

  GET_TAG_POS(tp, addr);
  tpi = tp;

  if (TAG_BITS(tp) == _typetag_unalloc)
    return 0; /* unallocated memory */
  else if (!CONT_BIT(tp) && /* optimize for scalars: */
	   (NEXT_POS(tp), CONT_BIT(tp) && (1 << TYPE_BITS(tp) >= size)))
    return 1;
  else {
    for(i = 0; i < size; ++i){
      if(TAG_BITS(tpi) == _typetag_unalloc)
	return 0; /* unallocated memory */
      NEXT_POS(tpi);
    }
  }

  /* Verify succeeded, return 1 */
  return 1;
}

/* called by "our" main() after calling the various init
   functions, to process the collected externVarList */
void processExternVars(void)
{
  struct externVarNode * eviter;

  eviter = externVarList;
  while(eviter){
    _mirror_pos_t tagpos;
    struct externVarNode * evcurr = eviter;

    eviter = eviter->next;

    /*--see if tagpos is already initialized */
    GET_TAG_POS(tagpos, evcurr->addr);
    if(TAG_BITS(tagpos) == _typetag_unalloc){
      /*--tagpos has not been allocated; initialize*/
      if(evcurr->type == _ctype_aggregate){
        /* Aggregate type: call initfns */
        if(evcurr->initfns){
          /* note: executeFnCalls will free fnCallNode memory */
          executeFnCalls(evcurr->initfns);
        } else {
          /* Incomplete type: warn? log for now */
	  /* This message is kinda useless; temporarily set aside */
          _output_flc(evcurr->fname, evcurr->line, evcurr->col, PEV_IT);
        }
      } else {
        /* Scalar type: just initialize the tag */
        _setScalarTag(evcurr->fname, evcurr->line, evcurr->col,
			evcurr->addr, evcurr->type);
      }
    } else {
      /*--tagpos has been initialized */
      /*  TODO: may want to verify; do nothing for now */
    }

    free(evcurr);
  }
}

/**************************************/
/* "private" API function definitions */
/**************************************/

/* Summarize if size is bigger than, say, 50, and limit to output of 50 "items" */
void _printTagPos(FILE * f, _mirror_pos_t tagpos, size_t size)
{
  if(size == 0){
    fprintf(f, "<void>");
  } else if(size > 50) { /* summarize */
    int i = size;
    int output_count = 0;

    char memo_type = 0;
    int  memo_size = 0;
    char temp_type = 0;
    char temp_size = 0;
    int  memo_count = 0;

    for(i = 0; i < size; ++i){ /* left-strays */
      if(!CONT_BIT(tagpos)) break;
      else fprintf(f, ":...");
      NEXT_POS(tagpos);
    }
    temp_type = TYPE_BITS(tagpos);
    temp_size = 1;
    for(; i < size; ++i){ /* first tag */
      if(!CONT_BIT(tagpos)) break;
      else temp_size++;
      NEXT_POS(tagpos);
    }
    for(; i < size; ++i){ /* main loop */
      if(!CONT_BIT(tagpos)){
        if(temp_type == memo_type && temp_size == memo_size){
          memo_count++;
        } else {
          if(memo_count){
            if(memo_count == 1)
              fprintf(f, "<%s,%d>", _typeDesc[memo_type], memo_size);
            else
              fprintf(f, "(<%s,%d>x%d)", _typeDesc[memo_type], memo_size, memo_count);
            if(++output_count >= 50){
              fprintf(f, "...remaining %d bytes suppressed...", size-i-temp_size);
              return;
            }
          }
          memo_type = temp_type;
          memo_size = temp_size;
          memo_count = 1;
        }
        temp_type = TYPE_BITS(tagpos);
        temp_size = 1;
      } else {
        temp_size++;
      }
      NEXT_POS(tagpos);
    }
    if(memo_count == 1)
      fprintf(f, "<%s,%d>", _typeDesc[memo_type], memo_size);
    else
      fprintf(f, "(<%s,%d>x%d)", _typeDesc[memo_type], memo_size, memo_count);
    if(temp_size)
      fprintf(f, "<%s,%d%s", _typeDesc[memo_type], memo_size, CONT_BIT(tagpos)?":...":">");
  } else {
    int i;
    const char * type_desc = "...";
    for(i = 0; i < size; ++i){
      fprintf(f, "%c%s", CONT_BIT(tagpos)?':':'<',
	      CONT_BIT(tagpos) ? type_desc : (type_desc = _typeDesc[TYPE_BITS(tagpos)]));
      NEXT_POS(tagpos);
    }
    fprintf(f, "%s", CONT_BIT(tagpos)?":...":">");
  }
}

void _printTag(FILE * f, const void * addr, size_t size)
{
  _printTagPos(f, _getTagPos(addr), size);
}

void _printTagStdout(void * addr, size_t size)
{
  _printTagPos(stdout, _getTagPos(addr), size);
}

void _printTagStderr(void * addr, size_t size)
{
  _printTagPos(stderr, _getTagPos(addr), size);
  fprintf(stderr, "\n");
}

/**********************************************/
/* Wrappers for macros - useful for debugging */
/**********************************************/

_mirror_pos_t _getTagPos(const void * addr)
{
  _mirror_pos_t ret;

  GET_TAG_POS(ret,addr);
/*
  unsigned long mapindex = MIRRORMAP_INDEX(addr);
  unsigned long pageindex = MIRRORPAGE_INDEX(addr);

  if(!mirrormap[mapindex])
    _touchMirrorPage(mapindex);

  ret.ptr = (unsigned char *)mirrormap[mapindex] + pageindex/2;
  ret.bit = pageindex%2 * BITS_PER_TAG;
*/
  return ret;
}

void _printConstsStderr()
{
#define EXPAND_PRINT_STMT(CID) fprintf(stderr, #CID " = %d (0x%08x)\n", CID, CID)
  EXPAND_PRINT_STMT(MIRRORPAGE_NUMBITS);
  EXPAND_PRINT_STMT(MIRRORPAGE_NUMBYTES);
  EXPAND_PRINT_STMT(MIRRORPAGE_MASK);
  EXPAND_PRINT_STMT(MIRRORMAP_NUMBITS);
  EXPAND_PRINT_STMT(MIRRORMAP_NUMELEMENTS);
  EXPAND_PRINT_STMT(BITS_PER_TAG);
  EXPAND_PRINT_STMT(LOG_BITS_PER_TAG);
  EXPAND_PRINT_STMT(CONT_BIT_MASK);
  EXPAND_PRINT_STMT(TYPE_BITS_MASK);
  EXPAND_PRINT_STMT(TAG_BITS_MASK);
  EXPAND_PRINT_STMT(EVEN_TAG_MASK);
  EXPAND_PRINT_STMT(EVEN_TYPE_MASK);
  EXPAND_PRINT_STMT(EVEN_CONT_MASK);
  EXPAND_PRINT_STMT(ODD_TAG_MASK);
  EXPAND_PRINT_STMT(ODD_TYPE_MASK);
  EXPAND_PRINT_STMT(ODD_CONT_MASK);
#undef EXPAND_PRINT_STMT
}

void _tcfn_SET_UNALLOC_TAG(const void * start_addr, const void * end_addr)
	{ SET_UNALLOC_TAG("_tcfn_SET_UNALLOC_TAG",__FILE__,__LINE__,0, start_addr, end_addr); }
const void * _tcfn_MIRRORMAP_INDEX(const void * addr) { return (const void *) MIRRORMAP_INDEX(addr); }
const void * _tcfn_MIRRORPAGE_INDEX(const void * addr) { return (const void *) MIRRORPAGE_INDEX(addr); }
int _tcfn_SAME_MIRROR_PAGE(const void * addr1, const void * addr2) { return SAME_MIRROR_PAGE(addr1, addr2); }
unsigned char _tcfn_TAG_BITS(_mirror_pos_t pos) { return TAG_BITS(pos); }
unsigned char _tcfn_CONT_BIT(_mirror_pos_t pos) { return CONT_BIT(pos); }
unsigned char _tcfn_TYPE_BITS(_mirror_pos_t pos) { return TYPE_BITS(pos); }
void _tcfn_WRITE_TAG(_mirror_pos_t * posptr, unsigned char tag) { WRITE_TAG(*posptr,tag); }
_mirror_pos_t _tcfn_get_NEXT_POS(_mirror_pos_t pos) { NEXT_POS(pos); return pos; }
_mirror_pos_t _tcfn_get_PREV_POS(_mirror_pos_t pos) { PREV_POS(pos); return pos; }
unsigned char _tcfn_ODD_TAG_BITS(unsigned char byte) { return ODD_TAG_BITS(byte); }
unsigned char _tcfn_ODD_TYPE_BITS(unsigned char byte) { return ODD_TYPE_BITS(byte); }
unsigned char _tcfn_EVEN_TAG_BITS(unsigned char byte) { return EVEN_TAG_BITS(byte); }
unsigned char _tcfn_EVEN_TYPE_BITS(unsigned char byte) { return EVEN_TYPE_BITS(byte); }
unsigned char _tcfn_GET_TAG_BYTE(const void * addr) { return GET_TAG_BYTE(addr); }
const void * _tcfn_GET_TAG_BYTE_addr(const void * addr) { return &GET_TAG_BYTE(addr); }
unsigned char _tcfn_GET_CHAR_TAG(unsigned char byte, int isOdd) { return GET_CHAR_TAG(byte, isOdd); }
void _tcfn_SET_CHAR_TAG(unsigned char * lhsptr, unsigned char * rhsptr, int isOdd)
	{ SET_CHAR_TAG(*lhsptr, *rhsptr, isOdd); }

/****************************/
/* API function definitions */
/****************************/

/* function version of SET_UNALLOC_TAG macro */
static void _fn_SET_UNALLOC_TAG(const char * caller, const char * fname, int line, int col,
			const void * start_addr, const void * end_addr)
{ SET_UNALLOC_TAG(caller,fname,line,col, start_addr, end_addr); }

/* NOTE: (type == _ctype_aggregate && externInitFns == 0) means
	 type is incomplete, so don't initialize (?) */
void _registerExtern(const char * fname, int line, int col,
		void * addr, _ctype_t type)
{
  struct externVarNode * evcurr;
  struct externVarNode ** eviter;

  if(!++tot_dynamic_num_calls) ++tot_dynamic_num_calls_overflow; /* count */

  /*--FIRST: look for addr in externVarList */
  eviter = &externVarList;
  while(*eviter && (*eviter)->addr < addr)
    eviter = &(*eviter)->next;

  evcurr = *eviter;

  if(evcurr && evcurr->addr == addr){

    /*--addr found: check for matching types*/
    if(evcurr->type != type){

      /*--type mismatch; warn */
      _output_si(fname, line, col,
		RE_PDEF, 
		fname, evcurr->fname,
		typeinfo[type].desc, typeinfo[evcurr->type].desc,
		line, evcurr->line,
		col, evcurr->col);

    } else if (type == _ctype_aggregate){

      /*--if type matches and is aggregate */

      /*--if new version is complete, and old version is incomplete,
	  adopt new version */
      if(externInitFns && !evcurr->initfns){

        evcurr->fname = fname;
        evcurr->line = line;
        evcurr->col = col;
        evcurr->addr = addr;
        evcurr->type = type;
        evcurr->initfns = externInitFns;
        externInitFns = 0;
        externInitFnsIter = &externInitFns;

      } else if(externInitFns && evcurr->initfns){

        /*--we have two complete aggregate initfns; compare them */
        /* TODO */

      }
    }

    /*--discard init functions (if any) */
    while(externInitFns){
      struct fnCallNode * temp = externInitFns;
      externInitFns = externInitFns->next;
      free(temp);
    }
    externInitFnsIter = &externInitFns;

  } else {

    /*--addr not found; insert info */
    (*eviter) = (struct externVarNode *)malloc(sizeof(struct externVarNode));
    (*eviter)->fname = fname;
    (*eviter)->line = line;
    (*eviter)->col = col;
    (*eviter)->addr = addr;
    (*eviter)->type = type;
    (*eviter)->initfns = externInitFns;
    (*eviter)->next = evcurr;

    /*--reset externInitFns */
    externInitFns = 0;
    externInitFnsIter = &externInitFns;
  }
}

void _touchMirrorPage(unsigned long mapindex)
{
    if(mirrormap_freelist){ /*see comment about freelist above*/
      mirrormap[mapindex] = mirrormap_freelist;
      mirrormap_freelist = 0;
    } else {
      mirrormap[mapindex] = (void *) memalign(MIRRORPAGE_NUMBYTES, MIRRORPAGE_NUMBYTES);
      if(!mirrormap[mapindex])
        exit((_output_internal_error("_touchMirrorPage/FATAL", "memalign out of memory"),-1));
      mirrormap_freelist = (char *)mirrormap[mapindex] + MIRRORPAGE_NUMBYTES/2;
    }
    /* initialize mirror to 0 (_typetag_unalloc) */
    memset(mirrormap[mapindex], _typetag_unalloc, MIRRORPAGE_NUMBYTES/2);
}

/* dereference addr and see if it is allocated (for up to size bytes)
 */
void _verifyPtr(const char * fname, int line, int col, const char * exp,
		const void * addr, size_t size)
{
  if(!++tot_dynamic_num_calls) ++tot_dynamic_num_calls_overflow; /* count */

  /* for now a function call, optimize later when stable */
  if(!verifyAlloc(addr, size)){
    _output_full(fname, line, col, VP_UNA,
		exp, 0,0,0, addr,0, 0,0,0);
	/* prepare to die!  Could return another value from
	   verifyAlloc to say that there is no allocated page
	   in the region.  Could try to exit instead in some cases? */
  }
}

/* Note: we don't fully verify aggregate types;
	 to implement this in the future, we'd need
	 to pass in more info (e.g. size_aggr) */
void _verifyTag(const char * fname, int line, int col, const char * exp,
		const void * addr, _ctype_t reftype /*, size_t size_aggr */)
{
  _mirror_pos_t tpi, stpi;
  _mirror_pos_t staticpos; /* formerly a param */
  _mirror_pos_t tagpos;
  int size;

  if(!++tot_dynamic_num_calls) ++tot_dynamic_num_calls_overflow; /* count */

  /* verifying aggregate: currently just verifyPointer on first byte */
  if(reftype == _ctype_aggregate){
    _verifyPtr(fname,line,col, exp, addr, 1 /* size_aggr */);
    if(!tot_dynamic_num_calls--) tot_dynamic_num_calls_overflow--; /* adjust count */
    return;
  }

  GET_TAG_POS(tagpos, addr);
  GET_TAG_POS(staticpos, typeinfo[reftype].staticrep_ptr);

  size = typeinfo[reftype].size;

  /* Compare tags */
  tpi = tagpos;
  stpi = staticpos;

  if (size > 1) {
    /* AAL: assert(!tpi.bit && !stpi.bit); */
    /* Compare the first bytes of the tags.  The first
       byte of a tag contains both the type and the size. */
    if (*(char *)tpi.ptr != *(char *)stpi.ptr
	&& !_checkIfInit(addr, reftype, 1)) { /*SY: do we really need to fix??*/

      _output_full(fname, line, col, VT_TMM,
		exp, size,size,0, addr,0,
		typeinfo[reftype].staticrep_ptr,addr,0);

      /* if destination is unallocated,
         suppress future messages by setting to declared type */
      /* note: should check for all = unalloc, instead of any = unalloc? */
      if(!verifyAlloc(addr,size))
        _copyTagSilent(addr,typeinfo[reftype].staticrep_ptr,size);

      return;
    }
  }
  else { /* A single byte. */
    if(TAG_BITS(tpi) != TAG_BITS(stpi)
	&& !_checkIfInit(addr, reftype, 1)) { /* could optimize by inlining? */ /*SY: do we really need to fix??*/
      /* type mismatch; verify fails */

      _output_full(fname, line, col, VT_TMM,
		exp, size,size,0, addr,0,
		typeinfo[reftype].staticrep_ptr,addr,0);

      /* if destination is unallocated,
         suppress future messages by setting to declared type */
      if(TAG_BITS(tpi) == _typetag_unalloc)
        _copyTagSilent(addr,typeinfo[reftype].staticrep_ptr,size);

      return;
    }

    NEXT_POS(tpi);
    /* Make sure tagpos has "ended" */
    if(CONT_BIT(tpi)){
      /* tagpos is longer than staticpos */
      _output_full(fname, line, col, VT_TSM,
		exp, size,2*size,0, addr,0, 
		typeinfo[reftype].staticrep_ptr,addr,0);
    }
  }
}

#if !defined(TC_CHECK_SET_UNALLOC) /* { */

#define SBT_NEM_TEST(cond,posn,size,addr)

#else /* } if defined(TC_CHECK_SET_UNALLOC) { */
/* if setByteTags overwrites non-zero (non-Unalloc) memory, issue SBT_NEM warning */

static int _mc; /* used by SBT_NEM_TEST conditionals */

/* _tc_init_mode prevents check for multiple definitions of same location */
/* clear_tag is an argument to setByteTags that indicates whether NEM-check should be done */
#define SBT_NEM_TEST(cond,posn,size,addr) \
	if(!clear_tag && !_tc_init_mode && cond) { \
	  _output_full(fname,line,col, SBT_NEM, 0, size,posn,0, addr,0, addr,0,0); \
	}

/* check a block of (mirror) memory for non-zero (non-Unalloc) memory. */
static int memcheck(void * saddr, size_t n)
{
  if(n <= sizeof(int)){
    char * cp = (char *) saddr;
    int i;
    for(i = 0; i < n; ++i)
      if(cp[i]) return i*2+1;
  } else {
    /* walk up to first int boundary */
    char * cp = (char *) saddr;
    while(((unsigned long)cp) % sizeof(int)){
      if(*cp) return (cp-(char *)saddr)*2+1;
      cp++;
      n--;
    }

    /* check last bytes up to int boundary */
    while(n % sizeof(int))
      if(cp[--n]) return (cp-(char *)saddr)*2+1;

    /* walk in int-sized strides; could go bigger (double-sized strides)? */
    {
      int * ip = (int *) cp;
      int * ep = (int *) (cp + n);
      while(ip < ep){
        if(*ip) return (((char *)ip)-(char *)saddr)*2+1;
        ip++;
      }
    }
  }
  return 0;
}

#endif /* } defined(TC_CHECK_SET_UNALLOC) */

void _setByteTags(const char * fname, int line, int col,
		const void * addr, size_t size, int set_tag, int clear_tag)
{
  _mirror_pos_t spos, epos;
  char * saddr = (char *)addr;
  char * eaddr = (char *)addr + size;
  unsigned char set_tag_pair = set_tag|(set_tag<<BITS_PER_TAG);

  if(!++tot_dynamic_num_calls) ++tot_dynamic_num_calls_overflow; /* count */

  if(saddr != eaddr) {
    /* Check stray tags to left */
    GET_TAG_POS(spos, saddr);
    if(CONT_BIT(spos)){
      _mirror_pos_t tmp;

      _output_flc(fname,line,col, SBT_STB);

      tmp = spos;
      PREV_POS(tmp);
      while(CONT_BIT(tmp)){
        WRITE_TAG(tmp,clear_tag);
        PREV_POS(tmp);
      }
      WRITE_TAG(tmp,_typetag_unalloc);
    }

    /* Align saddr to even address */
    if((unsigned long)saddr & 0x1){
      SBT_NEM_TEST(TAG_BITS(spos),0,size,addr);
      WRITE_TAG(spos,set_tag);
      saddr++;
    }

    /* Check stray tags to right */
    GET_TAG_POS(epos, eaddr);
    if(CONT_BIT(epos)){
      _mirror_pos_t tmp;

      _output_flc(fname,line,col, SBT_STA);

      tmp = epos;
      while(CONT_BIT(tmp)){
        WRITE_TAG(tmp,clear_tag)
        NEXT_POS(tmp);
      }
    }
    /* Align eaddr to even address */
    if((unsigned long)eaddr & 0x1){
      --eaddr;
      GET_TAG_POS(epos, eaddr); /* note: eaddr is (char *) */
      SBT_NEM_TEST(TAG_BITS(epos),size,size,addr);
      WRITE_TAG(epos,set_tag);
    }

    if(SAME_MIRROR_PAGE(saddr,eaddr-1)){
      SBT_NEM_TEST((_mc = memcheck(&GET_TAG_BYTE(saddr), (eaddr-saddr)/2)),
			_mc + (saddr-(char *)addr),size,addr);
      memset(&GET_TAG_BYTE(saddr), set_tag_pair, (eaddr-saddr)/2);
    } else {
      int sindex = MIRRORMAP_INDEX(saddr);
      int eindex = MIRRORMAP_INDEX(eaddr-1);
      SBT_NEM_TEST((_mc = memcheck(&GET_TAG_BYTE(saddr),
		(MIRRORPAGE_NUMBYTES - MIRRORPAGE_INDEX(saddr))/2)),
		_mc + (saddr-(char *)addr),size,addr);
      memset(&GET_TAG_BYTE(saddr), set_tag_pair,
		(MIRRORPAGE_NUMBYTES - MIRRORPAGE_INDEX(saddr))/2);
      for(++sindex; sindex < eindex; sindex++){
        SBT_NEM_TEST((_mc = memcheck(&GET_TAG_BYTE((char *)(sindex << MIRRORPAGE_NUMBITS)),
		MIRRORPAGE_NUMBYTES/2)),_mc + (saddr-(char *)addr),size,addr);
        memset(&GET_TAG_BYTE((char *)(sindex << MIRRORPAGE_NUMBITS)),
		set_tag_pair, MIRRORPAGE_NUMBYTES/2);
      }
      SBT_NEM_TEST((_mc = memcheck(&GET_TAG_BYTE((char *)(sindex << MIRRORPAGE_NUMBITS)),
		MIRRORPAGE_INDEX(eaddr)/2)),_mc + (saddr-(char *)addr),size,addr);
      memset(&GET_TAG_BYTE((char *)(sindex << MIRRORPAGE_NUMBITS)),
		set_tag_pair, MIRRORPAGE_INDEX(eaddr)/2);
    }
  }
}

#if 0 /* { */
#ifdef TC_LOG_DIRTY_COPY /* { */
#define COPYTAG_TYPE_MISMATCH(dst,src) \
( \
  TYPE_BITS(dst) != _typetag_uninit && \
  (( \
     strictPointer && \
     !CONT_BIT(src) && /* AAL: unnecessary now? */ \
     (( \
        TAG_SIZE(src) != TAG_SIZE(dst) \
      )||( \
        TAG_BITS(src) != TAG_BITS(dst) && \
        !(TYPE_BITS(src) == _typetag_int && TYPE_BITS(dst) == _typetag_ptr) && \
        !(TYPE_BITS(src) == _typetag_ptr && TYPE_BITS(dst) == _typetag_int) \
     )) \
   )||( \
     !strictPointer && \
     TAG_BITS(src) != TAG_BITS(dst) \
  )) \
)
#endif /* } TC_LOG_DIRTY_COPY */
#endif /* } if 0 */

/* stray tags are cleared to "uninit", since we're merely corrupting
 * it, not unallocating it.
 */
void _copyTag(const char * fname, int line, int col,
		const void * dstaddr, const void * srcaddr,
		size_t size, _ctype_t type)
{
  int log_written = 0, warn_written = 0;
  int i;
  _mirror_pos_t dst;
  _mirror_pos_t src;

  if(!++tot_dynamic_num_calls) ++tot_dynamic_num_calls_overflow; /* count */

  GET_TAG_POS(dst, dstaddr);
  GET_TAG_POS(src, srcaddr);

  if(!verifyAlloc(srcaddr, size)){
    /* copying from unallocated memory! */
    _output_full(fname,line,col, CT_CFU,
		0, 0,0,0, srcaddr,dstaddr, 0,0,0);
    
    if(type != _ctype_aggregate){
      /* if static type is scalar, we can continue */

      GET_TAG_POS(src, typeinfo[type].staticrep_ptr);

    } else {
      /* if static type is aggregate, do nothing */

      if(!verifyAlloc(dstaddr, size)){
        /* copying into unallocated memory! */
        _output_flc(fname,line,col, CT_AIU);
      }
      return;
    }
  }

  if(!verifyAlloc(dstaddr, size)){
    /* copying into unallocated memory! */
    _output_full(fname,line,col, CT_CIU,
		0, 0,0,0, srcaddr,dstaddr, 0,0,0);
  }

  /* -- Check src against static_type and warn on mismatch */
  if(streams[_msgs[CT_TMM].str]
	&& (type != _ctype_aggregate)
	&& ((TAG_SIZE(src) != typeinfo[type].size)
	    || (TAG_BITS(src) != typeinfo[type].typetag))
	&& !_checkIfInit(srcaddr, type, 0)){
    /* WARN mismatch */ 
    _output_full(fname,line,col, CT_TMM,
		0, size,size,size, srcaddr,dstaddr,
		typeinfo[type].staticrep_ptr,srcaddr,dstaddr);
    log_written = 1;
  }

#ifdef TC_LOG_DIRTY_COPY /* { */
  /* -- Check dst against static_type and warn on mismatch */
  if(streams[_msgs[CT_TDM].str]
	&& (type != _ctype_aggregate)
	&& (TAG_BITS(dst) != _typetag_uninit)
	&& ((TAG_SIZE(dst) != typeinfo[type].size)
	    || (TAG_BITS(dst) != typeinfo[type].typetag))){
    /* WARN mismatch */ 
    _output_full(fname,line,col, CT_TDM,
		0, size,size,size, srcaddr,dstaddr,
		typeinfo[type].staticrep_ptr,srcaddr,dstaddr);
    log_written = 1;
  }
#endif /* } TC_LOG_DIRTY_COPY */

  /* Clear off stray tags to the left */
  if(CONT_BIT(dst)){
    _mirror_pos_t iter = dst;
    PREV_POS(iter);
    while(CONT_BIT(iter)){
      /* AAL: unalloc or uninit? */
      WRITE_TAG(iter,_typetag_uninit);
      PREV_POS(iter);
    }
    WRITE_TAG(iter,_typetag_uninit);
  }

  /* Main copying loop. */
  for(i = 0; i < size; ){

    size_t src_size;

    /* Is this the start of a tag; does it fit within the size to be copied? */
    if(!CONT_BIT(src) && (src_size = TAG_SIZE(src)) <= size - i) {

      int j;

#if 0 /* { */ /* This will catch aggregate mismatches - pointless? */
      /* Warn if we haven't yet and there is a type or size mismatch.
	 The destination being uninit does not count as a mismatch. */
      /* AAL: May not want to warn if size doesn't match when dst is uninit. */
#ifdef TC_LOG_DIRTY_COPY /* { */
      if(streams[_msgs[CT_TDM].str] && !log_written && 
	 (COPYTAG_TYPE_MISMATCH(dst,src) || TAG_SIZE(dst) != TAG_SIZE(src)) &&
	 TYPE_BITS(dst) != _typetag_uninit){
	/* copying into memory initialized with different type */
        _output_full(fname,line,col, CT_TDM,
		0, typeinfo[type].size,size,size, srcaddr,dstaddr,
		typeinfo[type].staticrep_ptr,srcaddr,dstaddr);
	log_written = 1;
      }
#endif /* } TC_LOG_DIRTY_COPY */
#endif /* } if 0 */

      /* Now do the actual tag copy. */
      /* AAL: Should do this in one shot if possible. */
      for(j = 0; j < src_size; ++j){
	WRITE_TAG(dst, TAG_BITS(src));
	NEXT_POS(src);
	NEXT_POS(dst);
      }
      i += src_size;

    } else {  /* AAL: Copying from the middle of src!  Warn! */

      if (!warn_written) {
	/* This is not the start of src or
	   it is longer than the data to be copied? */
        _output_full(fname,line,col, CT_SI,
		0, size,size,0, srcaddr,dstaddr, srcaddr,dstaddr,0);
	warn_written = 1;
      }

      /* Set dst's type to uninit. */
      /* SY: New change: set to INIT instead. */
      do {
	WRITE_TAG(dst, _typetag_init);
	NEXT_POS(src);
	NEXT_POS(dst);
	i++;
      } while (CONT_BIT(src) && i < size);
    }
  }

  /* Clear off stray tags to the right */
  while(CONT_BIT(dst)){
    /* AAL: unalloc or uninit? */
    WRITE_TAG(dst,_typetag_uninit);
    NEXT_POS(dst);
  }
}

/* SY: currently unused: discard? Don't remember its intended purpose -27feb02 */
void _extern_registerVar(const char * fname, int line, int col,
		const char * varname, void * addr, size_t size)
{
  if(externInitFns)
    _output_flc(fname,line,col, ERV_ENN);
  externInitFns = 0;
  externInitFnsIter = &externInitFns;
}

void _extern_setUninitTag(const char * fname, int line, int col,
			void * addr, size_t size)
{
  *externInitFnsIter = (struct fnCallNode *)malloc(sizeof(struct fnCallNode));
  (*externInitFnsIter)->function = setUninitTag;
  (*externInitFnsIter)->args.sut.fname = fname;
  (*externInitFnsIter)->args.sut.line = line;
  (*externInitFnsIter)->args.sut.col = col;
  (*externInitFnsIter)->args.sut.addr = addr;
  (*externInitFnsIter)->args.sut.size = size;
  (*externInitFnsIter)->next = 0;
  externInitFnsIter = &(*externInitFnsIter)->next;
}

void _extern_setScalarTag(const char * fname, int line, int col,
			const void * addr, _ctype_t type)
{
  *externInitFnsIter = (struct fnCallNode *)malloc(sizeof(struct fnCallNode));
  (*externInitFnsIter)->function = setScalarTag;
  (*externInitFnsIter)->args.sst.fname = fname;
  (*externInitFnsIter)->args.sst.line = line;
  (*externInitFnsIter)->args.sst.col = col;
  (*externInitFnsIter)->args.sst.addr = addr;
  (*externInitFnsIter)->args.sst.type = type;
  (*externInitFnsIter)->next = 0;
  externInitFnsIter = &(*externInitFnsIter)->next;
}

void _extern_replicateTag(const char * fname, int line, int col,
			void * addr, size_t size, int nelem)
{
  *externInitFnsIter = (struct fnCallNode *)malloc(sizeof(struct fnCallNode));
  (*externInitFnsIter)->function = replicateTag;
  (*externInitFnsIter)->args.rt.fname = fname;
  (*externInitFnsIter)->args.rt.line = line;
  (*externInitFnsIter)->args.rt.col = col;
  (*externInitFnsIter)->args.rt.addr = addr;
  (*externInitFnsIter)->args.rt.size = size;
  (*externInitFnsIter)->args.rt.nelem = nelem;
  (*externInitFnsIter)->next = 0;
  externInitFnsIter = &(*externInitFnsIter)->next;
}

/* SY: currently unused: discard? Don't remember its intended purpose -27feb02 */
void _registerVar(const char * fname, int line, int col,
		const char * varname, void * addr, size_t size)
{
}

/* AAL: Produces uninits of byte size only. */
void _setScalarUninitTag(const char * fname, int line, int col,
			 void * addr, _ctype_t type)
{
  /* AAL: was initTag(fname, line, col, addr, _typetag_uninit); */

  int i;
  /* Get the position of the tag for the address. */
  _mirror_pos_t tagpos;

  /* First nibble has tag 0xxx, where xxx is _typetag_uninit;
     second nibble is 1yyy, where yyy is the log of the size;
     third nibble is 0zzz, where zzz is unalloc typetag (really 0). */
  uchar first_nibble = _typetag_uninit;
  uchar size_nibble = CONT_BIT_MASK | typeinfo[type].logsize;
  uchar subsequent_nibble = CONT_BIT_MASK | _typetag_unalloc;

  if(!++tot_dynamic_num_calls) ++tot_dynamic_num_calls_overflow; /* count */

  GET_TAG_POS(tagpos, addr);

  /* Clear off stray tags to the left */
  if(CONT_BIT(tagpos)){
    _mirror_pos_t iter = tagpos;

    _output_flc(fname,line,col, SSUT_NEM);

    PREV_POS(iter);
    while(CONT_BIT(iter)){
      /* AAL: unalloc or uninit? */
      WRITE_TAG(iter,_typetag_unalloc);
      PREV_POS(iter);
    }
    WRITE_TAG(iter,_typetag_unalloc);
  }

  /* write tags for initial byte */
  WRITE_TAG(tagpos, first_nibble);
  if (typeinfo[type].size > 1) {
    NEXT_POS(tagpos);
    WRITE_TAG(tagpos, size_nibble);
  }

  for(i = 2; i < typeinfo[type].size; ++i){
    /* write tag for subsequent bytes */
    NEXT_POS(tagpos);
    WRITE_TAG(tagpos, subsequent_nibble);
  }

  /* Clear off stray tags to the right */
  NEXT_POS(tagpos);
  while(CONT_BIT(tagpos)){
    /* AAL: unalloc or uninit? */
    WRITE_TAG(tagpos,_typetag_unalloc)
    NEXT_POS(tagpos);
  }
}

/* if type is pointer, initialize to int */
void _setScalarTagPtrToInt(const char * fname, int line, int col,
		const void * addr, _ctype_t type)
{
  if(!++tot_dynamic_num_calls) ++tot_dynamic_num_calls_overflow; /* count */
  if(type == _ctype_pointer){
    initTag(fname, line, col, (void *)addr, _ctype_int);
  } else {
    initTag(fname, line, col, (void *)addr, type);
  }
}

void _setScalarTag(const char * fname, int line, int col,
		const void * addr, _ctype_t type)
{
  if(!++tot_dynamic_num_calls) ++tot_dynamic_num_calls_overflow; /* count */
  initTag(fname, line, col, (void *)addr, type);
}

void _replicateTag(const char * fname, int line, int col,
		void * addr, size_t size, int nelem)
{
  int i;
  char * dst = addr;

  if(!++tot_dynamic_num_calls) ++tot_dynamic_num_calls_overflow; /* count */

/* temporary ASSERT */
  if(nelem == 0){
    fprintf(stderr, "TC: replicating 0 elements!\n");
    return;
  }

  for(i = 1; i < nelem; ++i)
    _copyTagSilent(dst += size, addr, size);
}

/*
 * if opnd_size == expr_size
 * then do nothing //-- memcopy => no change
 * else if verifyTag(*addrptr, opnd_staticpos)
 *      then *addrptr = expr_staticpos //-- `enforce' mode
 *      else do truncation/expansion //-- the messy case
 *
 * Note: tmpspace must be of size >= exptype. tmpspace's mirror is used
 *       to return the promoted tags only if it's a funny case.
 */
void _promoteTag(const char * fname, int line, int col,
		const void ** addrptr, _ctype_t optype, _ctype_t exptype,
		void * tmpspace)
{
  if(!++tot_dynamic_num_calls) ++tot_dynamic_num_calls_overflow; /* count */
  if(typeinfo[optype].size != typeinfo[exptype].size){
    if(_verifyTagSilent(*addrptr, optype)){
      *addrptr = typeinfo[exptype].staticrep_ptr;
    } else {
      /* do dirty work here */
      *addrptr = typeinfo[exptype].staticrep_ptr;
    }
  }
}

#ifdef TC_COUNT_PROC_RET /* { */
int _numEmptyProcessReturn = 0;
int _numCommonProcessReturn = 0;
int _numProcessReturn = 0;
#endif /* } TC_COUNT_PROC_RET */

/* debugging stuff to trace calls */
#ifdef TC_TRACECALL /* { */
#define TC_FNSTACK_SIZE 2048
const char * _tc_fnstack[TC_FNSTACK_SIZE];
int _tc_fnstack_i = 0;
#endif /* } TC_TRACECALL */

void _tcdebug_processCall_func(const char * fnname)
{
#ifdef TC_TRACECALL /* { */
  fprintf(stderr, "<<%d>>CALLED %s\n", _tc_fnstack_i, fnname);

  if(_tc_fnstack_i < TC_FNSTACK_SIZE)
    _tc_fnstack[_tc_fnstack_i] = fnname;

  _tc_fnstack_i++;
#endif /* } TC_TRACECALL */
}

/* Note: aargaddrs serves two purposes:
      2 - (void *)aargaddrs marks the start of the stack frame
      2 - *aargaddrs points to the argaddrs array, if any
*/
/* addr == null indicates void return */
void _processReturn(const char * fname, int line, int col,
		void * scaf_start, void * scaf_end, void * agrf_start, void * agrf_end,
		_addr_and_size_t ** aargaddrs, const void * addr, size_t size)
{
  static int debugflag = 0;

  /* mark end of stack frame */
  void * sf_top = &sf_top;

  _addr_and_size_t * argaddrs = *aargaddrs;

  if(!++tot_dynamic_num_calls) ++tot_dynamic_num_calls_overflow; /* count */

  /* process return tag: return value is in <addr,size>,
     the caller's expectation is in argaddrs[0].<addr,size>. */
#ifdef TC_COUNT_PROC_RET /* { */
_numProcessReturn++;
#endif /* } TC_COUNT_PROC_RET */

#ifdef TC_TRACECALL /* { */
  {
    const char * fnname = "-overflow-";

    _tc_fnstack_i--;
    if(_tc_fnstack_i < TC_FNSTACK_SIZE)
      fnname = _tc_fnstack[_tc_fnstack_i];

    fprintf(stderr, "<<%d>>RETURNING %s\n", _tc_fnstack_i, fnname);

    if(agrf_start){
      fprintf(stderr, "\tagrf_end   = %p (%6d)\n", agrf_end  , ((char *)agrf_end  ) - (char *)sf_top);
      fprintf(stderr, "\tagrf_start = %p (%6d)\n", agrf_start, ((char *)agrf_start) - (char *)sf_top);
    }
    if(scaf_start){
      fprintf(stderr, "\tscaf_end   = %p (%6d)\n", scaf_end  , ((char *)scaf_end  ) - (char *)sf_top);
      fprintf(stderr, "\tscaf_start = %p (%6d)\n", scaf_start, ((char *)scaf_start) - (char *)sf_top);
    }
    fprintf(stderr, "\taargaddrs  = %p (%6d)\n", aargaddrs , ((char *)aargaddrs ) - (char *)sf_top);
    fprintf(stderr, "\tsf_top     = %p (%6d)\n", sf_top    , ((char *)sf_top    ) - (char *)sf_top);
  }
#endif /* } TC_TRACECALL */

  if(argaddrs && argaddrs[0].size){
    /* if caller is instrumented, and expects a return value */
    /* (else do nothing) */

    if(size == argaddrs[0].size){
      /* -- same size -- */

      /* -- common case: if  - size > 1, and     - even addresses, and
                             - tags match, and   - tag size matches size
            then we're done checking.
       */
      if(!(size > 1
	 && !(((unsigned long)addr | (unsigned long)argaddrs[0].addr) & 0x1)
	 && GET_TAG_BYTE(addr) == GET_TAG_BYTE(argaddrs[0].addr)
	 && (1 << (ODD_TYPE_BITS(GET_TAG_BYTE(addr)))) == size)){

        /* else: either size = 1,         or non-aligned addresses,
                     or tags don't match, or tag size doesn't match size
		     or addr is <INI>
           do things slowly */

        size_t i;
        _mirror_pos_t tpi;
        _mirror_pos_t rtpi;

        GET_TAG_POS(tpi, addr);
        GET_TAG_POS(rtpi, argaddrs[0].addr);

        /* Compare tags */
        for(i = 0; i < size; ++i){
          if(TAG_BITS(tpi) != TAG_BITS(rtpi)
		&& TAG_BITS(tpi) != _typetag_init){ /* INI comparison */
            /* type mismatch */

            _output_full(fname,line,col, PR_TMM,
			0, size,size,0, 0,0, argaddrs[0].addr,addr,0);
            break;
          }
          NEXT_POS(tpi);
          NEXT_POS(rtpi);
        }
        if(i < size){ /* mismatch occurred: copy */
          _copyTagSilent(argaddrs[0].addr, addr, size);
        }
        /* No mismatch: Make sure tagpos has "ended" */
        if(i == size && CONT_BIT(tpi)){
          /* type size mismatch */
          _output_full(fname,line,col, PR_TSM,
			0, size,2*size,0, 0,0, argaddrs[0].addr,addr,0);
        }
#ifdef TC_COUNT_PROC_RET
      } else {
_numCommonProcessReturn++;
#endif /* TC_COUNT_PROC_RET */
      }
    } else {
      /* -- size mismatch -- */

      /* OUTPUT WARNING HERE */
      _output_full(fname,line,col, PR_TMC,
		0, argaddrs[0].size,size,0, 0,0, argaddrs[0].addr,addr,0);

      /* -- leave declared type -- */
    }
#ifdef TC_COUNT_PROC_RET
  } else {
_numEmptyProcessReturn++;
#endif /* TC_COUNT_PROC_RET */
  }

  /* Clear the stack frame between sf_bottom and sf_top */

  /* mark start of stack */
  if(((void *)aargaddrs) > sf_top){ /* stack grows downward */

    void * sf_bottom = aargaddrs;

    switch(tc_flag_clear){
      case _TC_TO_HIGHEST:
           if(scaf_start && scaf_end > sf_bottom) sf_bottom = scaf_end;
           if(agrf_start && agrf_end > sf_bottom) sf_bottom = agrf_end;
           break;
      case _TC_TO_SCALAR:
           if(scaf_start && scaf_end > sf_bottom) sf_bottom = scaf_end;
           if(agrf_start && agrf_end > scaf_end) {
             _fn_SET_UNALLOC_TAG("processReturn/toScalar",fname,line,col, agrf_start, agrf_end);
           }
           break;
      case _TC_TO_AGGR:
           if(agrf_start && agrf_end > sf_bottom) sf_bottom = agrf_end;
           if(scaf_start && scaf_end > agrf_end) {
             _fn_SET_UNALLOC_TAG("processReturn/toAggr",fname,line,col, scaf_start, scaf_end);
           }
           break;
      case _TC_SEGS_ONLY:
           if(scaf_start) {
             _fn_SET_UNALLOC_TAG("processReturn/Segs",fname,line,col, scaf_start, scaf_end);
           }
           if(agrf_start) {
             _fn_SET_UNALLOC_TAG("processReturn/Segs",fname,line,col, agrf_start, agrf_end);
           }
      case _TC_NONE:
           ;
    }

    SET_UNALLOC_TAG("processReturn", fname,line,col, sf_top, sf_bottom);

    if(!debugflag++ && streams[_tc_debug])
      fprintf(streams[_tc_debug], "Note: stack grows decreasingly!\n");

  } else {                /* stack grows upward   */

    void * sf_bottom = aargaddrs;

    switch(tc_flag_clear){
      case _TC_TO_HIGHEST:
           if(scaf_start && scaf_start < sf_bottom) sf_bottom = scaf_start;
           if(agrf_start && agrf_start < sf_bottom) sf_bottom = agrf_start;
           break;
      case _TC_TO_SCALAR:
           if(scaf_start && scaf_start < sf_bottom) sf_bottom = scaf_start;
           if(agrf_start && agrf_start < scaf_start) {
             _fn_SET_UNALLOC_TAG("processReturn/toScalar", fname,line,col, agrf_start, agrf_end);
           }
           break;
      case _TC_TO_AGGR:
           if(agrf_start && agrf_start < sf_bottom) sf_bottom = agrf_end;
           if(scaf_start && scaf_start < agrf_start) {
             _fn_SET_UNALLOC_TAG("processReturn/toAggr", fname,line,col, scaf_start, scaf_end);
           }
           break;
      case _TC_SEGS_ONLY:
           if(scaf_start) {
             _fn_SET_UNALLOC_TAG("processReturn/Segs", fname,line,col, scaf_start, scaf_end);
           }
           if(agrf_start) {
             _fn_SET_UNALLOC_TAG("processReturn/Segs", fname,line,col, agrf_start, agrf_end);
           }
      case _TC_NONE:
           ;
    }

    SET_UNALLOC_TAG("processReturn", fname,line,col, sf_bottom, sf_top);

    if(!debugflag++ && streams[_tc_debug])
      fprintf(streams[_tc_debug], "Note: stack grows increasingly\n");

  }

}

void _processArgTag(const char * fname, int line, int col,
		_addr_and_size_t * argaddrs,
		/*int argCount,*/ int index,
		void * addr, _ctype_t type, size_t size_aggr)
{
  if(!++tot_dynamic_num_calls) ++tot_dynamic_num_calls_overflow; /* count */
  if(index <= _globalArgCount){

    if(type == _ctype_aggregate){
      /* -- Aggregate type -- */

      /** same size, just copy **/
      if(argaddrs[index].size == size_aggr){
        /*NOTE: copyTag won't cough _typetag_unalloc; memory is pre-initialized*/
        _copyTag(fname,line,col,
		addr, argaddrs[index].addr, argaddrs[index].size, type);
        if(!tot_dynamic_num_calls--) tot_dynamic_num_calls_overflow--; /* adjust count */

      /** size mismatch, output warning and leave declared type? **/
      } else {
        /* OUTPUT WARNING HERE */
        _output_si(fname,line,col, PAT_TMA,
		0,0,0,0, size_aggr,argaddrs[index].size,index,0);

        /* leave declared type, or attempt partial copy? */
      }
    } else {
      /* -- Scalar type -- */

      /** same size, just copy **/
      if(argaddrs[index].size == typeinfo[type].size){
        /* NOTE: copyTag won't cough _typetag_unalloc; memory is pre-initialized */
        /* NOTE: if arg is INI, we'll just maintain INI tag (copyTag won't complain) */
        _copyTag(fname,line,col,
		addr, argaddrs[index].addr, argaddrs[index].size, type);
        if(!tot_dynamic_num_calls--) tot_dynamic_num_calls_overflow--; /* adjust count */

      /** type matches promotion, set to declared type **/
      } else if(argaddrs[index].size == typeinfo[typeinfo[type].promo].size &&
		_verifyTagSilent(argaddrs[index].addr, typeinfo[type].promo)){
        /* note: verifyTagSilent fixes INI types */
        _setScalarTag(fname,line,col, addr, type);
        if(!tot_dynamic_num_calls--) tot_dynamic_num_calls_overflow--; /* adjust count */

      /** size/type mismatch, output warning and leave declared type? **/
      } else {
        /* OUTPUT WARNING HERE */
        _output_full(fname,line,col, PAT_TMS,
		0, typeinfo[type].size,argaddrs[index].size,index,
		0,0, typeinfo[type].staticrep_ptr,argaddrs[index].addr,0);

        /* leave declared type; or attempt partial copy? */
      }
    }
  } else {
    /* we're out of bounds */
    /* WARN: not enough arguments passed to function, set uninit (?) */
    _output_si(fname,line,col, PAT_NEA,
		0,0,0,0, index,_globalArgCount,0,0);

    _setUninitTag(fname, line, col, addr, typeinfo[type].size);
    if(!tot_dynamic_num_calls--) tot_dynamic_num_calls_overflow--; /* adjust count */
    /* alt: leave declared type */
  }
}

/*****************************************/
/* report static instrumentation numbers */
/*****************************************/
void _reportNumCalls(const char * fname, int num_calls)
{
  tot_static_num_calls += num_calls;
}

#endif /* } if 0 */
/******************************************/
@


1.2
log
@Basic skeleton is there, and verifyPtr is partially written
though not tested.
@
text
@d3 1
d99 9
d115 9
d138 114
a270 3
void _tcptr_registerExtern(void * addr, size_t size)
{
}
d281 1
a281 1
      unsigned char mask = maskfront|maskback;
d285 6
a290 2

      if(mask & GET_TAG_BYTE(addr) != mask)
d296 2
a297 2
      if(maskfront & GET_TAG_BYTE(saddr) != maskfront ||
         maskback  & GET_TAG_BYTE(eaddr) != maskback)
d301 4
d306 51
a356 7
/*
    const char * head_byte = &GET_TAG_BYTE(addr);
    int head_bits = TAGS_PER_BYTE - MOD_TAGS_PER_BYTE((unsigned long)addr);
    const char * next_byte = head_byte + 1;
    const char * tail_byte = &GET_TAG_BYTE((const char *) addr + size);
    int tail
*/
d360 1
a360 1
void _tcptr_setTags(int tag, const void * addr, size_t size)
d362 63
d427 2
a428 1
void _tcptr_extern_setTag(int tag, void * addr, size_t size)
d430 63
d542 1
d632 2
a633 2
    _tcptr_setTags(1, &argv[i],sizeof(char *));
    _tcptr_setTags(1, argv[i],strlen(argv[i])+1);
d636 1
a636 1
  _tcptr_setTags(1, &argv[i],sizeof(char *));
d641 70
@


1.1
log
@Initial revision
@
text
@d3 1
d8 35
d45 90
d144 32
d178 1
a178 1
void _tcptr_setAppropriateTags(const void * addr, size_t size)
d182 1
a182 1
void _tcptr_extern_setAppropriateTag(void * addr, size_t size)
d191 1
a191 1
/* DIAGNOSTIC */
d193 1
a193 1
void _output_error(const char * msg)
a194 1
  fprintf(stderr, "%s\n", msg);
d197 4
a200 1
void _reportNumCalls(const char * fname, int num_calls)
d202 26
d235 94
d331 1
a331 1
/******************************************/
a2462 241
/*****************************************/
/* print user and system time difference */
/*****************************************/
static void printdelta(FILE * s, struct rusage * r1, struct rusage * r2)
{
  struct timeval u1 = r1->ru_utime;
  struct timeval u2 = r2->ru_utime;
  struct timeval s1 = r1->ru_stime;
  struct timeval s2 = r2->ru_stime;

  fprintf(s, "%.3f u, %.3f s\n",
	(double)(u2.tv_sec-u1.tv_sec)+(double)(u2.tv_usec-u1.tv_usec)/1000000,
	(double)(s2.tv_sec-s1.tv_sec)+(double)(s2.tv_usec-s1.tv_usec)/1000000
	);
}

struct rusage ru0, ru1, ru2, ru3, ru4, ru5;
/***********************************/
/* cleanup: registered with atexit */
/***********************************/
static void cleanup()
{
  FILE * statstream = streams[_tc_stat];
  int msg_count;

#ifdef TC_DOSTATS
  getrusage(RUSAGE_SELF, &ru5);
#endif /* TC_DOSTATS */

  msg_count = _print_all_msgs();

  /* report numbers of instrumentation calls */
  if(statstream){
    fprintf(statstream, "Static  inst-calls: %lu\n", tot_static_num_calls);
    fprintf(statstream, "Dynamic inst-calls: %lu + %lu * (%lu+1)\n",
			tot_dynamic_num_calls,
			tot_dynamic_num_calls_overflow,
			(unsigned long)-1);
    fprintf(statstream, "Error/warning/log messages: %d\n", msg_count);
  }

#ifdef TC_DOSTATS
  if(statstream){

    fprintf(statstream, "Total time: ");
    printdelta(statstream, &ru0, &ru5);

    fprintf(statstream, "Call init functions: ");
    printdelta(statstream, &ru1, &ru2);

    fprintf(statstream, "Process externs: ");
    printdelta(statstream, &ru2, &ru3);

    fprintf(statstream, "Prog_main: ");
    printdelta(statstream, &ru4, &ru5);

#ifdef TC_COUNT_PROC_RET /* { */
    fprintf(statstream, "processReturns : tot %d, empty %d, common %d\n",
			_numProcessReturn,
			_numCommonProcessReturn,
			_numEmptyProcessReturn);
#endif /* } TC_COUNT_PROC_RET */

    if(_vpctr || _vpcctr || _vpactr
	|| _vtctr || _vtcctr || _vtactr
	|| _ctctr || _ctcctr || _ctactr
	|| _sstctr || _sstcctr
	|| _ssutctr || _ssutcctr
	|| _patctr || _patpctr || _patactr){

      fprintf(statstream, "Macro counts (function counts):\n");

      fprintf(statstream,
	"verifyPtr : char %d(%d), aggr %d(%d), etc %d(%d)\n",
	_vpcctr, _vpcfctr, _vpactr, _vpafctr, _vpctr, _vpfctr);

      fprintf(statstream,
	"verifyTag : char %d(%d), aggr %d(%d), etc %d(%d)\n",
	_vtcctr, _vtcfctr, _vtactr, _vtafctr, _vtctr, _vtfctr);

      fprintf(statstream,
	"  copyTag : char %d(%d), aggr %d(%d), etc %d(%d)\n",
	_ctcctr, _ctcfctr, _ctactr, _ctafctr, _ctctr, _ctfctr);

      fprintf(statstream,
	"      setScalarTag : char %d(%d), etc %d(%d)\n",
	_sstcctr, _sstcfctr, _sstctr, _sstfctr);

      fprintf(statstream,
	"setScalarUninitTag : char %d(%d), etc %d(%d)\n",
	_ssutcctr, _ssutcfctr, _ssutctr, _ssutfctr);

      fprintf(statstream,
	"processArgTag : scalar %d(%d) (promo %d), aggr %d(%d)\n",
	_patctr, _patfctr, _patpctr, _patactr, _patafctr);
    }
  }
#endif /* TC_DOSTATS */
}

static int stringToStreamId(const char * cp, const char ** endptr)
{
  int i;
  for(i = 0; i < _tc_numstreams; ++i){
    int slen = strlen(stream_descr[i]);
    if(!strncmp(cp,stream_descr[i],slen)){
      if(endptr) *endptr = cp + slen;
      return i;
    }
  }
  return -1;
}


/************************/
/* "real" main function */
/************************/
int main(int argc, char * argv[])
{
  extern void callInitFunctions(void);
  extern int _prog_main(int argc, char * argv[]);
  int i;
  int ret;

  /* typechecker output streams */
  /* if set to 0, nothing will be output */
  streams[_tc_stat] = stderr;
  streams[_tc_log] = stderr;
  streams[_tc_debug] = 0; /* debug messages are just meaninglessly annoying */
  streams[_tc_warn] = stderr;
  streams[_tc_error] = stderr;

  /* initialize signal flags */
  signalflags[_tc_log] = 1;
  signalflags[_tc_warn] = 1;
  signalflags[_tc_error] = 1;

  TC_DO_TIMINGS(getrusage(RUSAGE_SELF, &ru0));

#ifndef TC_NOSIGNAL
  signal(TCSIG,SIG_IGN);
#endif

  /* register the cleanup function with atexit() */
  atexit(cleanup);

  /* intercept TC command-line arguments */
  for(i = 0; i < argc; ++i){
    if(!strncmp(argv[i],"-tc-",4)){
      int j;
      if(!strcmp(argv[i]+4,"summarize")) tc_flag_summarize = 1;
      else if(!strcmp(argv[i]+4,"terse")) tc_flag_terse = 1;
      else if(!strcmp(argv[i]+4,"trackfree")) tc_flag_trackfree = 1;
      else if(!strcmp(argv[i]+4,"allsig"))
		signalflags[_tc_log] = signalflags[_tc_warn] = signalflags[_tc_error] = 1;
      else if(!strcmp(argv[i]+4,"clearsig")){
             int i;
             for(i = 0; i < _tc_numstreams; ++i)
               signalflags[i] = 0;
      } else if(!strncmp(argv[i]+4,"sig-",4)){
             int stream_id;
             stream_id = stringToStreamId(argv[i]+8, 0);
             if(stream_id != -1){
               signalflags[stream_id] = 1;
               fprintf(stderr, "TC: Turning on signal for %s stream\n", stream_descr[stream_id]);
             } else fprintf(stderr, "TC: Malformed -tc- flag ignored (%s)\n", argv[i]);
      } else if(!strncmp(argv[i]+4,"nosig-",6)){
             int stream_id;
             stream_id = stringToStreamId(argv[i]+10, 0);
             if(stream_id != -1){
               signalflags[stream_id] = 0;
               fprintf(stderr, "TC: Turning off signal for %s stream\n", stream_descr[stream_id]);
             } else fprintf(stderr, "TC: Malformed -tc- flag ignored (%s)\n", argv[i]);
      } else if(!strncmp(argv[i]+4,"clear=",6)){
             if(!strcmp(argv[i]+10,"none"))
		tc_flag_clear = _TC_NONE;
             else if(!strcmp(argv[i]+10,"segs"))
		tc_flag_clear = _TC_SEGS_ONLY;
             else if(!strcmp(argv[i]+10,"scalar"))
		tc_flag_clear = _TC_TO_SCALAR;
             else if(!strcmp(argv[i]+10,"aggr"))
		tc_flag_clear = _TC_TO_AGGR;
             else if(!strcmp(argv[i]+10,"highest"))
		tc_flag_clear = _TC_TO_HIGHEST;
             else fprintf(stderr, "TC: Unrecognized -tc- flag ignored (%s)\n", argv[i]);
      } else if(!strncmp(argv[i]+4,"stream-",7)){
             int stream_id;
             const char * fname = 0;

             stream_id = stringToStreamId(argv[i]+11, &fname);
             if(fname && *fname == '=') fname++;
             if(stream_id != -1 && stream_id != _tc_null){
               if(!strcmp(fname,"")){
                 streams[stream_id] = 0;
                 fprintf(stderr, "TC: Disabling %s stream\n", stream_descr[stream_id]);
               } else if(!strcmp(fname,"-")){
                 streams[stream_id] = stdout;
                 fprintf(stderr, "TC: Setting %s stream to stdout\n", stream_descr[stream_id]);
               } else if(!strcmp(fname,"=")){
                 streams[stream_id] = stderr;
                 fprintf(stderr, "TC: Setting %s stream to stderr\n", stream_descr[stream_id]);
               } else {
                 if((streams[stream_id] = fopen(fname, "w")))
                   fprintf(stderr, "TC: Redirecting %s stream to file %s\n", stream_descr[stream_id], fname);
                 else
                   fprintf(stderr, "TC: Error opening file %s for %s output\n", fname, stream_descr[stream_id]);
               }
             } else fprintf(stderr, "TC: Malformed -tc- flag ignored (%s)\n", argv[i]);
      } else fprintf(stderr, "TC: Unrecognized -tc- flag ignored (%s)\n", argv[i]);

      for(j = i+1; j < argc; ++j) argv[j-1] = argv[j];
      argv[--argc] = 0;
      i--;
    }
  }

  /* Initialize globals and externs */
  _tc_init_mode = 1;
  TC_DO_TIMINGS(getrusage(RUSAGE_SELF, &ru1));
  callInitFunctions();
  TC_DO_TIMINGS(getrusage(RUSAGE_SELF, &ru2));
  processExternVars();
  TC_DO_TIMINGS(getrusage(RUSAGE_SELF, &ru3));
  _tc_init_mode = 0;

  /* debug output */
  if(streams[_tc_debug])
    fprintf(streams[_tc_debug], "Debug: running tcptr version\n");

  /* initialize argv */
  for(i = 0; i < argc; ++i){
    _setScalarTag(__FILE__,__LINE__,0,&argv[i],_ctype_pointer);
    _setStringTag(__FILE__,__LINE__,0,argv[i],strlen(argv[i]));
  }
  /* (terminating null pointer) */
  _setScalarTag(__FILE__,__LINE__,0,&argv[i],_ctype_pointer);

  TC_DO_TIMINGS(getrusage(RUSAGE_SELF, &ru4));
  return _prog_main(argc, argv);
}

d2464 1
@
